//go:build manual_api_test
// +build manual_api_test

// Package e2e contains end-to-end tests for the thinktank CLI
// These tests require a valid API key to run properly and are skipped by default
// To run these tests: go test -tags=manual_api_test ./internal/e2e/...
package e2e

import (
	"fmt"
	"net/http"
	"path/filepath"
	"strings"
	"testing"
)

// Constants for the mock synthesis responses
const (
	mockSynthesisContent = "# Synthesized Plan\n\nThis is a synthesized plan combining outputs from multiple models."
)

// setupSynthesisTest sets up a new TestEnv with mock handlers configured for synthesis tests
func setupSynthesisTest(t *testing.T) *TestEnv {
	t.Helper()

	// Create a new test environment
	env := NewTestEnv(t)

	// Set up test files
	// Create the basic test files, the actual instructions file will be used in each test
	env.CreateTestFile("instructions.md", "Implement a new feature with multiple models and synthesis")
	env.CreateTestFile("src/main.go", CreateGoSourceFileContent())

	// Store original mock handlers to restore later
	originalHandleModelInfo := env.MockConfig.HandleModelInfo
	originalHandleGeneration := env.MockConfig.HandleGeneration

	// Update mock handlers to handle multiple models and synthesis
	env.MockConfig.HandleModelInfo = func(req *http.Request) (string, int, int, error) {
		// Extract model name from URL path
		path := req.URL.Path
		modelName := path[strings.LastIndex(path, "/")+1:]
		return modelName, 100000, 8192, nil
	}

	env.MockConfig.HandleGeneration = func(req *http.Request) (string, int, string, error) {
		// Extract model name from URL path
		path := req.URL.Path
		parts := strings.Split(path, "/")
		modelName := parts[len(parts)-2]

		// If this is the synthesis model, return synthesized content
		if strings.Contains(modelName, "synthesis") {
			return mockSynthesisContent, mockGenerationTokenUsed, mockFinishReason, nil
		}

		// For regular models, generate model-specific content
		return fmt.Sprintf("# Plan generated by %s\n\nThis is a test plan from %s.", modelName, modelName),
			mockGenerationTokenUsed,
			mockFinishReason,
			nil
	}

	// Add cleanup to restore original handlers
	t.Cleanup(func() {
		env.MockConfig.HandleModelInfo = originalHandleModelInfo
		env.MockConfig.HandleGeneration = originalHandleGeneration
		env.Cleanup()
	})

	return env
}

// verifySynthesisOutput checks for the expected synthesis output file
func verifySynthesisOutput(t *testing.T, env *TestEnv, synthesisModel string, outputDir string) {
	t.Helper()

	// Check for the synthesis output file
	synthesisOutputPath := filepath.Join(outputDir, synthesisModel+"-synthesis.md")
	if !env.FileExists(synthesisOutputPath) {
		t.Logf("Synthesis output file not found: %s (may be acceptable in mock environment)", synthesisOutputPath)
	} else {
		t.Logf("Synthesis output file exists: %s", synthesisOutputPath)

		// Read the file content
		content, err := env.ReadFile(synthesisOutputPath)
		if err != nil {
			t.Logf("Failed to read synthesis output file: %v", err)
		} else {
			// Verify synthesis content
			if !strings.Contains(content, "Synthesized Plan") {
				t.Logf("Synthesis output file does not contain expected content")
			} else {
				t.Logf("Synthesis output file contains expected content")
			}
		}
	}
}

// verifyModelOutputs checks for the expected individual model output files
func verifyModelOutputs(t *testing.T, env *TestEnv, modelNames []string, outputDir string) {
	t.Helper()

	// Check each model output file
	for _, modelName := range modelNames {
		outputPath := filepath.Join(outputDir, modelName+".md")
		if !env.FileExists(outputPath) {
			t.Logf("Model output file not found: %s (may be acceptable in mock environment)", outputPath)
		} else {
			t.Logf("Model output file exists: %s", outputPath)

			// Read the file content
			content, err := env.ReadFile(outputPath)
			if err != nil {
				t.Logf("Failed to read model output file: %v", err)
			} else {
				// Verify model-specific content
				expectedContent := fmt.Sprintf("Plan generated by %s", modelName)
				if !strings.Contains(content, expectedContent) {
					t.Logf("Model output file does not contain expected content")
				} else {
					t.Logf("Model output file contains expected content for model %s", modelName)
				}
			}
		}
	}
}

// TestSynthesisBasic is a placeholder for the basic synthesis workflow test (T028)
// This will be implemented in the T028 ticket
func TestSynthesisBasic(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping e2e test in short mode")
	}

	t.Skip("TODO: This test will be implemented in T028")

	// This test will verify:
	// 1. Running thinktank with multiple models and a synthesis model
	// 2. Checking that individual model outputs are generated
	// 3. Verifying the synthesis output is generated correctly
}

// TestSynthesisModelFailures is a placeholder for the model failures test (T029)
// This will be implemented in the T029 ticket
func TestSynthesisModelFailures(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping e2e test in short mode")
	}

	t.Skip("TODO: This test will be implemented in T029")

	// This test will verify:
	// 1. Running thinktank with multiple models where some primary models fail
	// 2. Checking that outputs are generated for successful models
	// 3. Verifying the synthesis output is generated using available outputs
}
