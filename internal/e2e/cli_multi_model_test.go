package e2e

import (
	"fmt"
	"net/http"
	"path/filepath"
	"strings"
	"testing"
)

// TestMultipleModels tests using multiple --model flags
func TestMultipleModels(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping e2e test in short mode")
	}

	// Create a new test environment
	env := NewTestEnv(t)
	defer env.Cleanup()

	// Create test files
	instructionsFile := env.CreateTestFile("instructions.md", "Implement a new feature")
	env.CreateTestFile("src/main.go", `package main

import "fmt"

func main() {
	fmt.Println("Hello, world!")
}`)

	// Set up the output directory
	outputDir := filepath.Join(env.TempDir, "output")

	// Define multiple model names
	modelNames := []string{"model1", "model2", "model3"}

	// Set up flags
	flags := env.DefaultFlags
	flags.Instructions = instructionsFile
	flags.OutputDir = outputDir
	flags.ModelNames = modelNames

	// Set up the mock server to handle different models
	originalHandleModelInfo := env.MockConfig.HandleModelInfo
	originalHandleGeneration := env.MockConfig.HandleGeneration

	// Update mock handlers to handle multiple models
	env.MockConfig.HandleModelInfo = func(req *http.Request) (string, int, int, error) {
		// Extract model name from URL path
		path := req.URL.Path
		modelName := path[strings.LastIndex(path, "/")+1:]
		return modelName, 100000, 8192, nil
	}

	env.MockConfig.HandleGeneration = func(req *http.Request) (string, int, string, error) {
		// Extract model name from URL path
		path := req.URL.Path
		parts := strings.Split(path, "/")
		modelName := parts[len(parts)-2]

		// Generate model-specific content
		return fmt.Sprintf("# Plan generated by %s\n\nThis is a test plan.", modelName),
			mockGenerationTokenUsed,
			mockFinishReason,
			nil
	}

	// Restore original handlers when done
	defer func() {
		env.MockConfig.HandleModelInfo = originalHandleModelInfo
		env.MockConfig.HandleGeneration = originalHandleGeneration
	}()

	// Run the architect binary
	stdout, stderr, exitCode, err := env.RunWithFlags(flags, []string{filepath.Join(env.TempDir, "src")})
	if err != nil {
		t.Fatalf("Failed to run architect: %v", err)
	}

	// Verify exit code
	if exitCode != 0 {
		t.Errorf("Expected exit code 0, got %d", exitCode)
		t.Logf("Stdout: %s", stdout)
		t.Logf("Stderr: %s", stderr)
	}

	// Verify output files were created for each model
	for _, modelName := range modelNames {
		outputFile := filepath.Join("output", modelName+".md")
		if !env.FileExists(outputFile) {
			t.Errorf("Output file for model %s was not created at %s", modelName, outputFile)
			continue
		}

		// Verify output file content
		content, err := env.ReadFile(outputFile)
		if err != nil {
			t.Fatalf("Failed to read output file for model %s: %v", modelName, err)
		}

		expectedContent := fmt.Sprintf("Plan generated by %s", modelName)
		if !strings.Contains(content, expectedContent) {
			t.Errorf("Output file for model %s does not contain expected content", modelName)
		}
	}

	// Verify stdout/stderr contains information about each model
	combinedOutput := stdout + stderr
	for _, modelName := range modelNames {
		if !strings.Contains(combinedOutput, modelName) {
			t.Errorf("Output does not contain information about model %s", modelName)
		}
	}
}

// TestModelError tests error handling for model-specific errors
func TestModelError(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping e2e test in short mode")
	}

	// Create a new test environment
	env := NewTestEnv(t)
	defer env.Cleanup()

	// Create test files
	instructionsFile := env.CreateTestFile("instructions.md", "Implement a new feature")
	env.CreateTestFile("src/main.go", `package main

func main() {}`)

	// Set up the output directory
	outputDir := filepath.Join(env.TempDir, "output")

	// Set up flags
	flags := env.DefaultFlags
	flags.Instructions = instructionsFile
	flags.OutputDir = outputDir
	flags.ModelNames = []string{"error-model", "success-model"}

	// Set up the mock server to simulate errors for one model
	originalHandleGeneration := env.MockConfig.HandleGeneration

	// Update mock handler to return an error for the error-model
	env.MockConfig.HandleGeneration = func(req *http.Request) (string, int, string, error) {
		// Extract model name from URL path
		path := req.URL.Path
		if strings.Contains(path, "error-model") {
			return "", 0, "", fmt.Errorf("simulated API error for error-model")
		}
		return "# Success model plan", mockGenerationTokenUsed, mockFinishReason, nil
	}

	// Restore original handler when done
	defer func() {
		env.MockConfig.HandleGeneration = originalHandleGeneration
	}()

	// Run the architect binary
	stdout, stderr, exitCode, err := env.RunWithFlags(flags, []string{filepath.Join(env.TempDir, "src")})
	if err != nil {
		t.Fatalf("Failed to run architect: %v", err)
	}

	// Verify exit code (should be non-zero due to the error)
	if exitCode == 0 {
		t.Errorf("Expected non-zero exit code, got 0")
		t.Logf("Stdout: %s", stdout)
		t.Logf("Stderr: %s", stderr)
	}

	// Verify error message in output
	combinedOutput := stdout + stderr
	if !strings.Contains(combinedOutput, "error-model") || !strings.Contains(combinedOutput, "error") {
		t.Errorf("Output does not contain error information for error-model")
	}

	// Verify the success-model output file is NOT created (execution should stop on first error)
	successFile := filepath.Join("output", "success-model.md")
	if env.FileExists(successFile) {
		t.Errorf("Output file for success-model was created despite error in error-model")
	}
}
