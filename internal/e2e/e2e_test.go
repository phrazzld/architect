// Package e2e contains end-to-end tests for the architect CLI
package e2e

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/http/httptest"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
)

// architectBinaryPath stores the path to the compiled binary, set once in TestMain
var architectBinaryPath string

const (
	// Mock API responses
	mockTokenCount          = 1000
	mockGeneratedContent    = "# Test Generated Plan\n\nThis is a test plan generated by the mock API."
	mockGenerationTokenUsed = 500
	mockFinishReason        = "STOP"
)

// mockGeminiResponse is currently unused but kept for potential future use
// TODO: Consider removing if not needed in future iterations
// type mockGeminiResponse struct {
//    Content      string `json:"content"`
//    TokenCount   int    `json:"tokenCount"`
//    FinishReason string `json:"finishReason"`
// }

// mockGeminiError represents the structure of a Gemini API error response
type mockGeminiError struct {
	Error struct {
		Message    string `json:"message"`
		StatusCode int    `json:"statusCode"`
		Suggestion string `json:"suggestion"`
	} `json:"error"`
}

// testFlags holds predefined flags for convenient reuse in tests
type testFlags struct {
	Instructions   string
	OutputDir      string
	ModelNames     []string
	APIKey         string
	Include        string
	Exclude        string
	ExcludeNames   string
	DryRun         bool
	ConfirmTokens  int
	Verbose        bool
	LogLevel       string
	AuditLogFile   string
	ForceOverwrite bool
}

// TestEnv represents the test environment for e2e tests
type TestEnv struct {
	// Testing context
	t *testing.T

	// Temporary directory for the test
	TempDir string

	// Compiled binary path
	BinaryPath string

	// Mock HTTP server for the Gemini API
	MockServer *httptest.Server

	// Configuration for the mock server
	MockConfig struct {
		// Function to handle token counting requests
		HandleTokenCount func(req *http.Request) (int, error)

		// Function to handle generation requests
		HandleGeneration func(req *http.Request) (string, int, string, error)

		// Function to handle model info requests
		HandleModelInfo func(req *http.Request) (string, int, int, error)
	}

	// Default test flags
	DefaultFlags testFlags
}

// NewTestEnv creates a new test environment
func NewTestEnv(t *testing.T) *TestEnv {
	t.Helper()

	// Create a temporary directory for the test
	tempDir := t.TempDir()

	// Ensure the binary path was set by TestMain
	if architectBinaryPath == "" {
		// This should not happen if TestMain ran correctly
		t.Fatal("FATAL: architectBinaryPath not set by TestMain. E2E test setup failed.")
	}

	// Initialize the test environment using the binary path set by TestMain
	env := &TestEnv{
		t:          t,
		TempDir:    tempDir,
		BinaryPath: architectBinaryPath,
	}

	// Set up default mock handlers
	env.MockConfig.HandleTokenCount = func(req *http.Request) (int, error) {
		return mockTokenCount, nil
	}

	env.MockConfig.HandleGeneration = func(req *http.Request) (string, int, string, error) {
		return mockGeneratedContent, mockGenerationTokenUsed, mockFinishReason, nil
	}

	env.MockConfig.HandleModelInfo = func(req *http.Request) (string, int, int, error) {
		return "gemini-model", 100000, 8192, nil
	}

	// Start the mock server
	env.startMockServer()

	// Set up default test flags
	env.DefaultFlags = testFlags{
		Instructions:  "", // Will be set by specific tests
		OutputDir:     filepath.Join(tempDir, "output"),
		ModelNames:    []string{"test-model"},
		APIKey:        "test-api-key",
		Include:       "",
		Exclude:       ".git,node_modules",
		ExcludeNames:  ".git,node_modules",
		DryRun:        false,
		ConfirmTokens: 0,
		Verbose:       false,
		LogLevel:      "info",
		AuditLogFile:  "",
	}

	return env
}

// Cleanup performs cleanup operations after the test
func (e *TestEnv) Cleanup() {
	// Shutdown the mock server if it exists
	if e.MockServer != nil {
		e.MockServer.Close()
	}
}

// startMockServer starts a mock HTTP server for the Gemini API
func (e *TestEnv) startMockServer() {
	handler := http.NewServeMux()

	// Generic handler for any model-related endpoint
	handler.HandleFunc("/v1beta/models/", func(w http.ResponseWriter, r *http.Request) {
		path := r.URL.Path

		// Handle token counting endpoint
		if strings.HasSuffix(path, ":countTokens") {
			count, err := e.MockConfig.HandleTokenCount(r)
			if err != nil {
				w.WriteHeader(http.StatusBadRequest)
				if encodeErr := json.NewEncoder(w).Encode(mockGeminiError{
					Error: struct {
						Message    string "json:\"message\""
						StatusCode int    "json:\"statusCode\""
						Suggestion string "json:\"suggestion\""
					}{
						Message:    err.Error(),
						StatusCode: http.StatusBadRequest,
						Suggestion: "Check your request parameters",
					},
				}); encodeErr != nil {
					e.t.Logf("Failed to encode error response: %v", encodeErr)
				}
				return
			}

			w.Header().Set("Content-Type", "application/json")
			if encodeErr := json.NewEncoder(w).Encode(map[string]interface{}{
				"totalTokens": count,
			}); encodeErr != nil {
				e.t.Logf("Failed to encode response: %v", encodeErr)
			}
			return
		}

		// Handle generation endpoint
		if strings.HasSuffix(path, ":generateContent") {
			content, tokens, finishReason, err := e.MockConfig.HandleGeneration(r)
			if err != nil {
				w.WriteHeader(http.StatusBadRequest)
				if encodeErr := json.NewEncoder(w).Encode(mockGeminiError{
					Error: struct {
						Message    string "json:\"message\""
						StatusCode int    "json:\"statusCode\""
						Suggestion string "json:\"suggestion\""
					}{
						Message:    err.Error(),
						StatusCode: http.StatusBadRequest,
						Suggestion: "Check your request parameters",
					},
				}); encodeErr != nil {
					e.t.Logf("Failed to encode error response: %v", encodeErr)
				}
				return
			}

			w.Header().Set("Content-Type", "application/json")
			if encodeErr := json.NewEncoder(w).Encode(map[string]interface{}{
				"candidates": []map[string]interface{}{
					{
						"content": map[string]interface{}{
							"parts": []map[string]interface{}{
								{
									"text": content,
								},
							},
						},
					},
				},
				"usageMetadata": map[string]interface{}{
					"totalTokenCount": tokens,
				},
				"finishReason": finishReason,
			}); encodeErr != nil {
				e.t.Logf("Failed to encode response: %v", encodeErr)
			}
			return
		}

		// Handle model info endpoint (default case for model path without action)
		if !strings.Contains(path, ":") {
			name, inputLimit, outputLimit, err := e.MockConfig.HandleModelInfo(r)
			if err != nil {
				w.WriteHeader(http.StatusBadRequest)
				if encodeErr := json.NewEncoder(w).Encode(mockGeminiError{
					Error: struct {
						Message    string "json:\"message\""
						StatusCode int    "json:\"statusCode\""
						Suggestion string "json:\"suggestion\""
					}{
						Message:    err.Error(),
						StatusCode: http.StatusBadRequest,
						Suggestion: "Check your request parameters",
					},
				}); encodeErr != nil {
					e.t.Logf("Failed to encode error response: %v", encodeErr)
				}
				return
			}

			w.Header().Set("Content-Type", "application/json")
			if encodeErr := json.NewEncoder(w).Encode(map[string]interface{}{
				"name":             name,
				"inputTokenLimit":  inputLimit,
				"outputTokenLimit": outputLimit,
			}); encodeErr != nil {
				e.t.Logf("Failed to encode response: %v", encodeErr)
			}
			return
		}

		// If we get here, we didn't handle the request
		w.WriteHeader(http.StatusNotFound)
		if encodeErr := json.NewEncoder(w).Encode(mockGeminiError{
			Error: struct {
				Message    string "json:\"message\""
				StatusCode int    "json:\"statusCode\""
				Suggestion string "json:\"suggestion\""
			}{
				Message:    "Endpoint not found",
				StatusCode: http.StatusNotFound,
				Suggestion: "Check the API documentation for available endpoints",
			},
		}); encodeErr != nil {
			e.t.Logf("Failed to encode error response: %v", encodeErr)
		}
	})

	// Create and start the mock server
	e.MockServer = httptest.NewServer(handler)
}

// CreateTestFile creates a file in the test environment with the given content
func (e *TestEnv) CreateTestFile(relativePath, content string) string {
	e.t.Helper()

	// Create the full path
	fullPath := filepath.Join(e.TempDir, relativePath)

	// Ensure parent directories exist
	dir := filepath.Dir(fullPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		e.t.Fatalf("Failed to create directory %s: %v", dir, err)
	}

	// Write the file
	if err := os.WriteFile(fullPath, []byte(content), 0644); err != nil {
		e.t.Fatalf("Failed to write file %s: %v", fullPath, err)
	}

	return fullPath
}

// CreateTestDirectory creates a directory in the test environment
func (e *TestEnv) CreateTestDirectory(relativePath string) string {
	e.t.Helper()

	// Create the full path
	fullPath := filepath.Join(e.TempDir, relativePath)

	// Create the directory
	if err := os.MkdirAll(fullPath, 0755); err != nil {
		e.t.Fatalf("Failed to create directory %s: %v", fullPath, err)
	}

	return fullPath
}

// RunArchitect runs the architect binary with the provided arguments
func (e *TestEnv) RunArchitect(args []string, stdin io.Reader) (stdout, stderr string, exitCode int, err error) {
	e.t.Helper()

	// Create buffers for stdout and stderr
	stdoutBuf := &bytes.Buffer{}
	stderrBuf := &bytes.Buffer{}

	// Create the command
	cmd := exec.Command(e.BinaryPath, args...)

	// Set up stdin, stdout, and stderr
	cmd.Stdin = stdin
	cmd.Stdout = stdoutBuf
	cmd.Stderr = stderrBuf

	// Set the working directory
	cmd.Dir = e.TempDir

	// Set up environment variables with mock server URL and API key
	cmd.Env = append(os.Environ(),
		fmt.Sprintf("GEMINI_API_KEY=%s", e.DefaultFlags.APIKey),
		fmt.Sprintf("GEMINI_API_URL=%s", e.MockServer.URL),
		// Add any other required environment variables for testing
		"GEMINI_API_KEY_SOURCE=env", // Force it to use env var
	)

	// Run the command
	runErr := cmd.Run()

	// Extract the exit code
	exitCode = 0
	if runErr != nil {
		if exitErr, ok := runErr.(*exec.ExitError); ok {
			exitCode = exitErr.ExitCode()
		} else {
			return stdoutBuf.String(), stderrBuf.String(), exitCode, fmt.Errorf("failed to run command: %v", runErr)
		}
	}

	return stdoutBuf.String(), stderrBuf.String(), exitCode, nil
}

// RunWithFlags runs the architect binary with the provided flags and additional arguments
func (e *TestEnv) RunWithFlags(flags testFlags, additionalArgs []string) (stdout, stderr string, exitCode int, err error) {
	e.t.Helper()

	// Construct arguments
	args := []string{}

	// Add flags
	if flags.Instructions != "" {
		instructionsFile := e.CreateTestFile("instructions.md", "Test instructions")
		args = append(args, "--instructions", instructionsFile)
	}

	if flags.OutputDir != "" {
		args = append(args, "--output-dir", flags.OutputDir)
	}

	for _, model := range flags.ModelNames {
		args = append(args, "--model", model)
	}

	if flags.Include != "" {
		args = append(args, "--include", flags.Include)
	}

	if flags.Exclude != "" {
		args = append(args, "--exclude", flags.Exclude)
	}

	if flags.ExcludeNames != "" {
		args = append(args, "--exclude-names", flags.ExcludeNames)
	}

	if flags.DryRun {
		args = append(args, "--dry-run")
	}

	if flags.ConfirmTokens > 0 {
		args = append(args, "--confirm-tokens", fmt.Sprintf("%d", flags.ConfirmTokens))
	}

	if flags.Verbose {
		args = append(args, "--verbose")
	}

	if flags.LogLevel != "" {
		args = append(args, "--log-level", flags.LogLevel)
	}

	if flags.AuditLogFile != "" {
		args = append(args, "--audit-log-file", flags.AuditLogFile)
	}

	if flags.ForceOverwrite {
		args = append(args, "--force-overwrite")
	}

	// Add additional arguments
	args = append(args, additionalArgs...)

	// Run the command
	return e.RunArchitect(args, nil)
}

// findOrBuildBinary locates or builds the architect binary
func findOrBuildBinary() (string, error) {
	// Determine the project root directory relative to this test file
	projectRoot, err := os.Getwd() // Start from current dir
	if err != nil {
		return "", fmt.Errorf("failed to get current working directory: %v", err)
	}

	// If tests are run from within internal/e2e, go up two levels
	if strings.HasSuffix(projectRoot, "internal/e2e") {
		projectRoot = filepath.Dir(filepath.Dir(projectRoot))
	} else if strings.HasSuffix(projectRoot, "e2e") { // If run from e2e directly
		projectRoot = filepath.Dir(projectRoot)
	}
	// Additional logic could be added here to detect the project root more robustly
	// e.g., searching upward for go.mod file

	// Define potential binary locations relative to the project root
	binaryName := "architect"
	if os.PathSeparator == '\\' { // Handle Windows executable extension
		binaryName += ".exe"
	}

	candidates := []string{
		filepath.Join(projectRoot, binaryName),
		filepath.Join(projectRoot, "bin", binaryName),
		// Add additional common locations if needed
	}

	// Check for existing binary
	for _, candidate := range candidates {
		if _, err := os.Stat(candidate); err == nil {
			absPath, err := filepath.Abs(candidate)
			if err != nil {
				return "", fmt.Errorf("failed to get absolute path for %s: %v", candidate, err)
			}
			fmt.Printf("Found architect binary at: %s\n", absPath)
			return absPath, nil
		}
	}

	// If not found, build it
	fmt.Println("Architect binary not found, building from source...")
	buildOutput := filepath.Join(projectRoot, binaryName)

	// Build command targeting the main package
	cmd := exec.Command("go", "build", "-o", buildOutput, "github.com/phrazzld/architect/cmd/architect")
	cmd.Dir = projectRoot // Ensure the build runs from the project root
	stdout := &bytes.Buffer{}
	stderr := &bytes.Buffer{}
	cmd.Stdout = stdout
	cmd.Stderr = stderr

	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("failed to build architect binary: %v\nBuild Directory: %s\nStdout: %s\nStderr: %s",
			err, projectRoot, stdout.String(), stderr.String())
	}

	// Verify the binary was built
	if _, err := os.Stat(buildOutput); err != nil {
		return "", fmt.Errorf("failed to find built binary at %s after build attempt: %v", buildOutput, err)
	}

	absPath, err := filepath.Abs(buildOutput)
	if err != nil {
		return "", fmt.Errorf("failed to get absolute path for built binary: %v", err)
	}

	fmt.Printf("Successfully built architect binary at: %s\n", absPath)
	return absPath, nil
}

// FileExists checks if a file exists in the test environment
func (e *TestEnv) FileExists(relativePath string) bool {
	fullPath := filepath.Join(e.TempDir, relativePath)
	_, err := os.Stat(fullPath)
	return err == nil
}

// ReadFile reads a file from the test environment
func (e *TestEnv) ReadFile(relativePath string) (string, error) {
	fullPath := filepath.Join(e.TempDir, relativePath)
	content, err := os.ReadFile(fullPath)
	if err != nil {
		return "", err
	}
	return string(content), nil
}

// SimulateUserInput returns a reader that simulates user input
func SimulateUserInput(input string) io.Reader {
	return strings.NewReader(input)
}

// TestMain runs once before all tests in the package.
// It finds or builds the architect binary needed for the tests.
func TestMain(m *testing.M) {
	// Find or build the binary only once for all tests
	var err error
	architectBinaryPath, err = findOrBuildBinary()
	if err != nil {
		// Use log.Fatalf for cleaner exit on failure during setup
		log.Fatalf("FATAL: Failed to find or build architect binary for E2E tests: %v", err)
	}

	// Run all tests in the package
	exitCode := m.Run()

	// Perform any global cleanup here if needed
	// Note: we don't remove the binary as it might be reused in subsequent test runs

	// Exit with the status code from the test run
	os.Exit(exitCode)
}
