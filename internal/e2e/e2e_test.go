//go:build manual_api_test
// +build manual_api_test

// Package e2e contains end-to-end tests for the architect CLI
// These tests require a valid API key to run properly and are skipped by default
// To run these tests: go test -tags=manual_api_test ./internal/e2e/...
package e2e

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/http/httptest"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
)

// architectBinaryPath stores the path to the compiled binary, set once in TestMain
var architectBinaryPath string

const (
	// Mock API responses
	mockTokenCount          = 1000
	mockGeneratedContent    = "# Test Generated Plan\n\nThis is a test plan generated by the mock API."
	mockGenerationTokenUsed = 500
	mockFinishReason        = "STOP"
)

// mockGeminiResponse is currently unused but kept for potential future use
// TODO: Consider removing if not needed in future iterations
// type mockGeminiResponse struct {
//    Content      string `json:"content"`
//    TokenCount   int    `json:"tokenCount"`
//    FinishReason string `json:"finishReason"`
// }

// mockGeminiError represents the structure of a Gemini API error response
type mockGeminiError struct {
	Error struct {
		Message    string `json:"message"`
		StatusCode int    `json:"statusCode"`
		Suggestion string `json:"suggestion"`
	} `json:"error"`
}

// testFlags holds predefined flags for convenient reuse in tests
type testFlags struct {
	Instructions   string
	OutputDir      string
	ModelNames     []string
	APIKey         string
	Include        string
	Exclude        string
	ExcludeNames   string
	DryRun         bool
	ConfirmTokens  int
	Verbose        bool
	LogLevel       string
	AuditLogFile   string
	ForceOverwrite bool
}

// TestEnv represents the test environment for e2e tests
type TestEnv struct {
	// Testing context
	t *testing.T

	// Temporary directory for the test
	TempDir string

	// Compiled binary path
	BinaryPath string

	// Mock HTTP server for the Gemini API
	MockServer *httptest.Server

	// Configuration for the mock server
	MockConfig struct {
		// Function to handle token counting requests
		HandleTokenCount func(req *http.Request) (int, error)

		// Function to handle generation requests
		HandleGeneration func(req *http.Request) (string, int, string, error)

		// Function to handle model info requests
		HandleModelInfo func(req *http.Request) (string, int, int, error)
	}

	// Default test flags
	DefaultFlags testFlags
}

// NewTestEnv creates a new test environment
func NewTestEnv(t *testing.T) *TestEnv {
	t.Helper()

	// Create a temporary directory for the test
	tempDir := t.TempDir()

	// Ensure the binary path was set by TestMain
	if architectBinaryPath == "" {
		// This should not happen if TestMain ran correctly
		t.Fatal("FATAL: architectBinaryPath not set by TestMain. E2E test setup failed.")
	}

	// Initialize the test environment using the binary path set by TestMain
	env := &TestEnv{
		t:          t,
		TempDir:    tempDir,
		BinaryPath: architectBinaryPath,
	}

	// Set up default mock handlers
	env.MockConfig.HandleTokenCount = func(req *http.Request) (int, error) {
		return mockTokenCount, nil
	}

	env.MockConfig.HandleGeneration = func(req *http.Request) (string, int, string, error) {
		return mockGeneratedContent, mockGenerationTokenUsed, mockFinishReason, nil
	}

	env.MockConfig.HandleModelInfo = func(req *http.Request) (string, int, int, error) {
		return "gemini-model", 100000, 8192, nil
	}

	// Start the mock server
	env.startMockServer()

	// Set up default test flags
	env.DefaultFlags = testFlags{
		Instructions:  "", // Will be set by specific tests
		OutputDir:     filepath.Join(tempDir, "output"),
		ModelNames:    []string{"gemini-test-model"}, // Match model name used in mock server
		APIKey:        "test-api-key",
		Include:       "",
		Exclude:       ".git,node_modules",
		ExcludeNames:  ".git,node_modules",
		DryRun:        false,
		ConfirmTokens: 0,
		Verbose:       false,
		LogLevel:      "info",
		AuditLogFile:  "",
	}

	return env
}

// Cleanup performs cleanup operations after the test
func (e *TestEnv) Cleanup() {
	// Shutdown the mock server if it exists
	if e.MockServer != nil {
		e.MockServer.Close()
	}
}

// startMockServer starts a mock HTTP server for the Gemini API
func (e *TestEnv) startMockServer() {
	handler := http.NewServeMux()

	// Handler for direct API client access to bypass the complex Google client
	// Use a pattern that matches what the Gemini client expects
	handler.HandleFunc("/v1/models/", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		// Return a valid model info response
		if err := json.NewEncoder(w).Encode(map[string]interface{}{
			"name":                       "gemini-test-model",
			"version":                    "001",
			"displayName":                "Test Model",
			"description":                "Test model for E2E tests",
			"inputTokenLimit":            100000,
			"outputTokenLimit":           8192,
			"supportedGenerationMethods": []string{"generateContent", "countTokens"},
		}); err != nil {
			e.t.Logf("Failed to encode model info response: %v", err)
		}
	})

	// Handle content generation requests
	handler.HandleFunc("/v1/models/gemini-test-model:generateContent", func(w http.ResponseWriter, r *http.Request) {
		content, tokens, finishReason, err := e.MockConfig.HandleGeneration(r)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			json.NewEncoder(w).Encode(map[string]interface{}{
				"error": map[string]interface{}{
					"code":    400,
					"message": err.Error(),
					"status":  "INVALID_ARGUMENT",
				},
			})
			return
		}

		w.Header().Set("Content-Type", "application/json")
		if err := json.NewEncoder(w).Encode(map[string]interface{}{
			"candidates": []map[string]interface{}{
				{
					"content": map[string]interface{}{
						"parts": []map[string]interface{}{
							{
								"text": content,
							},
						},
						"role": "model",
					},
					"finishReason": finishReason,
					"safetyRatings": []map[string]interface{}{
						{
							"category":    "HARM_CATEGORY_DANGEROUS_CONTENT",
							"probability": "NEGLIGIBLE",
						},
					},
				},
			},
			"promptFeedback": map[string]interface{}{
				"safetyRatings": []map[string]interface{}{
					{
						"category":    "HARM_CATEGORY_DANGEROUS_CONTENT",
						"probability": "NEGLIGIBLE",
					},
				},
			},
			"usageMetadata": map[string]interface{}{
				"promptTokenCount":     tokens / 2,
				"candidatesTokenCount": tokens / 2,
				"totalTokenCount":      tokens,
			},
		}); err != nil {
			e.t.Logf("Failed to encode generate content response: %v", err)
		}
	})

	// Handle token counting requests
	handler.HandleFunc("/v1/models/gemini-test-model:countTokens", func(w http.ResponseWriter, r *http.Request) {
		count, err := e.MockConfig.HandleTokenCount(r)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			json.NewEncoder(w).Encode(map[string]interface{}{
				"error": map[string]interface{}{
					"code":    400,
					"message": err.Error(),
					"status":  "INVALID_ARGUMENT",
				},
			})
			return
		}

		w.Header().Set("Content-Type", "application/json")
		if err := json.NewEncoder(w).Encode(map[string]interface{}{
			"totalTokens": count,
		}); err != nil {
			e.t.Logf("Failed to encode count tokens response: %v", err)
		}
	})

	// Create and start the mock server
	e.MockServer = httptest.NewServer(handler)
}

// CreateTestFile creates a file in the test environment with the given content
func (e *TestEnv) CreateTestFile(relativePath, content string) string {
	e.t.Helper()

	// Create the full path
	fullPath := filepath.Join(e.TempDir, relativePath)

	// Ensure parent directories exist
	dir := filepath.Dir(fullPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		e.t.Fatalf("Failed to create directory %s: %v", dir, err)
	}

	// Write the file
	if err := os.WriteFile(fullPath, []byte(content), 0644); err != nil {
		e.t.Fatalf("Failed to write file %s: %v", fullPath, err)
	}

	return fullPath
}

// CreateTestDirectory creates a directory in the test environment
func (e *TestEnv) CreateTestDirectory(relativePath string) string {
	e.t.Helper()

	// Create the full path
	fullPath := filepath.Join(e.TempDir, relativePath)

	// Create the directory
	if err := os.MkdirAll(fullPath, 0755); err != nil {
		e.t.Fatalf("Failed to create directory %s: %v", fullPath, err)
	}

	return fullPath
}

// RunArchitect runs the architect binary with the provided arguments
func (e *TestEnv) RunArchitect(args []string, stdin io.Reader) (stdout, stderr string, exitCode int, err error) {
	e.t.Helper()

	// Create buffers for stdout and stderr
	stdoutBuf := &bytes.Buffer{}
	stderrBuf := &bytes.Buffer{}

	// Create the command
	cmd := exec.Command(e.BinaryPath, args...)

	// Set up stdin, stdout, and stderr
	cmd.Stdin = stdin
	cmd.Stdout = stdoutBuf
	cmd.Stderr = stderrBuf

	// Set the working directory
	cmd.Dir = e.TempDir

	// Set up environment variables with mock server URL and API key
	cmd.Env = append(os.Environ(),
		// Always set a valid API key value
		fmt.Sprintf("GEMINI_API_KEY=%s", "test-api-key"),

		// Set the mock server URL as the API endpoint
		fmt.Sprintf("GEMINI_API_URL=%s", e.MockServer.URL),

		// Hard-code the model name to match mock server path
		fmt.Sprintf("GEMINI_MODEL_NAME=%s", "gemini-test-model"),

		// Force env var source
		"GEMINI_API_KEY_SOURCE=env",

		// Debug mode for detailed logging
		"ARCHITECT_DEBUG=true",

		// Explicitly set PATH to ensure binary can find dependencies
		fmt.Sprintf("PATH=%s", os.Getenv("PATH")),
	)

	// Print debug info
	e.t.Logf("Running %s with environment: GEMINI_API_URL=%s", e.BinaryPath, e.MockServer.URL)

	// Run the command
	runErr := cmd.Run()

	// Extract the exit code
	exitCode = 0
	if runErr != nil {
		if exitErr, ok := runErr.(*exec.ExitError); ok {
			exitCode = exitErr.ExitCode()
		} else {
			return stdoutBuf.String(), stderrBuf.String(), exitCode, fmt.Errorf("failed to run command: %v", runErr)
		}
	}

	// For debugging: log output on non-zero exit codes
	if exitCode != 0 {
		e.t.Logf("Command exited with code %d\nStdout: %s\nStderr: %s",
			exitCode, stdoutBuf.String(), stderrBuf.String())
	}

	return stdoutBuf.String(), stderrBuf.String(), exitCode, nil
}

// RunWithFlags runs the architect binary with the provided flags and additional arguments
func (e *TestEnv) RunWithFlags(flags testFlags, additionalArgs []string) (stdout, stderr string, exitCode int, err error) {
	e.t.Helper()

	// Construct arguments
	args := []string{}

	// Add flags
	if flags.Instructions != "" {
		instructionsFile := e.CreateTestFile("instructions.md", "Test instructions")
		args = append(args, "--instructions", instructionsFile)
	}

	if flags.OutputDir != "" {
		args = append(args, "--output-dir", flags.OutputDir)
	}

	for _, model := range flags.ModelNames {
		args = append(args, "--model", model)
	}

	if flags.Include != "" {
		args = append(args, "--include", flags.Include)
	}

	if flags.Exclude != "" {
		args = append(args, "--exclude", flags.Exclude)
	}

	if flags.ExcludeNames != "" {
		args = append(args, "--exclude-names", flags.ExcludeNames)
	}

	if flags.DryRun {
		args = append(args, "--dry-run")
	}

	if flags.ConfirmTokens > 0 {
		args = append(args, "--confirm-tokens", fmt.Sprintf("%d", flags.ConfirmTokens))
	}

	if flags.Verbose {
		args = append(args, "--verbose")
	}

	if flags.LogLevel != "" {
		args = append(args, "--log-level", flags.LogLevel)
	}

	if flags.AuditLogFile != "" {
		args = append(args, "--audit-log-file", flags.AuditLogFile)
	}

	if flags.ForceOverwrite {
		args = append(args, "--force-overwrite")
	}

	// Add additional arguments
	args = append(args, additionalArgs...)

	// Run the command
	return e.RunArchitect(args, nil)
}

// findOrBuildBinary locates or builds the architect binary
func findOrBuildBinary() (string, error) {
	// Determine the project root directory relative to this test file
	projectRoot, err := os.Getwd() // Start from current dir
	if err != nil {
		return "", fmt.Errorf("failed to get current working directory: %v", err)
	}

	// If tests are run from within internal/e2e, go up two levels
	if strings.HasSuffix(projectRoot, "internal/e2e") {
		projectRoot = filepath.Dir(filepath.Dir(projectRoot))
	} else if strings.HasSuffix(projectRoot, "e2e") { // If run from e2e directly
		projectRoot = filepath.Dir(projectRoot)
	}
	// Additional logic could be added here to detect the project root more robustly
	// e.g., searching upward for go.mod file

	// Define potential binary locations relative to the project root
	binaryName := "architect"
	if os.PathSeparator == '\\' { // Handle Windows executable extension
		binaryName += ".exe"
	}

	candidates := []string{
		filepath.Join(projectRoot, binaryName),
		filepath.Join(projectRoot, "bin", binaryName),
		// Add additional common locations if needed
	}

	// Check for existing binary
	for _, candidate := range candidates {
		if _, err := os.Stat(candidate); err == nil {
			absPath, err := filepath.Abs(candidate)
			if err != nil {
				return "", fmt.Errorf("failed to get absolute path for %s: %v", candidate, err)
			}
			fmt.Printf("Found architect binary at: %s\n", absPath)
			return absPath, nil
		}
	}

	// If not found, build it
	fmt.Println("Architect binary not found, building from source...")
	buildOutput := filepath.Join(projectRoot, binaryName)

	// Build command targeting the main package
	cmd := exec.Command("go", "build", "-o", buildOutput, "github.com/phrazzld/architect/cmd/architect")
	cmd.Dir = projectRoot // Ensure the build runs from the project root
	stdout := &bytes.Buffer{}
	stderr := &bytes.Buffer{}
	cmd.Stdout = stdout
	cmd.Stderr = stderr

	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("failed to build architect binary: %v\nBuild Directory: %s\nStdout: %s\nStderr: %s",
			err, projectRoot, stdout.String(), stderr.String())
	}

	// Verify the binary was built
	if _, err := os.Stat(buildOutput); err != nil {
		return "", fmt.Errorf("failed to find built binary at %s after build attempt: %v", buildOutput, err)
	}

	absPath, err := filepath.Abs(buildOutput)
	if err != nil {
		return "", fmt.Errorf("failed to get absolute path for built binary: %v", err)
	}

	fmt.Printf("Successfully built architect binary at: %s\n", absPath)
	return absPath, nil
}

// FileExists checks if a file exists in the test environment
func (e *TestEnv) FileExists(relativePath string) bool {
	fullPath := filepath.Join(e.TempDir, relativePath)
	_, err := os.Stat(fullPath)
	return err == nil
}

// ReadFile reads a file from the test environment
func (e *TestEnv) ReadFile(relativePath string) (string, error) {
	fullPath := filepath.Join(e.TempDir, relativePath)
	content, err := os.ReadFile(fullPath)
	if err != nil {
		return "", err
	}
	return string(content), nil
}

// SimulateUserInput returns a reader that simulates user input
func SimulateUserInput(input string) io.Reader {
	return strings.NewReader(input)
}

// TestMain runs once before all tests in the package.
// It finds or builds the architect binary needed for the tests.
func TestMain(m *testing.M) {
	// Find or build the binary only once for all tests
	var err error
	architectBinaryPath, err = findOrBuildBinary()
	if err != nil {
		// Use log.Fatalf for cleaner exit on failure during setup
		log.Fatalf("FATAL: Failed to find or build architect binary for E2E tests: %v", err)
	}

	// Run all tests in the package
	exitCode := m.Run()

	// Perform any global cleanup here if needed
	// Note: we don't remove the binary as it might be reused in subsequent test runs

	// Exit with the status code from the test run
	os.Exit(exitCode)
}
