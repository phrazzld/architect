// internal/integration/filtering_test.go
package integration

import (
	"context"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/phrazzld/architect/internal/architect"
	"github.com/phrazzld/architect/internal/config"
	"github.com/phrazzld/architect/internal/gemini"
	"github.com/phrazzld/architect/internal/logutil"
)

// TestFilteringBehaviors tests file filtering functions using a table-driven approach
func TestFilteringBehaviors(t *testing.T) {
	// Define the test case struct for filtering scenarios
	type filterTestCase struct {
		name                string
		instructionsContent string
		fileContents        map[string]string
		includeFilter       string
		excludeFilter       string
		excludeNames        string
		outputShouldExist   bool
		expectedContent     string
		verifyFilteringFunc func(ctx context.Context, prompt string, params map[string]interface{}) (*gemini.GenerationResult, error)
	}

	// Define default files for filter tests
	defaultFiles := map[string]string{
		"src/main.go":       "package main\n\nfunc main() {}\n",
		"src/README.md":     "# Test Project",
		"src/config.json":   `{"key": "value"}`,
		"src/utils/util.js": "function helper() { return true; }",
	}

	// Define test cases based on the original filtering test
	tests := []filterTestCase{
		{
			name:                "Include Go and Markdown Files",
			instructionsContent: "Test task",
			fileContents:        defaultFiles,
			includeFilter:       ".go,.md", // Only include Go and Markdown files
			excludeFilter:       "",
			excludeNames:        "",
			outputShouldExist:   true,
			expectedContent:     "Test Generated Plan",
			verifyFilteringFunc: func(ctx context.Context, prompt string, params map[string]interface{}) (*gemini.GenerationResult, error) {
				// In a real implementation, we would check the actual context to ensure
				// that only Go and Markdown files are included
				// We're just returning a successful result here, but could add more verification
				return &gemini.GenerationResult{
					Content:      "# Test Generated Plan\n\nThis is a test plan generated by the mock client.",
					TokenCount:   1000,
					FinishReason: "STOP",
				}, nil
			},
		},
		// Additional filtering test cases could be added here
	}

	// Execute each test case
	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			// Set up test environment
			env := NewTestEnv(t)
			defer env.Cleanup()

			// Set up the custom mock client that verifies context content
			if tc.verifyFilteringFunc != nil {
				env.MockClient.GenerateContentFunc = tc.verifyFilteringFunc
			}

			// Create all the test files
			for path, content := range tc.fileContents {
				env.CreateTestFile(t, path, content)
			}

			// Create instructions file
			instructionsFile := env.CreateTestFile(t, "instructions.md", tc.instructionsContent)

			// Set up the output directory and model-specific output file path
			modelName := "test-model"
			outputDir := filepath.Join(env.TestDir, "output")
			outputFile := filepath.Join(outputDir, modelName+".md")

			// Create a test configuration with filtering options
			testConfig := &config.CliConfig{
				InstructionsFile: instructionsFile,
				OutputDir:        outputDir,
				ModelNames:       []string{modelName},
				APIKey:           "test-api-key",
				Include:          tc.includeFilter,
				Exclude:          tc.excludeFilter,
				ExcludeNames:     tc.excludeNames,
				Paths:            []string{env.TestDir + "/src"},
				LogLevel:         logutil.InfoLevel,
			}

			// Create a mock API service
			mockApiService := createMockAPIService(env)

			// Run the application with our test configuration
			ctx := context.Background()
			err := architect.Execute(
				ctx,
				testConfig,
				env.Logger,
				env.AuditLogger,
				mockApiService,
			)

			// Verify execution succeeded
			if err != nil {
				t.Fatalf("architect.Execute failed: %v", err)
			}

			// Check file existence based on expectation
			fileExists := false
			if _, err := os.Stat(outputFile); !os.IsNotExist(err) {
				fileExists = true
			}

			if tc.outputShouldExist && !fileExists {
				t.Errorf("Expected output file to exist, but it doesn't: %s", outputFile)
			} else if !tc.outputShouldExist && fileExists {
				t.Errorf("Output file was created when it shouldn't have been: %s", outputFile)
			}

			// Verify content if we expect the file to exist
			if tc.outputShouldExist && fileExists && tc.expectedContent != "" {
				content, err := os.ReadFile(outputFile)
				if err != nil {
					t.Fatalf("Failed to read output file: %v", err)
				}

				if !strings.Contains(string(content), tc.expectedContent) {
					t.Errorf("Output file does not contain expected content: %s", tc.expectedContent)
				}
			}
		})
	}
}
