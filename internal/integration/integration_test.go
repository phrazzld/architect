// internal/integration/integration_test.go
package integration

import (
	"context"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/phrazzld/architect/internal/gemini"
)

// TestBasicPlanGeneration tests the basic workflow of the application
func TestBasicPlanGeneration(t *testing.T) {
	// Set up the test environment
	env := NewTestEnv(t)
	defer env.Cleanup()

	// Set up the mock client
	env.SetupMockGeminiClient()

	// Create some test files
	env.CreateTestFile(t, "src/main.go", `package main

import "fmt"

func main() {
	fmt.Println("Hello, world!")
}`)

	env.CreateTestFile(t, "src/utils.go", `package main

func add(a, b int) int {
	return a + b
}`)

	// Create a task file
	_ = env.CreateTestFile(t, "task.txt", "Implement a new feature to multiply two numbers")

	// Set up the adapter
	adapter := NewMainAdapter()

	// Set up the output file path
	outputFile := filepath.Join(env.TestDir, "output.md")

	// Run the application with basic arguments
	err := adapter.RunWithArgs(
		[]string{
			"architect",
			"--task", "Implement a new feature to multiply two numbers",
			"--output", outputFile,
			env.TestDir + "/src",
		},
		env,
	)

	if err != nil {
		t.Fatalf("RunWithArgs failed: %v", err)
	}

	// Check that the output file exists
	if _, err := os.Stat(outputFile); os.IsNotExist(err) {
		t.Errorf("Output file was not created at %s", outputFile)
	}

	// Verify content
	content, err := os.ReadFile(outputFile)
	if err != nil {
		t.Fatalf("Failed to read output file: %v", err)
	}

	// Check that content includes expected text (from our mock response)
	if !strings.Contains(string(content), "Test Generated Plan") {
		t.Errorf("Output file does not contain expected content")
	}
}

// TestDryRunMode tests the dry run mode of the application
func TestDryRunMode(t *testing.T) {
	// Set up the test environment
	env := NewTestEnv(t)
	defer env.Cleanup()

	// Set up the mock client
	env.SetupMockGeminiClient()

	// Create some test files
	env.CreateTestFile(t, "src/main.go", `package main

import "fmt"

func main() {
	fmt.Println("Hello, world!")
}`)

	// Set up the adapter
	adapter := NewMainAdapter()

	// Set up the output file path
	outputFile := filepath.Join(env.TestDir, "output.md")

	// Run the application in dry run mode
	err := adapter.RunWithArgs(
		[]string{
			"architect",
			"--dry-run",
			"--task", "Test task",
			"--output", outputFile,
			env.TestDir + "/src",
		},
		env,
	)

	if err != nil {
		t.Fatalf("RunWithArgs failed: %v", err)
	}

	// Check that the output file was NOT created in dry run mode
	if _, err := os.Stat(outputFile); !os.IsNotExist(err) {
		t.Errorf("Output file was created in dry run mode at %s", outputFile)
	}
}

// TestTaskFileInput tests using a task file instead of command line task
func TestTaskFileInput(t *testing.T) {
	// Set up the test environment
	env := NewTestEnv(t)
	defer env.Cleanup()

	// Set up the mock client
	env.SetupMockGeminiClient()

	// Create some test files
	env.CreateTestFile(t, "src/main.go", `package main

import "fmt"

func main() {
	fmt.Println("Hello, world!")
}`)

	// Create a task file
	taskFile := env.CreateTestFile(t, "task.txt", "Implement a new feature to multiply two numbers")

	// Set up the adapter
	adapter := NewMainAdapter()

	// Set up the output file path
	outputFile := filepath.Join(env.TestDir, "output.md")

	// Run the application with task file
	err := adapter.RunWithArgs(
		[]string{
			"architect",
			"--task-file", taskFile,
			"--output", outputFile,
			env.TestDir + "/src",
		},
		env,
	)

	if err != nil {
		t.Fatalf("RunWithArgs failed: %v", err)
	}

	// Check that the output file exists
	if _, err := os.Stat(outputFile); os.IsNotExist(err) {
		t.Errorf("Output file was not created at %s", outputFile)
	}
}

// TestFilteredFileInclusion tests including only specific file extensions
func TestFilteredFileInclusion(t *testing.T) {
	// Set up the test environment
	env := NewTestEnv(t)
	defer env.Cleanup()

	// Set up the mock client with a custom implementation that verifies the context content
	env.MockClient.GenerateContentFunc = func(ctx context.Context, prompt string) (*gemini.GenerationResult, error) {
		// In a real implementation, we would check the actual context
		return &gemini.GenerationResult{
			Content:      "# Test Generated Plan\n\nThis is a test plan generated by the mock client.",
			TokenCount:   1000,
			FinishReason: "STOP",
		}, nil
	}

	// Create test files of different types
	env.CreateTestFile(t, "src/main.go", `package main

func main() {}`)

	env.CreateTestFile(t, "src/README.md", "# Test Project")

	env.CreateTestFile(t, "src/config.json", `{"key": "value"}`)

	// Set up the adapter
	adapter := NewMainAdapter()

	// Set up the output file path
	outputFile := filepath.Join(env.TestDir, "output.md")

	// Run the application with file filters
	err := adapter.RunWithArgs(
		[]string{
			"architect",
			"--task", "Test task",
			"--output", outputFile,
			"--include", ".go,.md", // Only include Go and Markdown files
			env.TestDir + "/src",
		},
		env,
	)

	if err != nil {
		t.Fatalf("RunWithArgs failed: %v", err)
	}

	// Check that the output file exists
	if _, err := os.Stat(outputFile); os.IsNotExist(err) {
		t.Errorf("Output file was not created at %s", outputFile)
	}
}

// TestErrorHandling tests error handling scenarios
func TestErrorHandling(t *testing.T) {
	// Set up the test environment
	env := NewTestEnv(t)
	defer env.Cleanup()

	// Mock an error from the Gemini API
	env.MockClient.GenerateContentFunc = func(ctx context.Context, prompt string) (*gemini.GenerationResult, error) {
		// Create a simple API error
		apiError := &gemini.APIError{
			Message:    "API quota exceeded",
			Suggestion: "Try again later",
			StatusCode: 429,
		}
		return nil, apiError
	}

	// Create a test file
	env.CreateTestFile(t, "src/main.go", `package main

func main() {}`)

	// Set up the adapter
	adapter := NewMainAdapter()

	// Set up the output file path
	outputFile := filepath.Join(env.TestDir, "output.md")

	// Run the application
	err := adapter.RunWithArgs(
		[]string{
			"architect",
			"--task", "Test task",
			"--output", outputFile,
			env.TestDir + "/src",
		},
		env,
	)

	// The application should continue despite the error
	if err != nil {
		t.Fatalf("RunWithArgs failed: %v", err)
	}

	// But the output file should not be created due to the error
	if _, err := os.Stat(outputFile); !os.IsNotExist(err) {
		t.Errorf("Output file was created despite API error")
	}
}

// TestTokenCountExceeded tests the behavior when token count exceeds limits
func TestTokenCountExceeded(t *testing.T) {
	// Set up the test environment
	env := NewTestEnv(t)
	defer env.Cleanup()

	// Mock a token count that exceeds limits
	env.MockClient.CountTokensFunc = func(ctx context.Context, prompt string) (*gemini.TokenCount, error) {
		return &gemini.TokenCount{Total: 1000000}, nil // Very large count
	}

	env.MockClient.GetModelInfoFunc = func(ctx context.Context) (*gemini.ModelInfo, error) {
		return &gemini.ModelInfo{
			Name:             "test-model",
			InputTokenLimit:  10000, // Smaller than the count
			OutputTokenLimit: 8192,
		}, nil
	}

	// Create a test file
	env.CreateTestFile(t, "src/main.go", `package main

func main() {}`)

	// Set up the adapter
	adapter := NewMainAdapter()

	// Set up the output file path
	outputFile := filepath.Join(env.TestDir, "output.md")

	// Run the application
	err := adapter.RunWithArgs(
		[]string{
			"architect",
			"--task", "Test task",
			"--output", outputFile,
			env.TestDir + "/src",
		},
		env,
	)

	// The application should continue despite the error
	if err != nil {
		t.Fatalf("RunWithArgs failed: %v", err)
	}

	// The output file should not be created due to the token limit error
	if _, err := os.Stat(outputFile); !os.IsNotExist(err) {
		t.Errorf("Output file was created despite token limit error")
	}
}

// TestUserConfirmation tests the confirmation prompt for large token counts
func TestUserConfirmation(t *testing.T) {
	// Set up the test environment
	env := NewTestEnv(t)
	defer env.Cleanup()

	// Set up the mock client
	env.SetupMockGeminiClient()

	// Mock token count
	env.MockClient.CountTokensFunc = func(ctx context.Context, prompt string) (*gemini.TokenCount, error) {
		return &gemini.TokenCount{Total: 5000}, nil
	}

	// Create a test file
	env.CreateTestFile(t, "src/main.go", `package main

func main() {}`)

	// Simulate user input (say "yes" to confirmation)
	env.SimulateUserInput("y\n")

	// Set up the adapter
	adapter := NewMainAdapter()

	// Set up the output file path
	outputFile := filepath.Join(env.TestDir, "output.md")

	// Run the application with confirmation threshold
	err := adapter.RunWithArgs(
		[]string{
			"architect",
			"--task", "Test task",
			"--output", outputFile,
			"--confirm-tokens", "1000", // Threshold lower than our token count
			env.TestDir + "/src",
		},
		env,
	)

	if err != nil {
		t.Fatalf("RunWithArgs failed: %v", err)
	}

	// In a real implementation, we'd check if the confirmation was presented
	// and if the output file was created based on the user's response
}

// TestTaskExecution tests the basic task execution without clarification
// (replaces the old TestTaskClarification test that depended on the removed clarify feature)
func TestTaskExecution(t *testing.T) {
	// Set up the test environment
	env := NewTestEnv(t)
	defer env.Cleanup()

	// Set up the mock client with default responses
	env.SetupMockGeminiClient()

	// Create a test file
	env.CreateTestFile(t, "src/main.go", `package main

func main() {}`)

	// Set up the output file path
	outputFile := filepath.Join(env.TestDir, "output.md")

	// Set up the adapter
	adapter := NewMainAdapter()

	// Task description
	taskDescription := "Implement a new feature"

	// Run the application with basic task description
	err := adapter.RunWithArgs(
		[]string{
			"architect",
			"--task", taskDescription,
			"--output", outputFile,
			env.TestDir + "/src",
		},
		env,
	)

	if err != nil {
		t.Fatalf("RunWithArgs failed: %v", err)
	}

	// Check that the output file exists
	if _, err := os.Stat(outputFile); os.IsNotExist(err) {
		t.Errorf("Output file was not created at %s", outputFile)
	}

	// Verify that the task was used
	content, err := os.ReadFile(outputFile)
	if err != nil {
		t.Fatalf("Failed to read output file: %v", err)
	}

	// NOTE: This test should be updated since clarify functionality was removed
	// The old expectation was to see a "REFINED:" marker in the output
	// For now, just check that the output contains some content
	if len(content) == 0 {
		t.Errorf("Output file is empty")
	}
}

// TestPromptFileTemplateHandling tests the different types of template files and their processing
func TestPromptFileTemplateHandling(t *testing.T) {
	// Test cases for different template scenarios
	t.Run("RegularTextFile", func(t *testing.T) {
		// Set up the test environment
		env := NewTestEnv(t)
		defer env.Cleanup()
		env.SetupMockGeminiClient()

		// Create a regular text file without template variables
		taskFileContent := "This is a regular task description without any template variables."
		taskFile := env.CreateTestFile(t, "task.txt", taskFileContent)

		// Set up the output file path
		outputFile := filepath.Join(env.TestDir, "output.md")

		// Run the application with the task file
		adapter := NewMainAdapter()
		err := adapter.RunWithArgs(
			[]string{
				"architect",
				"--task-file", taskFile,
				"--output", outputFile,
				env.TestDir,
			},
			env,
		)

		if err != nil {
			t.Fatalf("RunWithArgs failed: %v", err)
		}

		// Check that the output file exists
		if _, err := os.Stat(outputFile); os.IsNotExist(err) {
			t.Errorf("Output file was not created at %s", outputFile)
		}

		// Verify the content indicates that the file was NOT processed as a template
		content, err := os.ReadFile(outputFile)
		if err != nil {
			t.Fatalf("Failed to read output file: %v", err)
		}

		if !strings.Contains(string(content), "TEMPLATE_PROCESSED: NO") {
			t.Errorf("Regular text file was incorrectly processed as a template: %s", string(content))
		}
	})

	t.Run("TemplateExtensionNoVariables", func(t *testing.T) {
		// Set up the test environment
		env := NewTestEnv(t)
		defer env.Cleanup()
		env.SetupMockGeminiClient()

		// Create a file with .tmpl extension but no template variables
		taskFileContent := "This is a file with .tmpl extension but without template variables."
		taskFile := env.CreateTestFile(t, "task.tmpl", taskFileContent)

		// Set up the output file path
		outputFile := filepath.Join(env.TestDir, "output.md")

		// Run the application with the task file
		adapter := NewMainAdapter()
		err := adapter.RunWithArgs(
			[]string{
				"architect",
				"--task-file", taskFile,
				"--output", outputFile,
				env.TestDir,
			},
			env,
		)

		if err != nil {
			t.Fatalf("RunWithArgs failed: %v", err)
		}

		// Verify the content indicates that the file was processed as a template (based on extension)
		content, err := os.ReadFile(outputFile)
		if err != nil {
			t.Fatalf("Failed to read output file: %v", err)
		}

		if !strings.Contains(string(content), "TEMPLATE_PROCESSED: YES") {
			t.Errorf("File with .tmpl extension was not processed as a template: %s", string(content))
		}
	})

	t.Run("TemplateVariablesNoExtension", func(t *testing.T) {
		// Set up the test environment
		env := NewTestEnv(t)
		defer env.Cleanup()
		env.SetupMockGeminiClient()

		// Create a file with template variables but without .tmpl extension
		// We need to set the task description directly for testing since the adapter
		// doesn't actually read the file content
		taskFileContent := "This file has template variables {{.Task}} and {{.Context}} but no .tmpl extension."
		taskFile := env.CreateTestFile(t, "task.md", taskFileContent)

		// Set up the output file path
		outputFile := filepath.Join(env.TestDir, "output.md")

		// Create a special adapter where we can directly set properties
		adapter := NewMainAdapter()

		// Mock RunWithArgs to properly handle our test cases
		// We need to override how we pass the task content since our test adapter doesn't actually read the file
		origArgs := os.Args
		defer func() { os.Args = origArgs }()

		os.Args = []string{
			"architect",
			"--task-file", taskFile,
			"--output", outputFile,
			env.TestDir,
		}

		// Reset flags for this test
		adapter.ResetFlags()
		defer adapter.RestoreFlags()

		// Parse flags to get the config
		config := adapter.parseFlags()

		// Directly set the task description to simulate file content being read
		config.TaskDescription = taskFileContent

		// Set environment variables as needed
		if os.Getenv("GEMINI_API_KEY") == "" {
			os.Setenv("GEMINI_API_KEY", "test-api-key")
			defer os.Unsetenv("GEMINI_API_KEY")
		}

		// Set up logging
		logger := env.Logger

		// Initialize API client using our mock
		ctx := context.Background()
		geminiClient := env.MockClient

		// Gather context
		projectContext := adapter.gatherContext(ctx, config, geminiClient, logger)

		// Generate the plan
		adapter.generateAndSavePlan(ctx, config, geminiClient, projectContext, logger)

		// Verify the content indicates that the file was processed as a template (based on content)
		content, err := os.ReadFile(outputFile)
		if err != nil {
			t.Fatalf("Failed to read output file: %v", err)
		}

		if !strings.Contains(string(content), "TEMPLATE_PROCESSED: YES") {
			t.Errorf("File with template variables was not processed as a template: %s", string(content))
		}
	})

	t.Run("TemplateExtensionAndVariables", func(t *testing.T) {
		// Set up the test environment
		env := NewTestEnv(t)
		defer env.Cleanup()
		env.SetupMockGeminiClient()

		// Create a file with both .tmpl extension and template variables
		taskFileContent := "This file has both .tmpl extension and template variables {{.Task}} and {{.Context}}."
		taskFile := env.CreateTestFile(t, "task.tmpl", taskFileContent)

		// Set up the output file path
		outputFile := filepath.Join(env.TestDir, "output.md")

		// Create adapter
		adapter := NewMainAdapter()

		// Mock RunWithArgs to properly handle our test cases
		origArgs := os.Args
		defer func() { os.Args = origArgs }()

		os.Args = []string{
			"architect",
			"--task-file", taskFile,
			"--output", outputFile,
			env.TestDir,
		}

		// Reset flags for this test
		adapter.ResetFlags()
		defer adapter.RestoreFlags()

		// Parse flags to get the config
		config := adapter.parseFlags()

		// Directly set the task description to simulate file content being read
		config.TaskDescription = taskFileContent

		// Set environment variables as needed
		if os.Getenv("GEMINI_API_KEY") == "" {
			os.Setenv("GEMINI_API_KEY", "test-api-key")
			defer os.Unsetenv("GEMINI_API_KEY")
		}

		// Set up logging
		logger := env.Logger

		// Initialize API client using our mock
		ctx := context.Background()
		geminiClient := env.MockClient

		// Gather context
		projectContext := adapter.gatherContext(ctx, config, geminiClient, logger)

		// Generate the plan
		adapter.generateAndSavePlan(ctx, config, geminiClient, projectContext, logger)

		// Verify the content indicates that the file was processed as a template
		content, err := os.ReadFile(outputFile)
		if err != nil {
			t.Fatalf("Failed to read output file: %v", err)
		}

		if !strings.Contains(string(content), "TEMPLATE_PROCESSED: YES") {
			t.Errorf("File with .tmpl extension and template variables was not processed as a template: %s", string(content))
		}
	})

	t.Run("InvalidTemplateContent", func(t *testing.T) {
		// Set up the test environment
		env := NewTestEnv(t)
		defer env.Cleanup()
		env.SetupMockGeminiClient()

		// Create a file with invalid template syntax
		taskFileContent := "This file has invalid template syntax {{INVALID}}."
		taskFile := env.CreateTestFile(t, "task.tmpl", taskFileContent)

		// Set up the output file path
		outputFile := filepath.Join(env.TestDir, "output.md")

		// Create adapter
		adapter := NewMainAdapter()

		// Mock RunWithArgs to properly handle our test cases
		origArgs := os.Args
		defer func() { os.Args = origArgs }()

		os.Args = []string{
			"architect",
			"--task-file", taskFile,
			"--output", outputFile,
			env.TestDir,
		}

		// Reset flags for this test
		adapter.ResetFlags()
		defer adapter.RestoreFlags()

		// Parse flags to get the config
		config := adapter.parseFlags()

		// Directly set the task description to simulate file content being read
		config.TaskDescription = taskFileContent

		// Set environment variables as needed
		if os.Getenv("GEMINI_API_KEY") == "" {
			os.Setenv("GEMINI_API_KEY", "test-api-key")
			defer os.Unsetenv("GEMINI_API_KEY")
		}

		// Set up logging
		logger := env.Logger

		// Initialize API client using our mock
		ctx := context.Background()
		geminiClient := env.MockClient

		// Gather context
		projectContext := adapter.gatherContext(ctx, config, geminiClient, logger)

		// Generate the plan
		adapter.generateAndSavePlan(ctx, config, geminiClient, projectContext, logger)

		// Check that the output file exists with error information
		content, err := os.ReadFile(outputFile)
		if err != nil {
			t.Fatalf("Failed to read output file: %v", err)
		}

		if !strings.Contains(string(content), "ERROR") {
			t.Errorf("Invalid template content did not produce expected error in output: %s", string(content))
		}
	})
}
