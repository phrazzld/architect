// internal/integration/integration_test.go
package integration

import (
	"context"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/phrazzld/architect/internal/gemini"
)

// TestBasicPlanGeneration tests the basic workflow of the application
func TestBasicPlanGeneration(t *testing.T) {
	// Set up the test environment
	env := NewTestEnv(t)
	defer env.Cleanup()
	
	// Set up the mock client
	env.SetupMockGeminiClient()
	
	// Create some test files
	env.CreateTestFile(t, "src/main.go", `package main

import "fmt"

func main() {
	fmt.Println("Hello, world!")
}`)
	
	env.CreateTestFile(t, "src/utils.go", `package main

func add(a, b int) int {
	return a + b
}`)
	
	// Create a task file
	_ = env.CreateTestFile(t, "task.txt", "Implement a new feature to multiply two numbers")
	
	// Set up the adapter
	adapter := NewMainAdapter()
	
	// Set up the output file path
	outputFile := filepath.Join(env.TestDir, "output.md")
	
	// Run the application with basic arguments
	err := adapter.RunWithArgs(
		[]string{
			"architect",
			"--task", "Implement a new feature to multiply two numbers",
			"--output", outputFile,
			env.TestDir + "/src",
		},
		env,
	)
	
	if err != nil {
		t.Fatalf("RunWithArgs failed: %v", err)
	}
	
	// Check that the output file exists
	if _, err := os.Stat(outputFile); os.IsNotExist(err) {
		t.Errorf("Output file was not created at %s", outputFile)
	}
	
	// Verify content
	content, err := os.ReadFile(outputFile)
	if err != nil {
		t.Fatalf("Failed to read output file: %v", err)
	}
	
	// Check that content includes expected text (from our mock response)
	if !strings.Contains(string(content), "Test Generated Plan") {
		t.Errorf("Output file does not contain expected content")
	}
}

// TestDryRunMode tests the dry run mode of the application
func TestDryRunMode(t *testing.T) {
	// Set up the test environment
	env := NewTestEnv(t)
	defer env.Cleanup()
	
	// Set up the mock client
	env.SetupMockGeminiClient()
	
	// Create some test files
	env.CreateTestFile(t, "src/main.go", `package main

import "fmt"

func main() {
	fmt.Println("Hello, world!")
}`)
	
	// Set up the adapter
	adapter := NewMainAdapter()
	
	// Set up the output file path
	outputFile := filepath.Join(env.TestDir, "output.md")
	
	// Run the application in dry run mode
	err := adapter.RunWithArgs(
		[]string{
			"architect",
			"--dry-run",
			"--task", "Test task",
			"--output", outputFile,
			env.TestDir + "/src",
		},
		env,
	)
	
	if err != nil {
		t.Fatalf("RunWithArgs failed: %v", err)
	}
	
	// Check that the output file was NOT created in dry run mode
	if _, err := os.Stat(outputFile); !os.IsNotExist(err) {
		t.Errorf("Output file was created in dry run mode at %s", outputFile)
	}
}

// TestTaskFileInput tests using a task file instead of command line task
func TestTaskFileInput(t *testing.T) {
	// Set up the test environment
	env := NewTestEnv(t)
	defer env.Cleanup()
	
	// Set up the mock client
	env.SetupMockGeminiClient()
	
	// Create some test files
	env.CreateTestFile(t, "src/main.go", `package main

import "fmt"

func main() {
	fmt.Println("Hello, world!")
}`)
	
	// Create a task file
	taskFile := env.CreateTestFile(t, "task.txt", "Implement a new feature to multiply two numbers")
	
	// Set up the adapter
	adapter := NewMainAdapter()
	
	// Set up the output file path
	outputFile := filepath.Join(env.TestDir, "output.md")
	
	// Run the application with task file
	err := adapter.RunWithArgs(
		[]string{
			"architect",
			"--task-file", taskFile,
			"--output", outputFile,
			env.TestDir + "/src",
		},
		env,
	)
	
	if err != nil {
		t.Fatalf("RunWithArgs failed: %v", err)
	}
	
	// Check that the output file exists
	if _, err := os.Stat(outputFile); os.IsNotExist(err) {
		t.Errorf("Output file was not created at %s", outputFile)
	}
}

// TestFilteredFileInclusion tests including only specific file extensions
func TestFilteredFileInclusion(t *testing.T) {
	// Set up the test environment
	env := NewTestEnv(t)
	defer env.Cleanup()
	
	// Set up the mock client with a custom implementation that verifies the context content
	env.MockClient.GenerateContentFunc = func(ctx context.Context, prompt string) (*gemini.GenerationResult, error) {
		// In a real implementation, we would check the actual context
		return &gemini.GenerationResult{
			Content:      "# Test Generated Plan\n\nThis is a test plan generated by the mock client.",
			TokenCount:   1000,
			FinishReason: "STOP",
		}, nil
	}
	
	// Create test files of different types
	env.CreateTestFile(t, "src/main.go", `package main

func main() {}`)
	
	env.CreateTestFile(t, "src/README.md", "# Test Project")
	
	env.CreateTestFile(t, "src/config.json", `{"key": "value"}`)
	
	// Set up the adapter
	adapter := NewMainAdapter()
	
	// Set up the output file path
	outputFile := filepath.Join(env.TestDir, "output.md")
	
	// Run the application with file filters
	err := adapter.RunWithArgs(
		[]string{
			"architect",
			"--task", "Test task",
			"--output", outputFile,
			"--include", ".go,.md", // Only include Go and Markdown files
			env.TestDir + "/src",
		},
		env,
	)
	
	if err != nil {
		t.Fatalf("RunWithArgs failed: %v", err)
	}
	
	// Check that the output file exists
	if _, err := os.Stat(outputFile); os.IsNotExist(err) {
		t.Errorf("Output file was not created at %s", outputFile)
	}
}

// TestErrorHandling tests error handling scenarios
func TestErrorHandling(t *testing.T) {
	// Set up the test environment
	env := NewTestEnv(t)
	defer env.Cleanup()
	
	// Mock an error from the Gemini API
	env.MockClient.GenerateContentFunc = func(ctx context.Context, prompt string) (*gemini.GenerationResult, error) {
		// Create a simple API error
		apiError := &gemini.APIError{
			Message:    "API quota exceeded",
			Suggestion: "Try again later",
			StatusCode: 429,
		}
		return nil, apiError
	}
	
	// Create a test file
	env.CreateTestFile(t, "src/main.go", `package main

func main() {}`)
	
	// Set up the adapter
	adapter := NewMainAdapter()
	
	// Set up the output file path
	outputFile := filepath.Join(env.TestDir, "output.md")
	
	// Run the application
	err := adapter.RunWithArgs(
		[]string{
			"architect",
			"--task", "Test task",
			"--output", outputFile,
			env.TestDir + "/src",
		},
		env,
	)
	
	// The application should continue despite the error
	if err != nil {
		t.Fatalf("RunWithArgs failed: %v", err)
	}
	
	// But the output file should not be created due to the error
	if _, err := os.Stat(outputFile); !os.IsNotExist(err) {
		t.Errorf("Output file was created despite API error")
	}
}

// TestTokenCountExceeded tests the behavior when token count exceeds limits
func TestTokenCountExceeded(t *testing.T) {
	// Set up the test environment
	env := NewTestEnv(t)
	defer env.Cleanup()
	
	// Mock a token count that exceeds limits
	env.MockClient.CountTokensFunc = func(ctx context.Context, prompt string) (*gemini.TokenCount, error) {
		return &gemini.TokenCount{Total: 1000000}, nil // Very large count
	}
	
	env.MockClient.GetModelInfoFunc = func(ctx context.Context) (*gemini.ModelInfo, error) {
		return &gemini.ModelInfo{
			Name:             "test-model",
			InputTokenLimit:  10000, // Smaller than the count
			OutputTokenLimit: 8192,
		}, nil
	}
	
	// Create a test file
	env.CreateTestFile(t, "src/main.go", `package main

func main() {}`)
	
	// Set up the adapter
	adapter := NewMainAdapter()
	
	// Set up the output file path
	outputFile := filepath.Join(env.TestDir, "output.md")
	
	// Run the application
	err := adapter.RunWithArgs(
		[]string{
			"architect",
			"--task", "Test task",
			"--output", outputFile,
			env.TestDir + "/src",
		},
		env,
	)
	
	// The application should continue despite the error
	if err != nil {
		t.Fatalf("RunWithArgs failed: %v", err)
	}
	
	// The output file should not be created due to the token limit error
	if _, err := os.Stat(outputFile); !os.IsNotExist(err) {
		t.Errorf("Output file was created despite token limit error")
	}
}

// TestUserConfirmation tests the confirmation prompt for large token counts
func TestUserConfirmation(t *testing.T) {
	// Set up the test environment
	env := NewTestEnv(t)
	defer env.Cleanup()
	
	// Set up the mock client
	env.SetupMockGeminiClient()
	
	// Mock token count
	env.MockClient.CountTokensFunc = func(ctx context.Context, prompt string) (*gemini.TokenCount, error) {
		return &gemini.TokenCount{Total: 5000}, nil
	}
	
	// Create a test file
	env.CreateTestFile(t, "src/main.go", `package main

func main() {}`)
	
	// Simulate user input (say "yes" to confirmation)
	env.SimulateUserInput("y\n")
	
	// Set up the adapter
	adapter := NewMainAdapter()
	
	// Set up the output file path
	outputFile := filepath.Join(env.TestDir, "output.md")
	
	// Run the application with confirmation threshold
	err := adapter.RunWithArgs(
		[]string{
			"architect",
			"--task", "Test task",
			"--output", outputFile,
			"--confirm-tokens", "1000", // Threshold lower than our token count
			env.TestDir + "/src",
		},
		env,
	)
	
	if err != nil {
		t.Fatalf("RunWithArgs failed: %v", err)
	}
	
	// In a real implementation, we'd check if the confirmation was presented
	// and if the output file was created based on the user's response
}