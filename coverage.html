
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>architect: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/phrazzld/architect/cmd/architect/api.go (100.0%)</option>
				
				<option value="file1">github.com/phrazzld/architect/cmd/architect/api_test_helper.go (0.0%)</option>
				
				<option value="file2">github.com/phrazzld/architect/cmd/architect/cli.go (81.2%)</option>
				
				<option value="file3">github.com/phrazzld/architect/cmd/architect/main.go (0.0%)</option>
				
				<option value="file4">github.com/phrazzld/architect/cmd/architect/output.go (0.0%)</option>
				
				<option value="file5">github.com/phrazzld/architect/cmd/architect/token.go (74.4%)</option>
				
				<option value="file6">github.com/phrazzld/architect/internal/architect/modelproc/processor.go (64.2%)</option>
				
				<option value="file7">github.com/phrazzld/architect/internal/architect/prompt/prompt.go (100.0%)</option>
				
				<option value="file8">github.com/phrazzld/architect/internal/auditlog/logger.go (80.6%)</option>
				
				<option value="file9">github.com/phrazzld/architect/internal/config/config.go (33.3%)</option>
				
				<option value="file10">github.com/phrazzld/architect/internal/fileutil/fileutil.go (88.2%)</option>
				
				<option value="file11">github.com/phrazzld/architect/internal/fileutil/mock_logger.go (13.8%)</option>
				
				<option value="file12">github.com/phrazzld/architect/internal/gemini/client.go (50.0%)</option>
				
				<option value="file13">github.com/phrazzld/architect/internal/gemini/errors.go (0.0%)</option>
				
				<option value="file14">github.com/phrazzld/architect/internal/gemini/gemini_client.go (0.0%)</option>
				
				<option value="file15">github.com/phrazzld/architect/internal/gemini/mock_client.go (15.4%)</option>
				
				<option value="file16">github.com/phrazzld/architect/internal/logutil/logutil.go (71.1%)</option>
				
				<option value="file17">github.com/phrazzld/architect/internal/ratelimit/ratelimit.go (82.4%)</option>
				
				<option value="file18">github.com/phrazzld/architect/internal/runutil/runutil.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package architect provides the command-line interface for the architect tool
package architect

import (
        "github.com/phrazzld/architect/internal/architect"
        "github.com/phrazzld/architect/internal/logutil"
)

// Re-export error types from internal/architect for backward compatibility with tests
var (
        ErrEmptyResponse        = architect.ErrEmptyResponse
        ErrWhitespaceContent    = architect.ErrWhitespaceContent
        ErrSafetyBlocked        = architect.ErrSafetyBlocked
        ErrAPICall              = architect.ErrAPICall
        ErrClientInitialization = architect.ErrClientInitialization
)

// APIService is an alias to the internal one
type APIService = architect.APIService

// NewAPIService is a wrapper for the internal one
func NewAPIService(logger logutil.LoggerInterface) APIService <span class="cov8" title="1">{
        return architect.NewAPIService(logger)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package architect

import (
        "context"
        "github.com/phrazzld/architect/internal/gemini"
)

// MockClient is a mock implementation of gemini.Client for testing
type MockClient struct {
        CountTokensFunc     func(ctx context.Context, prompt string) (*gemini.TokenCount, error)
        GenerateContentFunc func(ctx context.Context, prompt string) (*gemini.GenerationResult, error)
        GetModelInfoFunc    func(ctx context.Context) (*gemini.ModelInfo, error)
        CloseFunc           func() error
}

func (m *MockClient) CountTokens(ctx context.Context, prompt string) (*gemini.TokenCount, error) <span class="cov0" title="0">{
        if m.CountTokensFunc != nil </span><span class="cov0" title="0">{
                return m.CountTokensFunc(ctx, prompt)
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

func (m *MockClient) GenerateContent(ctx context.Context, prompt string) (*gemini.GenerationResult, error) <span class="cov0" title="0">{
        if m.GenerateContentFunc != nil </span><span class="cov0" title="0">{
                return m.GenerateContentFunc(ctx, prompt)
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

func (m *MockClient) GetModelInfo(ctx context.Context) (*gemini.ModelInfo, error) <span class="cov0" title="0">{
        if m.GetModelInfoFunc != nil </span><span class="cov0" title="0">{
                return m.GetModelInfoFunc(ctx)
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

func (m *MockClient) Close() error <span class="cov0" title="0">{
        if m.CloseFunc != nil </span><span class="cov0" title="0">{
                return m.CloseFunc()
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package architect provides the command-line interface for the architect tool
package architect

import (
        "flag"
        "fmt"
        "io"
        "os"
        "strings"

        "github.com/phrazzld/architect/internal/config"
        "github.com/phrazzld/architect/internal/logutil"
)

// stringSliceFlag is a slice of strings that implements flag.Value interface
// to handle repeatable flags for multiple values
type stringSliceFlag []string

// String returns a comma-separated string representation of the flag values
// This method is required by the flag.Value interface
func (s *stringSliceFlag) String() string <span class="cov8" title="1">{
        return strings.Join(*s, ",")
}</span>

// Set appends the value to the slice of values
// This method is required by the flag.Value interface
func (s *stringSliceFlag) Set(value string) error <span class="cov8" title="1">{
        *s = append(*s, value)
        return nil
}</span>

// Constants referencing the config package defaults
const (
        defaultOutputFile   = config.DefaultOutputFile
        defaultModel        = config.DefaultModel
        apiKeyEnvVar        = config.APIKeyEnvVar
        apiEndpointEnvVar   = config.APIEndpointEnvVar
        defaultFormat       = config.DefaultFormat
        defaultExcludes     = config.DefaultExcludes
        defaultExcludeNames = config.DefaultExcludeNames
)

// ValidateInputs checks if the configuration is valid and returns an error if not
func ValidateInputs(config *config.CliConfig, logger logutil.LoggerInterface) error <span class="cov8" title="1">{
        // Check for instructions file
        if config.InstructionsFile == "" &amp;&amp; !config.DryRun </span><span class="cov8" title="1">{
                logger.Error("The required --instructions flag is missing.")
                return fmt.Errorf("missing required --instructions flag")
        }</span>

        // Check for input paths
        <span class="cov8" title="1">if len(config.Paths) == 0 </span><span class="cov8" title="1">{
                logger.Error("At least one file or directory path must be provided as an argument.")
                return fmt.Errorf("no paths specified")
        }</span>

        // Check for API key
        <span class="cov8" title="1">if config.APIKey == "" </span><span class="cov8" title="1">{
                logger.Error("%s environment variable not set.", apiKeyEnvVar)
                return fmt.Errorf("API key not set")
        }</span>

        // Check for model names
        <span class="cov8" title="1">if len(config.ModelNames) == 0 &amp;&amp; !config.DryRun </span><span class="cov8" title="1">{
                logger.Error("At least one model must be specified with --model flag.")
                return fmt.Errorf("no models specified")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ParseFlags handles command line argument parsing and returns the configuration
func ParseFlags() (*config.CliConfig, error) <span class="cov0" title="0">{
        return ParseFlagsWithEnv(flag.CommandLine, os.Args[1:], os.Getenv)
}</span>

// ParseFlagsWithEnv handles command-line flag parsing with custom flag set and environment lookup
// This improves testability by allowing tests to provide mock flag sets and environment functions
func ParseFlagsWithEnv(flagSet *flag.FlagSet, args []string, getenv func(string) string) (*config.CliConfig, error) <span class="cov8" title="1">{
        cfg := config.NewDefaultCliConfig()

        // Define flags
        instructionsFileFlag := flagSet.String("instructions", "", "Path to a file containing the static instructions for the LLM.")
        outputDirFlag := flagSet.String("output-dir", "", "Directory path to store generated plans (one per model).")
        verboseFlag := flagSet.Bool("verbose", false, "Enable verbose logging output (shorthand for --log-level=debug).")
        logLevelFlag := flagSet.String("log-level", "info", "Set logging level (debug, info, warn, error).")
        includeFlag := flagSet.String("include", "", "Comma-separated list of file extensions to include (e.g., .go,.md)")
        excludeFlag := flagSet.String("exclude", defaultExcludes, "Comma-separated list of file extensions to exclude.")
        excludeNamesFlag := flagSet.String("exclude-names", defaultExcludeNames, "Comma-separated list of file/dir names to exclude.")
        formatFlag := flagSet.String("format", defaultFormat, "Format string for each file. Use {path} and {content}.")
        dryRunFlag := flagSet.Bool("dry-run", false, "Show files that would be included and token count, but don't call the API.")
        confirmTokensFlag := flagSet.Int("confirm-tokens", 0, "Prompt for confirmation if token count exceeds this value (0 = never prompt)")
        auditLogFileFlag := flagSet.String("audit-log-file", "", "Path to write structured audit logs (JSON Lines). Disabled if empty.")

        // Rate limiting flags
        maxConcurrentFlag := flagSet.Int("max-concurrent", 5, // Use hardcoded default for backward compatibility with tests
                "Maximum number of concurrent API requests (0 = no limit)")
        rateLimitRPMFlag := flagSet.Int("rate-limit", 60, // Use hardcoded default for backward compatibility with tests
                "Maximum requests per minute (RPM) per model (0 = no limit)")

        // Define the model flag using our custom stringSliceFlag type to support multiple values
        modelFlag := &amp;stringSliceFlag{}
        flagSet.Var(modelFlag, "model", fmt.Sprintf("Gemini model to use for generation (repeatable). Default: %s", defaultModel))

        // Set custom usage message
        flagSet.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Usage: %s --instructions &lt;file&gt; [options] &lt;path1&gt; [path2...]\n\n", os.Args[0])

                fmt.Fprintf(os.Stderr, "Arguments:\n")
                fmt.Fprintf(os.Stderr, "  &lt;path1&gt; [path2...]   One or more file or directory paths for project context.\n\n")

                fmt.Fprintf(os.Stderr, "Example Commands:\n")
                fmt.Fprintf(os.Stderr, "  %s --instructions instructions.txt ./src                        Generate plan using default model\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  %s --instructions instructions.txt --output-dir custom-dir ./       Generate plans in custom directory\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  %s --instructions instructions.txt --model model1 --model model2 ./  Generate plans for multiple models\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  %s --dry-run ./                                                 Show files without generating plan\n\n", os.Args[0])

                fmt.Fprintf(os.Stderr, "Options:\n")
                flagSet.PrintDefaults()

                fmt.Fprintf(os.Stderr, "\nEnvironment Variables:\n")
                fmt.Fprintf(os.Stderr, "  %s: Required. Your Google AI Gemini API key.\n", apiKeyEnvVar)
        }</span>

        // Parse the flags
        <span class="cov8" title="1">if err := flagSet.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing flags: %w", err)
        }</span>

        // Store flag values in configuration
        <span class="cov8" title="1">cfg.InstructionsFile = *instructionsFileFlag

        // Set output directory
        cfg.OutputDir = *outputDirFlag

        cfg.AuditLogFile = *auditLogFileFlag
        cfg.Verbose = *verboseFlag
        cfg.Include = *includeFlag
        cfg.Exclude = *excludeFlag
        cfg.ExcludeNames = *excludeNamesFlag
        cfg.Format = *formatFlag
        cfg.DryRun = *dryRunFlag
        cfg.ConfirmTokens = *confirmTokensFlag
        cfg.Paths = flagSet.Args()

        // Store rate limiting configuration
        cfg.MaxConcurrentRequests = *maxConcurrentFlag
        cfg.RateLimitRequestsPerMinute = *rateLimitRPMFlag

        // Set model names from the flag, defaulting to a single default model if none provided
        if len(*modelFlag) &gt; 0 </span><span class="cov8" title="1">{
                cfg.ModelNames = *modelFlag
        }</span> else<span class="cov8" title="1"> {
                // If no models were specified on the command line, use the default model
                cfg.ModelNames = []string{defaultModel}
        }</span>

        // Determine initial log level from flag
        <span class="cov8" title="1">parsedLogLevel := logutil.InfoLevel // Default
        if *logLevelFlag != "info" </span><span class="cov8" title="1">{
                ll, err := logutil.ParseLogLevel(*logLevelFlag)
                if err == nil </span><span class="cov8" title="1">{
                        parsedLogLevel = ll
                }</span>
        }
        <span class="cov8" title="1">cfg.LogLevel = parsedLogLevel

        // Apply verbose override *after* parsing the specific level
        if cfg.Verbose </span><span class="cov8" title="1">{
                cfg.LogLevel = logutil.DebugLevel
        }</span>
        <span class="cov8" title="1">cfg.APIKey = getenv(apiKeyEnvVar)
        cfg.APIEndpoint = getenv(apiEndpointEnvVar)

        // ParseFlagsWithEnv no longer does logical validation (just parsing errors)
        // Validation is now exclusively handled by ValidateInputs
        return cfg, nil</span>
}

// SetupLogging initializes the logger based on configuration
func SetupLogging(config *config.CliConfig) logutil.LoggerInterface <span class="cov0" title="0">{
        return SetupLoggingCustom(config, flag.Lookup("log-level"), os.Stderr)
}</span>

// SetupLoggingCustom initializes the logger with custom flag and writer for testing
func SetupLoggingCustom(config *config.CliConfig, _ *flag.Flag, output io.Writer) logutil.LoggerInterface <span class="cov8" title="1">{
        // Apply verbose override if set
        if config.Verbose </span><span class="cov8" title="1">{
                config.LogLevel = logutil.DebugLevel
        }</span>

        // Use the LogLevel set in the config
        <span class="cov8" title="1">logger := logutil.NewLogger(config.LogLevel, output, "[architect] ")
        return logger</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package architect provides the command-line interface for the architect tool
package architect

import (
        "context"
        "fmt"
        "os"

        "github.com/phrazzld/architect/internal/architect"
        "github.com/phrazzld/architect/internal/auditlog"
)

// Main is the entry point for the architect CLI
func Main() <span class="cov0" title="0">{
        // Create a base context
        ctx := context.Background()

        // Parse command line flags
        config, err := ParseFlags()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>

        // Setup logging early for error reporting
        <span class="cov0" title="0">logger := SetupLogging(config)
        logger.Info("Starting Architect - AI-assisted content generation tool")

        // Initialize the audit logger
        // Note: The auditLogger will be passed to Execute() in a future task
        var auditLogger auditlog.AuditLogger
        if config.AuditLogFile != "" </span><span class="cov0" title="0">{
                fileLogger, err := auditlog.NewFileAuditLogger(config.AuditLogFile, logger)
                if err != nil </span><span class="cov0" title="0">{
                        // Log error and fall back to NoOp implementation
                        logger.Error("Failed to initialize file audit logger: %v. Audit logging disabled.", err)
                        auditLogger = auditlog.NewNoOpAuditLogger()
                }</span> else<span class="cov0" title="0"> {
                        auditLogger = fileLogger
                        logger.Info("Audit logging enabled to file: %s", config.AuditLogFile)
                }</span>
        } else<span class="cov0" title="0"> {
                auditLogger = auditlog.NewNoOpAuditLogger()
                logger.Debug("Audit logging is disabled")
        }</span>

        // Ensure the audit logger is properly closed when the application exits
        <span class="cov0" title="0">defer auditLogger.Close()

        // Configuration is now managed via CLI flags and environment variables only

        // Validate inputs before proceeding
        if err := ValidateInputs(config, logger); err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>

        // CLI flags and environment variables are now the only source of configuration

        // Initialize APIService
        <span class="cov0" title="0">apiService := architect.NewAPIService(logger)

        // Execute the core application logic
        err = architect.Execute(ctx, config, logger, auditLogger, apiService)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Application failed: %v", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package architect provides the command-line interface for the architect tool
package architect

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/phrazzld/architect/internal/logutil"
)

// FileWriter defines the interface for file writing
type FileWriter interface {
        // SaveToFile writes content to the specified file
        SaveToFile(content, outputFile string) error
}

// fileWriter implements the FileWriter interface
type fileWriter struct {
        logger logutil.LoggerInterface
}

// NewFileWriter creates a new FileWriter instance
func NewFileWriter(logger logutil.LoggerInterface) FileWriter <span class="cov0" title="0">{
        return &amp;fileWriter{
                logger: logger,
        }
}</span>

// SaveToFile writes content to the specified file
func (fw *fileWriter) SaveToFile(content, outputFile string) error <span class="cov0" title="0">{
        // Ensure output path is absolute
        outputPath := outputFile
        if !filepath.IsAbs(outputPath) </span><span class="cov0" title="0">{
                cwd, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        fw.logger.Error("Error getting current working directory: %v", err)
                        return fmt.Errorf("error getting current working directory: %w", err)
                }</span>
                <span class="cov0" title="0">outputPath = filepath.Join(cwd, outputPath)</span>
        }

        // Ensure the output directory exists
        <span class="cov0" title="0">outputDir := filepath.Dir(outputPath)
        if err := os.MkdirAll(outputDir, 0755); err != nil </span><span class="cov0" title="0">{
                fw.logger.Error("Error creating output directory %s: %v", outputDir, err)
                return fmt.Errorf("error creating output directory %s: %w", outputDir, err)
        }</span>

        // Write to file
        <span class="cov0" title="0">fw.logger.Info("Writing to file %s...", outputPath)
        err := os.WriteFile(outputPath, []byte(content), 0644)
        if err != nil </span><span class="cov0" title="0">{
                fw.logger.Error("Error writing to file %s: %v", outputPath, err)
                return fmt.Errorf("error writing to file %s: %w", outputPath, err)
        }</span>

        <span class="cov0" title="0">fw.logger.Info("Successfully saved to %s", outputPath)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package architect provides the command-line interface for the architect tool
package architect

import (
        "bufio"
        "context"
        "fmt"
        "os"
        "strings"

        "github.com/phrazzld/architect/internal/gemini"
        "github.com/phrazzld/architect/internal/logutil"
)

// TokenResult holds information about token counts and limits
type TokenResult struct {
        TokenCount   int32
        InputLimit   int32
        ExceedsLimit bool
        LimitError   string
        Percentage   float64
}

// TokenManager defines the interface for token counting and management
type TokenManager interface {
        // GetTokenInfo retrieves token count information and checks limits
        GetTokenInfo(ctx context.Context, prompt string) (*TokenResult, error)

        // CheckTokenLimit verifies the prompt doesn't exceed the model's token limit
        CheckTokenLimit(ctx context.Context, prompt string) error

        // PromptForConfirmation asks for user confirmation to proceed if token count exceeds threshold
        PromptForConfirmation(tokenCount int32, threshold int) bool
}

// tokenManager implements the TokenManager interface
type tokenManager struct {
        logger logutil.LoggerInterface
        client gemini.Client
}

// NewTokenManager creates a new TokenManager instance
func NewTokenManager(logger logutil.LoggerInterface, client gemini.Client) (TokenManager, error) <span class="cov8" title="1">{
        if client == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("client cannot be nil for TokenManager")
        }</span>
        <span class="cov8" title="1">return &amp;tokenManager{
                logger: logger,
                client: client,
        }, nil</span>
}

// GetTokenInfo retrieves token count information and checks limits
func (tm *tokenManager) GetTokenInfo(ctx context.Context, prompt string) (*TokenResult, error) <span class="cov8" title="1">{
        // Create result structure
        result := &amp;TokenResult{
                ExceedsLimit: false,
        }

        // Get model information (limits)
        modelInfo, err := tm.client.GetModelInfo(ctx)
        if err != nil </span><span class="cov8" title="1">{
                // Pass through API errors directly for better error messages
                if _, ok := gemini.IsAPIError(err); ok </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                // Wrap other errors
                <span class="cov8" title="1">return nil, fmt.Errorf("failed to get model info for token limit check: %w", err)</span>
        }

        // Store input limit
        <span class="cov8" title="1">result.InputLimit = modelInfo.InputTokenLimit

        // Count tokens in the prompt
        tokenResult, err := tm.client.CountTokens(ctx, prompt)
        if err != nil </span><span class="cov8" title="1">{
                // Pass through API errors directly for better error messages
                if _, ok := gemini.IsAPIError(err); ok </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Wrap other errors
                <span class="cov8" title="1">return nil, fmt.Errorf("failed to count tokens for token limit check: %w", err)</span>
        }

        // Store token count
        <span class="cov8" title="1">result.TokenCount = tokenResult.Total

        // Calculate percentage of limit
        result.Percentage = float64(result.TokenCount) / float64(result.InputLimit) * 100

        // Log token usage information
        tm.logger.Debug("Token usage: %d / %d (%.1f%%)",
                result.TokenCount,
                result.InputLimit,
                result.Percentage)

        // Check if the prompt exceeds the token limit
        if result.TokenCount &gt; result.InputLimit </span><span class="cov8" title="1">{
                result.ExceedsLimit = true
                result.LimitError = fmt.Sprintf("prompt exceeds token limit (%d tokens &gt; %d token limit)",
                        result.TokenCount, result.InputLimit)
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// CheckTokenLimit verifies the prompt doesn't exceed the model's token limit
func (tm *tokenManager) CheckTokenLimit(ctx context.Context, prompt string) error <span class="cov8" title="1">{
        tokenInfo, err := tm.GetTokenInfo(ctx, prompt)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if tokenInfo.ExceedsLimit </span><span class="cov8" title="1">{
                return fmt.Errorf(tokenInfo.LimitError)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// PromptForConfirmation asks for user confirmation to proceed
func (tm *tokenManager) PromptForConfirmation(tokenCount int32, threshold int) bool <span class="cov8" title="1">{
        if threshold &lt;= 0 || int32(threshold) &gt; tokenCount </span><span class="cov8" title="1">{
                // No confirmation needed if threshold is disabled (0) or token count is below threshold
                return true
        }</span>

        <span class="cov0" title="0">tm.logger.Info("Token count (%d) exceeds confirmation threshold (%d).", tokenCount, threshold)
        tm.logger.Info("Do you want to proceed with the API call? [y/N]: ")

        reader := bufio.NewReader(os.Stdin)
        response, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                tm.logger.Error("Error reading input: %v", err)
                return false
        }</span>

        // Trim whitespace and convert to lowercase
        <span class="cov0" title="0">response = strings.ToLower(strings.TrimSpace(response))

        // Only proceed if the user explicitly confirms with 'y' or 'yes'
        return response == "y" || response == "yes"</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package modelproc provides model processing functionality for the architect tool.
// It encapsulates the logic for interacting with AI models, managing tokens,
// writing outputs, and logging operations.
package modelproc

import (
        "context"
        "fmt"
        "path/filepath"
        "strings"
        "time"

        "github.com/phrazzld/architect/internal/auditlog"
        "github.com/phrazzld/architect/internal/config"
        "github.com/phrazzld/architect/internal/gemini"
        "github.com/phrazzld/architect/internal/logutil"
)

// APIService defines the interface for API-related operations
type APIService interface {
        // InitClient initializes and returns a Gemini client
        InitClient(ctx context.Context, apiKey, modelName, apiEndpoint string) (gemini.Client, error)

        // ProcessResponse processes the API response and extracts content
        ProcessResponse(result *gemini.GenerationResult) (string, error)

        // IsEmptyResponseError checks if an error is related to empty API responses
        IsEmptyResponseError(err error) bool

        // IsSafetyBlockedError checks if an error is related to safety filters
        IsSafetyBlockedError(err error) bool

        // GetErrorDetails extracts detailed information from an error
        GetErrorDetails(err error) string
}

// TokenResult holds information about token counts and limits
type TokenResult struct {
        TokenCount   int32
        InputLimit   int32
        ExceedsLimit bool
        LimitError   string
        Percentage   float64
}

// TokenManager defines the interface for token counting and management
type TokenManager interface {
        // GetTokenInfo retrieves token count information and checks limits
        GetTokenInfo(ctx context.Context, prompt string) (*TokenResult, error)

        // CheckTokenLimit verifies the prompt doesn't exceed the model's token limit
        CheckTokenLimit(ctx context.Context, prompt string) error

        // PromptForConfirmation asks for user confirmation to proceed if token count exceeds threshold
        PromptForConfirmation(tokenCount int32, threshold int) bool
}

// tokenManager provides a local implementation of TokenManager to avoid import cycles
type tokenManager struct {
        logger      logutil.LoggerInterface
        auditLogger auditlog.AuditLogger
        client      gemini.Client
}

// NewTokenManagerWithClient creates a new tokenManager instance with a specific client.
// This is defined as a variable to allow it to be mocked in tests.
var NewTokenManagerWithClient = func(logger logutil.LoggerInterface, auditLogger auditlog.AuditLogger, client gemini.Client) TokenManager <span class="cov8" title="1">{
        return &amp;tokenManager{
                logger:      logger,
                auditLogger: auditLogger,
                client:      client,
        }
}</span>

// GetTokenInfo implements TokenManager.GetTokenInfo
func (tm *tokenManager) GetTokenInfo(ctx context.Context, prompt string) (*TokenResult, error) <span class="cov8" title="1">{
        // Get the model name from the injected client
        modelName := tm.client.GetModelName()

        // Log the start of token checking
        checkStartTime := time.Now()
        if logErr := tm.auditLogger.Log(auditlog.AuditEntry{
                Timestamp: checkStartTime,
                Operation: "CheckTokensStart",
                Status:    "InProgress",
                Inputs: map[string]interface{}{
                        "prompt_length": len(prompt),
                        "model_name":    modelName,
                },
                Message: "Starting token count check for model " + modelName,
        }); logErr != nil </span><span class="cov0" title="0">{
                tm.logger.Error("Failed to write audit log: %v", logErr)
        }</span>

        // Create result structure
        <span class="cov8" title="1">result := &amp;TokenResult{
                ExceedsLimit: false,
        }

        // Get model information (limits)
        modelInfo, err := tm.client.GetModelInfo(ctx)
        if err != nil </span><span class="cov0" title="0">{
                // Pass through API errors directly for better error messages
                if apiErr, ok := gemini.IsAPIError(err); ok </span><span class="cov0" title="0">{
                        // Log the token check failure
                        if logErr := tm.auditLogger.Log(auditlog.AuditEntry{
                                Timestamp: time.Now().UTC(),
                                Operation: "CheckTokens",
                                Status:    "Failure",
                                Inputs: map[string]interface{}{
                                        "prompt_length": len(prompt),
                                        "model_name":    modelName,
                                },
                                Error: &amp;auditlog.ErrorInfo{
                                        Message: apiErr.Message,
                                        Type:    "APIError",
                                },
                                Message: "Token count check failed for model " + modelName,
                        }); logErr != nil </span><span class="cov0" title="0">{
                                tm.logger.Error("Failed to write audit log: %v", logErr)
                        }</span>

                        <span class="cov0" title="0">return nil, apiErr</span>
                }

                // Log the token check failure for other errors
                <span class="cov0" title="0">if logErr := tm.auditLogger.Log(auditlog.AuditEntry{
                        Timestamp: time.Now().UTC(),
                        Operation: "CheckTokens",
                        Status:    "Failure",
                        Inputs: map[string]interface{}{
                                "prompt_length": len(prompt),
                                "model_name":    modelName,
                        },
                        Error: &amp;auditlog.ErrorInfo{
                                Message: fmt.Sprintf("Failed to get model info: %v", err),
                                Type:    "TokenCheckError",
                        },
                        Message: "Token count check failed for model " + modelName,
                }); logErr != nil </span><span class="cov0" title="0">{
                        tm.logger.Error("Failed to write audit log: %v", logErr)
                }</span>

                // Wrap other errors
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get model info for token limit check: %w", err)</span>
        }

        // Store input limit
        <span class="cov8" title="1">result.InputLimit = modelInfo.InputTokenLimit

        // Count tokens in the prompt
        tokenResult, err := tm.client.CountTokens(ctx, prompt)
        if err != nil </span><span class="cov0" title="0">{
                // Pass through API errors directly for better error messages
                if apiErr, ok := gemini.IsAPIError(err); ok </span><span class="cov0" title="0">{
                        // Log the token check failure
                        if logErr := tm.auditLogger.Log(auditlog.AuditEntry{
                                Timestamp: time.Now().UTC(),
                                Operation: "CheckTokens",
                                Status:    "Failure",
                                Inputs: map[string]interface{}{
                                        "prompt_length": len(prompt),
                                        "model_name":    modelName,
                                },
                                Error: &amp;auditlog.ErrorInfo{
                                        Message: apiErr.Message,
                                        Type:    "APIError",
                                },
                                Message: "Token count check failed for model " + modelName,
                        }); logErr != nil </span><span class="cov0" title="0">{
                                tm.logger.Error("Failed to write audit log: %v", logErr)
                        }</span>

                        <span class="cov0" title="0">return nil, apiErr</span>
                }

                // Log the token check failure for other errors
                <span class="cov0" title="0">if logErr := tm.auditLogger.Log(auditlog.AuditEntry{
                        Timestamp: time.Now().UTC(),
                        Operation: "CheckTokens",
                        Status:    "Failure",
                        Inputs: map[string]interface{}{
                                "prompt_length": len(prompt),
                                "model_name":    modelName,
                        },
                        Error: &amp;auditlog.ErrorInfo{
                                Message: fmt.Sprintf("Failed to count tokens: %v", err),
                                Type:    "TokenCheckError",
                        },
                        Message: "Token count check failed for model " + modelName,
                }); logErr != nil </span><span class="cov0" title="0">{
                        tm.logger.Error("Failed to write audit log: %v", logErr)
                }</span>

                // Wrap other errors
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to count tokens for token limit check: %w", err)</span>
        }

        // Store token count
        <span class="cov8" title="1">result.TokenCount = tokenResult.Total

        // Calculate percentage of limit
        result.Percentage = float64(result.TokenCount) / float64(result.InputLimit) * 100

        // Log token usage information
        tm.logger.Debug("Token usage: %d / %d (%.1f%%)",
                result.TokenCount,
                result.InputLimit,
                result.Percentage)

        // Check if the prompt exceeds the token limit
        if result.TokenCount &gt; result.InputLimit </span><span class="cov8" title="1">{
                result.ExceedsLimit = true
                result.LimitError = fmt.Sprintf("prompt exceeds token limit (%d tokens &gt; %d token limit)",
                        result.TokenCount, result.InputLimit)

                // Log the token limit exceeded case
                if logErr := tm.auditLogger.Log(auditlog.AuditEntry{
                        Timestamp: time.Now().UTC(),
                        Operation: "CheckTokens",
                        Status:    "Failure",
                        Inputs: map[string]interface{}{
                                "prompt_length": len(prompt),
                                "model_name":    modelName,
                        },
                        TokenCounts: &amp;auditlog.TokenCountInfo{
                                PromptTokens: result.TokenCount,
                                TotalTokens:  result.TokenCount,
                                Limit:        result.InputLimit,
                        },
                        Error: &amp;auditlog.ErrorInfo{
                                Message: result.LimitError,
                                Type:    "TokenLimitExceededError",
                        },
                        Message: "Token limit exceeded for model " + modelName,
                }); logErr != nil </span><span class="cov0" title="0">{
                        tm.logger.Error("Failed to write audit log: %v", logErr)
                }</span>
        } else<span class="cov8" title="1"> {
                // Log the successful token check
                if logErr := tm.auditLogger.Log(auditlog.AuditEntry{
                        Timestamp: time.Now().UTC(),
                        Operation: "CheckTokens",
                        Status:    "Success",
                        Inputs: map[string]interface{}{
                                "prompt_length": len(prompt),
                                "model_name":    modelName,
                        },
                        Outputs: map[string]interface{}{
                                "percentage": result.Percentage,
                        },
                        TokenCounts: &amp;auditlog.TokenCountInfo{
                                PromptTokens: result.TokenCount,
                                TotalTokens:  result.TokenCount,
                                Limit:        result.InputLimit,
                        },
                        Message: fmt.Sprintf("Token check passed for model %s: %d / %d tokens (%.1f%% of limit)",
                                modelName, result.TokenCount, result.InputLimit, result.Percentage),
                }); logErr != nil </span><span class="cov0" title="0">{
                        tm.logger.Error("Failed to write audit log: %v", logErr)
                }</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// CheckTokenLimit implements TokenManager.CheckTokenLimit
func (tm *tokenManager) CheckTokenLimit(ctx context.Context, prompt string) error <span class="cov0" title="0">{
        tokenInfo, err := tm.GetTokenInfo(ctx, prompt)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if tokenInfo.ExceedsLimit </span><span class="cov0" title="0">{
                return fmt.Errorf(tokenInfo.LimitError)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// PromptForConfirmation implements TokenManager.PromptForConfirmation
func (tm *tokenManager) PromptForConfirmation(tokenCount int32, threshold int) bool <span class="cov8" title="1">{
        if threshold &lt;= 0 || int32(threshold) &gt; tokenCount </span><span class="cov8" title="1">{
                // No confirmation needed if threshold is disabled (0) or token count is below threshold
                tm.logger.Debug("No confirmation needed: threshold=%d, tokenCount=%d", threshold, tokenCount)
                return true
        }</span>

        <span class="cov0" title="0">tm.logger.Info("Token count (%d) exceeds confirmation threshold (%d).", tokenCount, threshold)
        tm.logger.Info("Do you want to proceed with the API call? [y/N]: ")

        // Implementation omitted for brevity - defaults to always returning true in this context
        // The actual confirmation would be handled in the top-level TokenManager
        return true</span>
}

// FileWriter defines the interface for file output writing
type FileWriter interface {
        // SaveToFile writes content to the specified file
        SaveToFile(content, outputFile string) error
}

// ModelProcessor handles all interactions with AI models including initialization,
// token management, request generation, response processing, and output handling.
type ModelProcessor struct {
        // Dependencies
        apiService   APIService
        tokenManager TokenManager
        fileWriter   FileWriter
        auditLogger  auditlog.AuditLogger
        logger       logutil.LoggerInterface
        config       *config.CliConfig
}

// NewProcessor creates a new ModelProcessor with all required dependencies.
// Note: The tokenManager parameter is ignored as each model needs its own TokenManager
// with the appropriate client. TokenManagers are created per-model in the Process method.
// This is necessary to avoid import cycles and to handle the multi-model architecture.
func NewProcessor(
        apiService APIService,
        _ TokenManager, // Ignored - Token managers are created per-model in Process
        fileWriter FileWriter,
        auditLogger auditlog.AuditLogger,
        logger logutil.LoggerInterface,
        config *config.CliConfig,
) *ModelProcessor <span class="cov8" title="1">{
        return &amp;ModelProcessor{
                apiService:   apiService,
                tokenManager: nil, // Not used - each model gets its own TokenManager in Process
                fileWriter:   fileWriter,
                auditLogger:  auditLogger,
                logger:       logger,
                config:       config,
        }
}</span>

// Process handles the entire model processing workflow for a single model.
// It implements the logic from the previous processModel/processModelConcurrently functions,
// including initialization, token checking, generation, response processing, and output saving.
func (p *ModelProcessor) Process(ctx context.Context, modelName string, stitchedPrompt string) error <span class="cov8" title="1">{
        p.logger.Info("Processing model: %s", modelName)

        // 1. Initialize model-specific client
        geminiClient, err := p.apiService.InitClient(ctx, p.config.APIKey, modelName, p.config.APIEndpoint)
        if err != nil </span><span class="cov8" title="1">{
                errorDetails := p.apiService.GetErrorDetails(err)
                if apiErr, ok := gemini.IsAPIError(err); ok </span><span class="cov0" title="0">{
                        p.logger.Error("Error creating Gemini client for model %s: %s", modelName, apiErr.Message)
                        if apiErr.Suggestion != "" </span><span class="cov0" title="0">{
                                p.logger.Error("Suggestion: %s", apiErr.Suggestion)
                        }</span>
                        <span class="cov0" title="0">if p.config.LogLevel == logutil.DebugLevel </span><span class="cov0" title="0">{
                                p.logger.Debug("Error details: %s", apiErr.DebugInfo())
                        }</span>
                } else<span class="cov8" title="1"> {
                        p.logger.Error("Error creating Gemini client for model %s: %s", modelName, errorDetails)
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("failed to initialize API client for model %s: %w", modelName, err)</span>
        }

        // BUGFIX: Ensure geminiClient is not nil before attempting to close it
        // CAUSE: There was a race condition in tests where geminiClient could be nil
        //        when concurrent tests interact with rate limiting, leading to nil pointer dereference
        // FIX: Add safety check in defer to prevent a panic if client is nil for any reason
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if geminiClient != nil </span><span class="cov8" title="1">{
                        geminiClient.Close()
                }</span>
        }()

        // 2. Check token limits for this model
        <span class="cov8" title="1">p.logger.Info("Checking token limits for model %s...", modelName)

        // We need to create a TokenManager with the client, but we can't import architect directly
        // without causing an import cycle. For now, use the per-model client in method calls
        // TODO: Refactor this to use a proper factory pattern

        // Note: We rely on the TokenManager to handle all audit logging for token checking operations.
        // The audit logs for CheckTokensStart, CheckTokens Success/Failure are managed by the TokenManager
        // implementation and should not be duplicated here.

        // Using direct TokenManager creation without importing architect package
        // Implementation-specific detail to avoid import cycle
        tokenInfo, err := NewTokenManagerWithClient(p.logger, p.auditLogger, geminiClient).GetTokenInfo(ctx, stitchedPrompt)
        if err != nil </span><span class="cov8" title="1">{
                p.logger.Error("Token count check failed for model %s", modelName)

                // Check if it's an API error with enhanced details
                if apiErr, ok := gemini.IsAPIError(err); ok </span><span class="cov0" title="0">{
                        p.logger.Error("Token count check failed for model %s: %s", modelName, apiErr.Message)
                        if apiErr.Suggestion != "" </span><span class="cov0" title="0">{
                                p.logger.Error("Suggestion: %s", apiErr.Suggestion)
                        }</span>
                        <span class="cov0" title="0">p.logger.Debug("Error details: %s", apiErr.DebugInfo())</span>
                } else<span class="cov8" title="1"> {
                        p.logger.Error("Token count check failed for model %s: %v", modelName, err)
                        p.logger.Error("Try reducing context by using --include, --exclude, or --exclude-names flags")
                }</span>

                <span class="cov8" title="1">return fmt.Errorf("token count check failed for model %s: %w", modelName, err)</span>
        }

        // If token limit is exceeded, abort
        <span class="cov8" title="1">if tokenInfo.ExceedsLimit </span><span class="cov8" title="1">{
                p.logger.Error("Token limit exceeded for model %s", modelName)
                p.logger.Error("Token limit exceeded: %s", tokenInfo.LimitError)
                p.logger.Error("Try reducing context by using --include, --exclude, or --exclude-names flags")

                return fmt.Errorf("token limit exceeded for model %s: %s", modelName, tokenInfo.LimitError)
        }</span>

        // Prompt for confirmation if token count exceeds threshold
        // Create a token manager for this model if needed (same one used for token count)
        <span class="cov8" title="1">tokenManager := NewTokenManagerWithClient(p.logger, p.auditLogger, geminiClient)
        if !tokenManager.PromptForConfirmation(tokenInfo.TokenCount, p.config.ConfirmTokens) </span><span class="cov8" title="1">{
                p.logger.Info("Operation cancelled by user due to token count.")
                return nil
        }</span>

        <span class="cov8" title="1">p.logger.Info("Token check passed for model %s: %d / %d tokens (%.1f%% of limit)",
                modelName, tokenInfo.TokenCount, tokenInfo.InputLimit, tokenInfo.Percentage)

        // 3. Generate content with this model
        p.logger.Info("Generating output with model %s (Temperature: %.2f, MaxOutputTokens: %d)...",
                modelName,
                geminiClient.GetTemperature(),
                geminiClient.GetMaxOutputTokens())

        // Log the start of content generation
        generateStartTime := time.Now()
        if logErr := p.auditLogger.Log(auditlog.AuditEntry{
                Timestamp: generateStartTime,
                Operation: "GenerateContentStart",
                Status:    "InProgress",
                Inputs: map[string]interface{}{
                        "model_name":    modelName,
                        "prompt_length": len(stitchedPrompt),
                },
                Message: "Starting content generation with Gemini model " + modelName,
        }); logErr != nil </span><span class="cov0" title="0">{
                p.logger.Error("Failed to write audit log: %v", logErr)
        }</span>

        <span class="cov8" title="1">result, err := geminiClient.GenerateContent(ctx, stitchedPrompt)

        // Calculate duration in milliseconds
        generateDurationMs := time.Since(generateStartTime).Milliseconds()

        if err != nil </span><span class="cov8" title="1">{
                p.logger.Error("Generation failed for model %s", modelName)

                var errorType string
                var errorMessage string

                // Check if it's an API error with enhanced details
                if apiErr, ok := gemini.IsAPIError(err); ok </span><span class="cov0" title="0">{
                        p.logger.Error("Error generating content with model %s: %s", modelName, apiErr.Message)
                        if apiErr.Suggestion != "" </span><span class="cov0" title="0">{
                                p.logger.Error("Suggestion: %s", apiErr.Suggestion)
                        }</span>
                        <span class="cov0" title="0">p.logger.Debug("Error details: %s", apiErr.DebugInfo())
                        errorType = "APIError"
                        errorMessage = apiErr.Message</span>
                } else<span class="cov8" title="1"> {
                        p.logger.Error("Error generating content with model %s: %v (Current token count: %d)", modelName, err, tokenInfo.TokenCount)
                        errorType = "ContentGenerationError"
                        errorMessage = fmt.Sprintf("Failed to generate content with model %s: %v", modelName, err)
                }</span>

                // Log the content generation failure
                <span class="cov8" title="1">if logErr := p.auditLogger.Log(auditlog.AuditEntry{
                        Timestamp:  time.Now().UTC(),
                        Operation:  "GenerateContentEnd",
                        Status:     "Failure",
                        DurationMs: &amp;generateDurationMs,
                        Inputs: map[string]interface{}{
                                "model_name":    modelName,
                                "prompt_length": len(stitchedPrompt),
                        },
                        Error: &amp;auditlog.ErrorInfo{
                                Message: errorMessage,
                                Type:    errorType,
                        },
                        Message: "Content generation failed for model " + modelName,
                }); logErr != nil </span><span class="cov0" title="0">{
                        p.logger.Error("Failed to write audit log: %v", logErr)
                }</span>

                <span class="cov8" title="1">return fmt.Errorf("output generation failed for model %s: %w", modelName, err)</span>
        }

        // Log successful content generation
        <span class="cov8" title="1">if logErr := p.auditLogger.Log(auditlog.AuditEntry{
                Timestamp:  time.Now().UTC(),
                Operation:  "GenerateContentEnd",
                Status:     "Success",
                DurationMs: &amp;generateDurationMs,
                Inputs: map[string]interface{}{
                        "model_name":    modelName,
                        "prompt_length": len(stitchedPrompt),
                },
                Outputs: map[string]interface{}{
                        "finish_reason":      result.FinishReason,
                        "has_safety_ratings": len(result.SafetyRatings) &gt; 0,
                },
                TokenCounts: &amp;auditlog.TokenCountInfo{
                        PromptTokens: int32(tokenInfo.TokenCount),
                        OutputTokens: int32(result.TokenCount),
                        TotalTokens:  int32(tokenInfo.TokenCount + result.TokenCount),
                },
                Message: "Content generation completed successfully for model " + modelName,
        }); logErr != nil </span><span class="cov0" title="0">{
                p.logger.Error("Failed to write audit log: %v", logErr)
        }</span>

        // 4. Process API response
        <span class="cov8" title="1">generatedOutput, err := p.apiService.ProcessResponse(result)
        if err != nil </span><span class="cov8" title="1">{
                // Get detailed error information
                errorDetails := p.apiService.GetErrorDetails(err)

                // Provide specific error messages based on error type
                if p.apiService.IsEmptyResponseError(err) </span><span class="cov0" title="0">{
                        p.logger.Error("Received empty or invalid response from Gemini API for model %s", modelName)
                        p.logger.Error("Error details: %s", errorDetails)
                        return fmt.Errorf("failed to process API response for model %s due to empty content: %w", modelName, err)
                }</span> else<span class="cov8" title="1"> if p.apiService.IsSafetyBlockedError(err) </span><span class="cov0" title="0">{
                        p.logger.Error("Content was blocked by Gemini safety filters for model %s", modelName)
                        p.logger.Error("Error details: %s", errorDetails)
                        return fmt.Errorf("failed to process API response for model %s due to safety restrictions: %w", modelName, err)
                }</span> else<span class="cov8" title="1"> {
                        // Generic API error handling
                        return fmt.Errorf("failed to process API response for model %s: %w", modelName, err)
                }</span>
        }
        <span class="cov8" title="1">contentLength := len(generatedOutput)
        p.logger.Info("Output generated successfully with model %s (content length: %d characters, tokens: %d)",
                modelName, contentLength, result.TokenCount)

        // 5. Sanitize model name for use in filename
        sanitizedModelName := sanitizeFilename(modelName)

        // 6. Construct output file path
        outputFilePath := filepath.Join(p.config.OutputDir, sanitizedModelName+".md")

        // 7. Save the output to file
        if err := p.saveOutputToFile(outputFilePath, generatedOutput); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to save output for model %s: %w", modelName, err)
        }</span>

        <span class="cov8" title="1">p.logger.Info("Successfully processed model: %s", modelName)
        return nil</span>
}

// sanitizeFilename replaces characters that are not valid in filenames
func sanitizeFilename(filename string) string <span class="cov8" title="1">{
        // Replace slashes and other problematic characters with hyphens
        replacer := strings.NewReplacer(
                "/", "-",
                "\\", "-",
                ":", "-",
                "*", "-",
                "?", "-",
                "\"", "-",
                "&lt;", "-",
                "&gt;", "-",
                "|", "-",
        )
        return replacer.Replace(filename)
}</span>

// saveOutputToFile is a helper method that saves the generated output to a file
// and includes audit logging around the file writing operation.
func (p *ModelProcessor) saveOutputToFile(outputFilePath, content string) error <span class="cov8" title="1">{
        // Log the start of output saving
        saveStartTime := time.Now()
        if logErr := p.auditLogger.Log(auditlog.AuditEntry{
                Timestamp: saveStartTime,
                Operation: "SaveOutputStart",
                Status:    "InProgress",
                Inputs: map[string]interface{}{
                        "output_path":    outputFilePath,
                        "content_length": len(content),
                },
                Message: "Starting to save output to file",
        }); logErr != nil </span><span class="cov0" title="0">{
                p.logger.Error("Failed to write audit log: %v", logErr)
        }</span>

        // Save output file
        <span class="cov8" title="1">p.logger.Info("Writing output to %s...", outputFilePath)
        err := p.fileWriter.SaveToFile(content, outputFilePath)

        // Calculate duration in milliseconds
        saveDurationMs := time.Since(saveStartTime).Milliseconds()

        if err != nil </span><span class="cov8" title="1">{
                // Log failure to save output
                p.logger.Error("Error saving output to file %s: %v", outputFilePath, err)

                if logErr := p.auditLogger.Log(auditlog.AuditEntry{
                        Timestamp:  time.Now().UTC(),
                        Operation:  "SaveOutputEnd",
                        Status:     "Failure",
                        DurationMs: &amp;saveDurationMs,
                        Inputs: map[string]interface{}{
                                "output_path": outputFilePath,
                        },
                        Error: &amp;auditlog.ErrorInfo{
                                Message: fmt.Sprintf("Failed to save output to file: %v", err),
                                Type:    "FileIOError",
                        },
                        Message: "Failed to save output to file",
                }); logErr != nil </span><span class="cov0" title="0">{
                        p.logger.Error("Failed to write audit log: %v", logErr)
                }</span>

                <span class="cov8" title="1">return fmt.Errorf("error saving output to file %s: %w", outputFilePath, err)</span>
        }

        // Log successful saving of output
        <span class="cov8" title="1">if logErr := p.auditLogger.Log(auditlog.AuditEntry{
                Timestamp:  time.Now().UTC(),
                Operation:  "SaveOutputEnd",
                Status:     "Success",
                DurationMs: &amp;saveDurationMs,
                Inputs: map[string]interface{}{
                        "output_path": outputFilePath,
                },
                Outputs: map[string]interface{}{
                        "content_length": len(content),
                },
                Message: "Successfully saved output to file",
        }); logErr != nil </span><span class="cov0" title="0">{
                p.logger.Error("Failed to write audit log: %v", logErr)
        }</span>

        <span class="cov8" title="1">p.logger.Info("Output successfully generated and saved to %s", outputFilePath)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package prompt handles the creation and manipulation of prompts
// sent to the generative AI models. It provides functions for constructing
// prompts with context files and proper escaping of content.
package prompt

import (
        "strings"

        "github.com/phrazzld/architect/internal/fileutil"
)

// EscapeContent helps prevent conflicts with XML-like tags by escaping &lt; and &gt; characters
func EscapeContent(content string) string <span class="cov8" title="1">{
        escaped := strings.ReplaceAll(content, "&lt;", "&amp;lt;")
        escaped = strings.ReplaceAll(escaped, "&gt;", "&amp;gt;")
        return escaped
}</span>

// StitchPrompt combines instructions and file context into the final prompt string with XML-like tags
func StitchPrompt(instructions string, contextFiles []fileutil.FileMeta) string <span class="cov8" title="1">{
        var sb strings.Builder

        // Add instructions block
        sb.WriteString("&lt;instructions&gt;\n")
        if instructions != "" </span><span class="cov8" title="1">{
                sb.WriteString(instructions)
                sb.WriteString("\n")
        }</span>
        <span class="cov8" title="1">sb.WriteString("&lt;/instructions&gt;\n")

        // Add context block
        sb.WriteString("&lt;context&gt;\n")
        for _, file := range contextFiles </span><span class="cov8" title="1">{
                // Add file path tag
                sb.WriteString("&lt;path&gt;")
                sb.WriteString(file.Path)
                sb.WriteString("&lt;/path&gt;\n")

                // Add file content with escaping
                sb.WriteString(EscapeContent(file.Content))
                sb.WriteString("\n\n")
        }</span>
        <span class="cov8" title="1">sb.WriteString("&lt;/context&gt;")

        return sb.String()</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package auditlog provides structured logging for audit purposes
package auditlog

import (
        "encoding/json"
        "fmt"
        "os"
        "sync"
        "time"

        "github.com/phrazzld/architect/internal/logutil"
)

// AuditLogger defines the interface for logging audit events.
// Implementations of this interface will handle persisting audit
// log entries in various formats (e.g., JSON Lines file, no-op).
type AuditLogger interface {
        // Log records a single audit entry.
        // The entry contains information about operations, status, and relevant metadata.
        // Returns an error if the logging operation fails.
        Log(entry AuditEntry) error

        // Close releases any resources used by the logger (e.g., open file handles).
        // Should be called when the logger is no longer needed.
        // Returns an error if the closing operation fails.
        Close() error
}

// FileAuditLogger implements AuditLogger by writing JSON Lines to a file.
type FileAuditLogger struct {
        file   *os.File
        mu     sync.Mutex
        logger logutil.LoggerInterface // For logging errors within the audit logger itself
}

// NewFileAuditLogger creates a new FileAuditLogger that writes to the specified file path.
// If the file doesn't exist, it will be created. If it does exist, logs will be appended.
// The provided internal logger is used to log any errors that occur during audit logging operations.
func NewFileAuditLogger(filePath string, internalLogger logutil.LoggerInterface) (*FileAuditLogger, error) <span class="cov8" title="1">{
        file, err := os.OpenFile(filePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        if err != nil </span><span class="cov8" title="1">{
                internalLogger.Error("Failed to open audit log file '%s': %v", filePath, err)
                return nil, fmt.Errorf("failed to open audit log file %s: %w", filePath, err)
        }</span>
        <span class="cov8" title="1">internalLogger.Info("Audit logging enabled to file: %s", filePath)
        return &amp;FileAuditLogger{
                file:   file,
                logger: internalLogger,
        }, nil</span>
}

// Log records a single audit entry by marshaling it to JSON and writing it to the log file.
// It sets the entry timestamp if not already set and ensures thread safety with a mutex lock.
func (l *FileAuditLogger) Log(entry AuditEntry) error <span class="cov8" title="1">{
        l.mu.Lock()
        defer l.mu.Unlock()

        // Ensure timestamp is set
        if entry.Timestamp.IsZero() </span><span class="cov8" title="1">{
                entry.Timestamp = time.Now().UTC()
        }</span>

        // Marshal entry to JSON
        <span class="cov8" title="1">jsonData, err := json.Marshal(entry)
        if err != nil </span><span class="cov0" title="0">{
                l.logger.Error("Failed to marshal audit entry to JSON: %v, Entry: %+v", err, entry)
                return fmt.Errorf("failed to marshal audit entry: %w", err)
        }</span>

        // Write JSON line to file
        <span class="cov8" title="1">if _, err := l.file.Write(append(jsonData, '\n')); err != nil </span><span class="cov0" title="0">{
                l.logger.Error("Failed to write audit entry to file '%s': %v", l.file.Name(), err)
                return fmt.Errorf("failed to write audit entry: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Close properly closes the log file.
// It ensures thread safety with a mutex lock and prevents double-closing.
func (l *FileAuditLogger) Close() error <span class="cov8" title="1">{
        l.mu.Lock()
        defer l.mu.Unlock()

        if l.file != nil </span><span class="cov8" title="1">{
                l.logger.Info("Closing audit log file: %s", l.file.Name())
                err := l.file.Close()
                l.file = nil // Prevent double close
                if err != nil </span><span class="cov0" title="0">{
                        l.logger.Error("Error closing audit log file: %v", err)
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// NoOpAuditLogger implements AuditLogger with no-op methods.
// This implementation is used when audit logging is disabled.
type NoOpAuditLogger struct{}

// NewNoOpAuditLogger creates a new NoOpAuditLogger instance.
func NewNoOpAuditLogger() *NoOpAuditLogger <span class="cov8" title="1">{
        return &amp;NoOpAuditLogger{}
}</span>

// Log implements the AuditLogger interface but performs no action.
// It always returns nil (no error).
func (l *NoOpAuditLogger) Log(entry AuditEntry) error <span class="cov8" title="1">{
        return nil // Do nothing
}</span>

// Close implements the AuditLogger interface but performs no action.
// It always returns nil (no error).
func (l *NoOpAuditLogger) Close() error <span class="cov8" title="1">{
        return nil // Do nothing
}</span>

// Compile-time checks to ensure implementations satisfy the AuditLogger interface.
var _ AuditLogger = (*FileAuditLogger)(nil)
var _ AuditLogger = (*NoOpAuditLogger)(nil)
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package config handles loading and managing application configuration.
// It defines a canonical set of configuration parameters used throughout
// the application, consolidating configuration from CLI flags, environment
// variables, and default values. This centralized approach ensures
// consistent configuration handling and reduces duplication.
package config

import (
        "github.com/phrazzld/architect/internal/logutil"
)

// Configuration constants
const (
        // Default values
        DefaultOutputFile = "PLAN.md"
        DefaultModel      = "gemini-2.5-pro-exp-03-25"
        APIKeyEnvVar      = "GEMINI_API_KEY"
        APIEndpointEnvVar = "GEMINI_API_URL"
        DefaultFormat     = "&lt;{path}&gt;\n```\n{content}\n```\n&lt;/{path}&gt;\n\n"

        // Default rate limiting values
        DefaultMaxConcurrentRequests      = 5  // Default maximum concurrent API requests
        DefaultRateLimitRequestsPerMinute = 60 // Default requests per minute per model

        // Default excludes for file extensions
        DefaultExcludes = ".exe,.bin,.obj,.o,.a,.lib,.so,.dll,.dylib,.class,.jar,.pyc,.pyo,.pyd," +
                ".zip,.tar,.gz,.rar,.7z,.pdf,.doc,.docx,.xls,.xlsx,.ppt,.pptx,.odt,.ods,.odp," +
                ".jpg,.jpeg,.png,.gif,.bmp,.tiff,.svg,.mp3,.wav,.ogg,.mp4,.avi,.mov,.wmv,.flv," +
                ".iso,.img,.dmg,.db,.sqlite,.log"

        // Default excludes for file and directory names
        DefaultExcludeNames = ".git,.hg,.svn,node_modules,bower_components,vendor,target,dist,build," +
                "out,tmp,coverage,__pycache__,*.pyc,*.pyo,.DS_Store,~$*,desktop.ini,Thumbs.db," +
                "package-lock.json,yarn.lock,go.sum,go.work"
)

// ExcludeConfig defines file exclusion configuration
type ExcludeConfig struct {
        // File extensions to exclude
        Extensions string
        // File and directory names to exclude
        Names string
}

// AppConfig holds essential configuration settings with defaults
type AppConfig struct {
        // Core settings with defaults
        OutputFile string
        ModelName  string
        Format     string

        // File handling settings
        Include       string
        ConfirmTokens int

        // Logging and display settings
        Verbose  bool
        LogLevel logutil.LogLevel

        // Exclude settings (hierarchical)
        Excludes ExcludeConfig
}

// DefaultConfig returns a new AppConfig instance with default values
func DefaultConfig() *AppConfig <span class="cov0" title="0">{
        return &amp;AppConfig{
                OutputFile:    DefaultOutputFile,
                ModelName:     DefaultModel,
                Format:        DefaultFormat,
                LogLevel:      logutil.InfoLevel,
                ConfirmTokens: 0, // Disabled by default
                Excludes: ExcludeConfig{
                        Extensions: DefaultExcludes,
                        Names:      DefaultExcludeNames,
                },
        }
}</span>

// CliConfig holds the parsed command-line options for the application.
// It serves as the canonical configuration structure used throughout the
// application, combining user inputs from CLI flags, environment variables,
// and default values. This struct is passed to components that need
// configuration parameters rather than having them parse flags directly.
type CliConfig struct {
        // Instructions configuration
        InstructionsFile string

        // Output configuration
        OutputDir    string
        AuditLogFile string // Path to write structured audit logs (JSON Lines)
        Format       string

        // Context gathering options
        Paths        []string
        Include      string
        Exclude      string
        ExcludeNames string
        DryRun       bool
        Verbose      bool

        // API configuration
        APIKey      string
        APIEndpoint string
        ModelNames  []string

        // Token management
        ConfirmTokens int

        // Logging
        LogLevel logutil.LogLevel

        // Rate limiting configuration
        MaxConcurrentRequests      int // Maximum number of concurrent API requests (0 = no limit)
        RateLimitRequestsPerMinute int // Maximum requests per minute per model (0 = no limit)
}

// NewDefaultCliConfig returns a CliConfig with default values.
// This is used as a starting point before parsing CLI flags, ensuring
// that all fields have sensible defaults even if not explicitly set
// by the user.
func NewDefaultCliConfig() *CliConfig <span class="cov8" title="1">{
        return &amp;CliConfig{
                Format:                     DefaultFormat,
                Exclude:                    DefaultExcludes,
                ExcludeNames:               DefaultExcludeNames,
                ModelNames:                 []string{DefaultModel},
                LogLevel:                   logutil.InfoLevel,
                MaxConcurrentRequests:      DefaultMaxConcurrentRequests,
                RateLimitRequestsPerMinute: DefaultRateLimitRequestsPerMinute,
        }
}</span>

// ValidateConfig checks if the configuration is valid and returns an error if not.
// It performs validation beyond simple type-checking, such as verifying that
// required fields are present, paths exist, and values are within acceptable ranges.
// This helps catch configuration errors early before they cause runtime failures.
func ValidateConfig(config *CliConfig, logger logutil.LoggerInterface) error <span class="cov0" title="0">{
        // This is a placeholder for the validation function that will be moved from CLI package
        // to maintain the API but will be implemented in the next task
        return nil
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// internal/fileutil/fileutil.go
package fileutil

import (
        "bytes"
        "log"
        "os"
        "os/exec"
        "path/filepath"
        "slices"
        "strings"
        "unicode"

        "github.com/phrazzld/architect/internal/logutil"
)

// FileMeta represents a file with its path and content.
type FileMeta struct {
        Path    string
        Content string
}

// Config holds file processing configuration
type Config struct {
        Verbose        bool
        IncludeExts    []string
        ExcludeExts    []string
        ExcludeNames   []string
        Format         string
        Logger         logutil.LoggerInterface
        GitAvailable   bool
        processedFiles int
        totalFiles     int               // For verbose logging
        fileCollector  func(path string) // Optional callback to collect processed file paths
}

// NewConfig creates a configuration with defaults.
func NewConfig(verbose bool, include, exclude, excludeNames, format string, logger logutil.LoggerInterface) *Config <span class="cov8" title="1">{
        // Check if git is available
        _, gitErr := exec.LookPath("git")
        gitAvailable := gitErr == nil

        if logger == nil </span><span class="cov0" title="0">{
                stdLogger := log.New(os.Stderr, "[fileutil] ", log.LstdFlags)
                logger = logutil.NewStdLoggerAdapter(stdLogger)
        }</span>

        <span class="cov8" title="1">cfg := &amp;Config{
                Verbose:      verbose,
                Format:       format,
                Logger:       logger,
                GitAvailable: gitAvailable,
        }

        // Process include/exclude extensions
        if include != "" </span><span class="cov8" title="1">{
                cfg.IncludeExts = strings.Split(include, ",")
                for i, ext := range cfg.IncludeExts </span><span class="cov8" title="1">{
                        ext = strings.TrimSpace(ext)
                        if !strings.HasPrefix(ext, ".") </span><span class="cov8" title="1">{
                                ext = "." + ext
                        }</span>
                        <span class="cov8" title="1">cfg.IncludeExts[i] = strings.ToLower(ext)</span>
                }
        }
        <span class="cov8" title="1">if exclude != "" </span><span class="cov8" title="1">{
                cfg.ExcludeExts = strings.Split(exclude, ",")
                for i, ext := range cfg.ExcludeExts </span><span class="cov8" title="1">{
                        ext = strings.TrimSpace(ext)
                        if !strings.HasPrefix(ext, ".") </span><span class="cov8" title="1">{
                                ext = "." + ext
                        }</span>
                        <span class="cov8" title="1">cfg.ExcludeExts[i] = strings.ToLower(ext)</span>
                }
        }
        // Process exclude names
        <span class="cov8" title="1">if excludeNames != "" </span><span class="cov8" title="1">{
                cfg.ExcludeNames = strings.Split(excludeNames, ",")
                for i, name := range cfg.ExcludeNames </span><span class="cov8" title="1">{
                        cfg.ExcludeNames[i] = strings.TrimSpace(name)
                }</span>
        }

        <span class="cov8" title="1">return cfg</span>
}

// SetFileCollector sets a callback function that will be called for each processed file
func (c *Config) SetFileCollector(collector func(path string)) <span class="cov8" title="1">{
        c.fileCollector = collector
}</span>

// isGitIgnored checks if a file is likely ignored by git or is hidden.
func isGitIgnored(path string, config *Config) bool <span class="cov8" title="1">{
        base := filepath.Base(path)
        // Always ignore .git directory contents implicitly
        if base == ".git" || strings.Contains(path, string(filepath.Separator)+".git"+string(filepath.Separator)) </span><span class="cov8" title="1">{
                return true
        }</span>

        // Use git check-ignore if available
        <span class="cov8" title="1">if config.GitAvailable </span><span class="cov8" title="1">{
                dir := filepath.Dir(path)
                // Check if the directory is actually a git repo first
                gitRepoCheck := exec.Command("git", "-C", dir, "rev-parse", "--is-inside-work-tree")
                if gitRepoCheck.Run() == nil </span><span class="cov0" title="0">{ // If it is a git repo
                        cmd := exec.Command("git", "-C", dir, "check-ignore", "-q", base)
                        err := cmd.Run()
                        if err == nil </span><span class="cov0" title="0">{ // Exit code 0: file IS ignored
                                config.Logger.Printf("Verbose: Git ignored: %s\n", path)
                                return true
                        }</span>
                        <span class="cov0" title="0">if exitErr, ok := err.(*exec.ExitError); ok &amp;&amp; exitErr.ExitCode() == 1 </span>{<span class="cov0" title="0">
                                // Exit code 1: file is NOT ignored
                                // Continue to other checks like hidden files
                        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                                // Other errors running check-ignore, log it but fall back
                                config.Logger.Printf("Verbose: Error running git check-ignore for %s: %v. Falling back.\n", path, err)
                        }</span>
                }
                // If not a git repo or check-ignore failed non-fatally, proceed to hidden check
        }

        // Fallback or additional check: Check if the file/directory itself is hidden
        <span class="cov8" title="1">if strings.HasPrefix(base, ".") &amp;&amp; base != "." &amp;&amp; base != ".." </span><span class="cov8" title="1">{
                config.Logger.Printf("Verbose: Hidden file/dir ignored: %s\n", path)
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// Constants for binary file detection
const (
        binarySampleSize            = 512
        binaryNonPrintableThreshold = 0.3
)

// isBinaryFile checks if content is likely binary.
func isBinaryFile(content []byte) bool <span class="cov8" title="1">{
        if len(content) &gt; 0 &amp;&amp; bytes.IndexByte(content, 0) != -1 </span><span class="cov8" title="1">{
                return true // Contains null byte
        }</span>
        <span class="cov8" title="1">nonPrintable := 0
        sampleSize := min(len(content), binarySampleSize)
        for i := 0; i &lt; sampleSize; i++ </span><span class="cov8" title="1">{
                if content[i] &lt; 32 &amp;&amp; !isWhitespace(content[i]) </span><span class="cov8" title="1">{
                        nonPrintable++
                }</span>
        }
        <span class="cov8" title="1">return float64(nonPrintable) &gt; float64(sampleSize)*binaryNonPrintableThreshold</span>
}

func isWhitespace(b byte) bool <span class="cov8" title="1">{
        return b == '\n' || b == '\r' || b == '\t' || b == ' '
}</span>

// shouldProcess checks all filters for a given file path.
func shouldProcess(path string, config *Config) bool <span class="cov8" title="1">{
        base := filepath.Base(path)
        ext := strings.ToLower(filepath.Ext(path))

        // Check if explicitly excluded by name
        if len(config.ExcludeNames) &gt; 0 &amp;&amp; slices.Contains(config.ExcludeNames, base) </span><span class="cov8" title="1">{
                config.Logger.Printf("Verbose: Skipping excluded name: %s\n", path)
                return false
        }</span>

        // Check if gitignored or hidden (handles .git implicitly)
        <span class="cov8" title="1">if isGitIgnored(path, config) </span><span class="cov8" title="1">{
                return false // Logging done within isGitIgnored
        }</span>

        // Check include extensions (if specified)
        <span class="cov8" title="1">if len(config.IncludeExts) &gt; 0 </span><span class="cov8" title="1">{
                included := false
                for _, includeExt := range config.IncludeExts </span><span class="cov8" title="1">{
                        if ext == includeExt </span><span class="cov8" title="1">{
                                included = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !included </span><span class="cov8" title="1">{
                        config.Logger.Printf("Verbose: Skipping non-included extension: %s (%s)\n", path, ext)
                        return false
                }</span>
        }

        // Check exclude extensions
        <span class="cov8" title="1">if len(config.ExcludeExts) &gt; 0 </span><span class="cov8" title="1">{
                for _, excludeExt := range config.ExcludeExts </span><span class="cov8" title="1">{
                        if ext == excludeExt </span><span class="cov8" title="1">{
                                config.Logger.Printf("Verbose: Skipping excluded extension: %s (%s)\n", path, ext)
                                return false
                        }</span>
                }
        }

        <span class="cov8" title="1">return true</span>
}

// processFile reads, checks, and adds a file to the FileMeta slice.
func processFile(path string, files *[]FileMeta, config *Config) <span class="cov8" title="1">{
        config.totalFiles++ // Increment total count when we attempt to process

        // Run all checks first
        if !shouldProcess(path, config) </span><span class="cov8" title="1">{
                return // Already logged why it was skipped
        }</span>

        <span class="cov8" title="1">content, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                config.Logger.Printf("Warning: Cannot read file %s: %v\n", path, err)
                return
        }</span>

        <span class="cov8" title="1">if isBinaryFile(content) </span><span class="cov8" title="1">{
                config.Logger.Printf("Verbose: Skipping binary file: %s\n", path)
                return
        }</span>

        // If all checks pass, process it
        <span class="cov8" title="1">config.processedFiles++
        config.Logger.Printf("Verbose: Processing file (%d/%d): %s (size: %d bytes)\n",
                config.processedFiles, config.totalFiles, path, len(content))

        // If a file collector is set, call it
        if config.fileCollector != nil </span><span class="cov8" title="1">{
                config.fileCollector(path)
        }</span>

        // Convert to absolute path if it's not already
        <span class="cov8" title="1">absPath := path
        if !filepath.IsAbs(path) </span><span class="cov8" title="1">{
                // If this fails, just use the original path
                if abs, err := filepath.Abs(path); err == nil </span><span class="cov8" title="1">{
                        absPath = abs
                }</span> else<span class="cov0" title="0"> {
                        config.Logger.Printf("Warning: Could not convert %s to absolute path: %v\n", path, err)
                }</span>
        }

        // Create a FileMeta and add it to the slice
        <span class="cov8" title="1">*files = append(*files, FileMeta{
                Path:    absPath,
                Content: string(content),
        })</span>
}

// GatherProjectContext walks paths and gathers files into a slice of FileMeta.
func GatherProjectContext(paths []string, config *Config) ([]FileMeta, int, error) <span class="cov8" title="1">{
        var files []FileMeta

        config.processedFiles = 0
        config.totalFiles = 0

        for _, p := range paths </span><span class="cov8" title="1">{
                info, err := os.Stat(p)
                if err != nil </span><span class="cov8" title="1">{
                        config.Logger.Printf("Warning: Cannot stat path %s: %v. Skipping.\n", p, err)
                        continue</span>
                }

                <span class="cov8" title="1">if info.IsDir() </span><span class="cov8" title="1">{
                        // Walk the directory
                        err := filepath.WalkDir(p, func(subPath string, d os.DirEntry, err error) error </span><span class="cov8" title="1">{
                                if err != nil </span><span class="cov0" title="0">{
                                        config.Logger.Printf("Warning: Error accessing path %s during walk: %v\n", subPath, err)
                                        return err // Report error up
                                }</span>

                                // Check if the directory itself should be skipped (e.g., .git, node_modules)
                                <span class="cov8" title="1">if d.IsDir() </span><span class="cov8" title="1">{
                                        if isGitIgnored(subPath, config) || slices.Contains(config.ExcludeNames, d.Name()) </span><span class="cov8" title="1">{
                                                config.Logger.Printf("Verbose: Skipping directory: %s\n", subPath)
                                                return filepath.SkipDir // Skip this whole directory
                                        }</span>
                                        <span class="cov8" title="1">return nil</span> // Continue walking into directory
                                }

                                // It's a file, process it
                                <span class="cov8" title="1">if !d.IsDir() </span><span class="cov8" title="1">{
                                        processFile(subPath, &amp;files, config)
                                }</span>

                                <span class="cov8" title="1">return nil</span> // Continue walking
                        })
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                config.Logger.Printf("Error walking directory %s: %v\n", p, err)
                                // Continue with other paths if possible
                        }</span>
                } else<span class="cov8" title="1"> {
                        // It's a single file
                        processFile(p, &amp;files, config)
                }</span>
        }

        <span class="cov8" title="1">return files, config.processedFiles, nil</span>
}

// CalculateStatistics calculates basic string stats.
func CalculateStatistics(content string) (charCount, lineCount, tokenCount int) <span class="cov8" title="1">{
        charCount = len(content)
        lineCount = strings.Count(content, "\n") + 1
        tokenCount = estimateTokenCount(content) // Fallback estimation
        return charCount, lineCount, tokenCount
}</span>

// estimateTokenCount counts tokens simply by whitespace boundaries.
// This is kept as a fallback method in case the API token counting fails.
func estimateTokenCount(text string) int <span class="cov8" title="1">{
        count := 0
        inToken := false
        for _, r := range text </span><span class="cov8" title="1">{
                if unicode.IsSpace(r) </span><span class="cov8" title="1">{
                        if inToken </span><span class="cov8" title="1">{
                                count++
                                inToken = false
                        }</span>
                } else<span class="cov8" title="1"> {
                        inToken = true
                }</span>
        }
        <span class="cov8" title="1">if inToken </span><span class="cov8" title="1">{
                count++
        }</span>
        <span class="cov8" title="1">return count</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package fileutil

import (
        "fmt"
        "strings"
        "sync"

        "github.com/phrazzld/architect/internal/logutil"
)

// MockLogger implements logutil.LoggerInterface for testing
type MockLogger struct {
        mutex       sync.Mutex
        messages    []string
        debugMsgs   []string
        infoMsgs    []string
        warnMsgs    []string
        errorMsgs   []string
        fatalMsgs   []string
        logLevel    logutil.LogLevel
        verboseMode bool
}

// NewMockLogger creates a new mock logger for testing
func NewMockLogger() *MockLogger <span class="cov8" title="1">{
        return &amp;MockLogger{
                messages:    make([]string, 0),
                debugMsgs:   make([]string, 0),
                infoMsgs:    make([]string, 0),
                warnMsgs:    make([]string, 0),
                errorMsgs:   make([]string, 0),
                fatalMsgs:   make([]string, 0),
                logLevel:    logutil.DebugLevel, // Default to debug for tests
                verboseMode: true,
        }
}</span>

// Println implements LoggerInterface.Println
func (m *MockLogger) Println(v ...interface{}) <span class="cov0" title="0">{
        msg := fmt.Sprintln(v...)
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.messages = append(m.messages, msg)
        m.infoMsgs = append(m.infoMsgs, msg)
}</span>

// Printf logs a formatted message at the default level
func (m *MockLogger) Printf(format string, args ...interface{}) <span class="cov8" title="1">{
        // Only log if we're in verbose mode and the format starts with "Verbose:"
        if m.verboseMode || !strings.HasPrefix(format, "Verbose:") </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(format, args...)
                m.mutex.Lock()
                defer m.mutex.Unlock()
                m.messages = append(m.messages, msg)
        }</span>
}

// Debug logs a formatted message at debug level
func (m *MockLogger) Debug(format string, args ...interface{}) <span class="cov0" title="0">{
        if m.logLevel &lt;= logutil.DebugLevel </span><span class="cov0" title="0">{
                msg := fmt.Sprintf(format, args...)
                m.mutex.Lock()
                defer m.mutex.Unlock()
                m.messages = append(m.messages, msg)
                m.debugMsgs = append(m.debugMsgs, msg)
        }</span>
}

// Info logs a formatted message at info level
func (m *MockLogger) Info(format string, args ...interface{}) <span class="cov0" title="0">{
        if m.logLevel &lt;= logutil.InfoLevel </span><span class="cov0" title="0">{
                msg := fmt.Sprintf(format, args...)
                m.mutex.Lock()
                defer m.mutex.Unlock()
                m.messages = append(m.messages, msg)
                m.infoMsgs = append(m.infoMsgs, msg)
        }</span>
}

// Warn logs a formatted message at warn level
func (m *MockLogger) Warn(format string, args ...interface{}) <span class="cov0" title="0">{
        if m.logLevel &lt;= logutil.WarnLevel </span><span class="cov0" title="0">{
                msg := fmt.Sprintf(format, args...)
                m.mutex.Lock()
                defer m.mutex.Unlock()
                m.messages = append(m.messages, msg)
                m.warnMsgs = append(m.warnMsgs, msg)
        }</span>
}

// Error logs a formatted message at error level
func (m *MockLogger) Error(format string, args ...interface{}) <span class="cov0" title="0">{
        if m.logLevel &lt;= logutil.ErrorLevel </span><span class="cov0" title="0">{
                msg := fmt.Sprintf(format, args...)
                m.mutex.Lock()
                defer m.mutex.Unlock()
                m.messages = append(m.messages, msg)
                m.errorMsgs = append(m.errorMsgs, msg)
        }</span>
}

// Fatal logs a formatted message at fatal level
func (m *MockLogger) Fatal(format string, args ...interface{}) <span class="cov0" title="0">{
        msg := fmt.Sprintf(format, args...)
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.messages = append(m.messages, msg)
        m.fatalMsgs = append(m.fatalMsgs, msg)
        // Note: We don't exit in tests
}</span>

// SetLevel sets the log level
func (m *MockLogger) SetLevel(level logutil.LogLevel) <span class="cov0" title="0">{
        m.logLevel = level
}</span>

// GetLevel returns the current log level
func (m *MockLogger) GetLevel() logutil.LogLevel <span class="cov0" title="0">{
        return m.logLevel
}</span>

// GetMessages returns all logged messages
func (m *MockLogger) GetMessages() []string <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        result := make([]string, len(m.messages))
        copy(result, m.messages)
        return result
}</span>

// GetDebugMessages returns debug level messages
func (m *MockLogger) GetDebugMessages() []string <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        result := make([]string, len(m.debugMsgs))
        copy(result, m.debugMsgs)
        return result
}</span>

// GetInfoMessages returns info level messages
func (m *MockLogger) GetInfoMessages() []string <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        result := make([]string, len(m.infoMsgs))
        copy(result, m.infoMsgs)
        return result
}</span>

// GetWarnMessages returns warn level messages
func (m *MockLogger) GetWarnMessages() []string <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        result := make([]string, len(m.warnMsgs))
        copy(result, m.warnMsgs)
        return result
}</span>

// GetErrorMessages returns error level messages
func (m *MockLogger) GetErrorMessages() []string <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        result := make([]string, len(m.errorMsgs))
        copy(result, m.errorMsgs)
        return result
}</span>

// GetFatalMessages returns fatal level messages
func (m *MockLogger) GetFatalMessages() []string <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        result := make([]string, len(m.fatalMsgs))
        copy(result, m.fatalMsgs)
        return result
}</span>

// ClearMessages clears all logged messages
func (m *MockLogger) ClearMessages() <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.messages = make([]string, 0)
        m.debugMsgs = make([]string, 0)
        m.infoMsgs = make([]string, 0)
        m.warnMsgs = make([]string, 0)
        m.errorMsgs = make([]string, 0)
        m.fatalMsgs = make([]string, 0)
}</span>

// ContainsMessage checks if a message was logged (substring match)
func (m *MockLogger) ContainsMessage(substr string) bool <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        for _, msg := range m.messages </span><span class="cov8" title="1">{
                if strings.Contains(msg, substr) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// SetVerbose sets the verbose mode for testing
func (m *MockLogger) SetVerbose(verbose bool) <span class="cov8" title="1">{
        m.verboseMode = verbose
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// internal/gemini/client.go
package gemini

import (
        "context"
)

// ModelConfig holds Gemini model configuration parameters
type ModelConfig struct {
        MaxOutputTokens int32
        Temperature     float32
        TopP            float32
}

// ModelInfo holds model capabilities and limits
type ModelInfo struct {
        Name             string
        InputTokenLimit  int32
        OutputTokenLimit int32
}

// SafetyRating represents a content safety evaluation
type SafetyRating struct {
        Category string
        Blocked  bool
        Score    float32
}

// GenerationResult holds the response from a generate content call
type GenerationResult struct {
        Content       string
        FinishReason  string
        SafetyRatings []SafetyRating
        TokenCount    int32
        Truncated     bool
}

// TokenCount holds the result of a token counting operation
type TokenCount struct {
        Total int32
}

// Client defines the interface for interacting with Gemini API
type Client interface {
        // GenerateContent sends a text prompt to Gemini and returns the generated content
        GenerateContent(ctx context.Context, prompt string) (*GenerationResult, error)

        // CountTokens counts the tokens in a given prompt
        CountTokens(ctx context.Context, prompt string) (*TokenCount, error)

        // GetModelInfo retrieves information about a model (for future implementation)
        GetModelInfo(ctx context.Context) (*ModelInfo, error)

        // GetModelName returns the name of the model being used
        GetModelName() string

        // GetTemperature returns the temperature setting for the model
        GetTemperature() float32

        // GetMaxOutputTokens returns the max output tokens setting for the model
        GetMaxOutputTokens() int32

        // GetTopP returns the topP setting for the model
        GetTopP() float32

        // Close releases resources used by the client
        Close() error
}

// NewClient creates a new Gemini client with the given API key, model name, and optional API endpoint
func NewClient(ctx context.Context, apiKey, modelName, apiEndpoint string) (Client, error) <span class="cov0" title="0">{
        return newGeminiClient(ctx, apiKey, modelName, apiEndpoint)
}</span>

// DefaultModelConfig returns a reasonable default model configuration
func DefaultModelConfig() ModelConfig <span class="cov8" title="1">{
        return ModelConfig{
                MaxOutputTokens: 8192, // High limit for plan generation
                Temperature:     0.3,  // Lower temperature for deterministic output
                TopP:            0.9,  // Allow some creativity
        }
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package gemini provides a client for interacting with Google's Gemini API
package gemini

import (
        "errors"
        "fmt"
        "net/http"
        "strings"
)

// ErrorType represents different categories of errors that can occur when using the Gemini API
type ErrorType int

const (
        // ErrorTypeUnknown represents an unknown or uncategorized error
        ErrorTypeUnknown ErrorType = iota

        // ErrorTypeAuth represents authentication and authorization errors
        ErrorTypeAuth

        // ErrorTypeRateLimit represents rate limiting or quota errors
        ErrorTypeRateLimit

        // ErrorTypeInvalidRequest represents invalid request errors
        ErrorTypeInvalidRequest

        // ErrorTypeNotFound represents model not found errors
        ErrorTypeNotFound

        // ErrorTypeServer represents server errors
        ErrorTypeServer

        // ErrorTypeNetwork represents network connectivity errors
        ErrorTypeNetwork

        // ErrorTypeCancelled represents cancelled context errors
        ErrorTypeCancelled

        // ErrorTypeInputLimit represents input token limit exceeded errors
        ErrorTypeInputLimit

        // ErrorTypeContentFiltered represents content filtered by safety settings errors
        ErrorTypeContentFiltered
)

// APIError represents an enhanced error with detailed information
type APIError struct {
        // Original is the original error
        Original error

        // Type is the categorized error type
        Type ErrorType

        // Message is a user-friendly error message
        Message string

        // StatusCode is the HTTP status code (if applicable)
        StatusCode int

        // Suggestion is a helpful suggestion for resolving the error
        Suggestion string

        // Details contains additional error details
        Details string
}

// Error implements the error interface
func (e *APIError) Error() string <span class="cov0" title="0">{
        if e.Original != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s: %v", e.Message, e.Original)
        }</span>
        <span class="cov0" title="0">return e.Message</span>
}

// Unwrap returns the original error
func (e *APIError) Unwrap() error <span class="cov0" title="0">{
        return e.Original
}</span>

// UserFacingError returns a user-friendly error message with suggestions
func (e *APIError) UserFacingError() string <span class="cov0" title="0">{
        var sb strings.Builder

        // Start with the error message
        sb.WriteString(e.Message)

        // Add suggestions if available
        if e.Suggestion != "" </span><span class="cov0" title="0">{
                sb.WriteString("\n\nSuggestion: ")
                sb.WriteString(e.Suggestion)
        }</span>

        <span class="cov0" title="0">return sb.String()</span>
}

// DebugInfo returns detailed debugging information about the error
func (e *APIError) DebugInfo() string <span class="cov0" title="0">{
        var sb strings.Builder

        sb.WriteString(fmt.Sprintf("Error Type: %v\n", e.Type))
        sb.WriteString(fmt.Sprintf("Message: %s\n", e.Message))

        if e.StatusCode != 0 </span><span class="cov0" title="0">{
                sb.WriteString(fmt.Sprintf("Status Code: %d\n", e.StatusCode))
        }</span>

        <span class="cov0" title="0">if e.Original != nil </span><span class="cov0" title="0">{
                sb.WriteString(fmt.Sprintf("Original Error: %v\n", e.Original))
        }</span>

        <span class="cov0" title="0">if e.Details != "" </span><span class="cov0" title="0">{
                sb.WriteString(fmt.Sprintf("Details: %s\n", e.Details))
        }</span>

        <span class="cov0" title="0">if e.Suggestion != "" </span><span class="cov0" title="0">{
                sb.WriteString(fmt.Sprintf("Suggestion: %s\n", e.Suggestion))
        }</span>

        <span class="cov0" title="0">return sb.String()</span>
}

// IsAPIError checks if an error is an APIError and returns it
func IsAPIError(err error) (*APIError, bool) <span class="cov0" title="0">{
        var apiErr *APIError
        if errors.As(err, &amp;apiErr) </span><span class="cov0" title="0">{
                return apiErr, true
        }</span>
        <span class="cov0" title="0">return nil, false</span>
}

// GetErrorType determines the error type based on the error message and status code
func GetErrorType(err error, statusCode int) ErrorType <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return ErrorTypeUnknown
        }</span>

        <span class="cov0" title="0">errMsg := err.Error()

        // Check for authorization errors
        if statusCode == http.StatusUnauthorized || statusCode == http.StatusForbidden </span><span class="cov0" title="0">{
                return ErrorTypeAuth
        }</span>

        // Check for rate limit or quota errors
        <span class="cov0" title="0">if statusCode == http.StatusTooManyRequests ||
                strings.Contains(errMsg, "rate limit") ||
                strings.Contains(errMsg, "quota") </span><span class="cov0" title="0">{
                return ErrorTypeRateLimit
        }</span>

        // Check for invalid request errors
        <span class="cov0" title="0">if statusCode == http.StatusBadRequest </span><span class="cov0" title="0">{
                return ErrorTypeInvalidRequest
        }</span>

        // Check for not found errors
        <span class="cov0" title="0">if statusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                return ErrorTypeNotFound
        }</span>

        // Check for server errors
        <span class="cov0" title="0">if statusCode &gt;= 500 &amp;&amp; statusCode &lt; 600 </span><span class="cov0" title="0">{
                return ErrorTypeServer
        }</span>

        // Check for content filtering
        <span class="cov0" title="0">if strings.Contains(errMsg, "safety") ||
                strings.Contains(errMsg, "blocked") ||
                strings.Contains(errMsg, "filtered") </span><span class="cov0" title="0">{
                return ErrorTypeContentFiltered
        }</span>

        // Check for token limit errors
        <span class="cov0" title="0">if strings.Contains(errMsg, "token limit") ||
                strings.Contains(errMsg, "tokens exceeds") </span><span class="cov0" title="0">{
                return ErrorTypeInputLimit
        }</span>

        // Check for network errors
        <span class="cov0" title="0">if strings.Contains(errMsg, "network") ||
                strings.Contains(errMsg, "connection") ||
                strings.Contains(errMsg, "timeout") </span><span class="cov0" title="0">{
                return ErrorTypeNetwork
        }</span>

        // Check for cancellation
        <span class="cov0" title="0">if strings.Contains(errMsg, "canceled") ||
                strings.Contains(errMsg, "cancelled") ||
                strings.Contains(errMsg, "deadline exceeded") </span><span class="cov0" title="0">{
                return ErrorTypeCancelled
        }</span>

        <span class="cov0" title="0">return ErrorTypeUnknown</span>
}

// FormatAPIError creates a detailed API error from a standard error
func FormatAPIError(err error, statusCode int) *APIError <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Check if it's already an APIError
        <span class="cov0" title="0">if apiErr, ok := IsAPIError(err); ok </span><span class="cov0" title="0">{
                return apiErr
        }</span>

        // Determine error type
        <span class="cov0" title="0">errType := GetErrorType(err, statusCode)

        // Create base API error
        apiErr := &amp;APIError{
                Original:   err,
                Type:       errType,
                Message:    err.Error(),
                StatusCode: statusCode,
        }

        // Enhance error details based on type
        switch errType </span>{
        case ErrorTypeAuth:<span class="cov0" title="0">
                apiErr.Message = "Authentication failed with the Gemini API"
                apiErr.Suggestion = "Check that your API key is valid and has not expired. Ensure environment variables are set correctly."</span>

        case ErrorTypeRateLimit:<span class="cov0" title="0">
                apiErr.Message = "Request rate limit or quota exceeded on the Gemini API"
                apiErr.Suggestion = "Wait and try again later. Consider adjusting the --max-concurrent and --rate-limit flags to limit request rate. You can also upgrade your API usage tier if this happens frequently."</span>

        case ErrorTypeInvalidRequest:<span class="cov0" title="0">
                apiErr.Message = "Invalid request sent to the Gemini API"
                apiErr.Suggestion = "Check the prompt format and parameters. Ensure they comply with the API requirements."</span>

        case ErrorTypeNotFound:<span class="cov0" title="0">
                apiErr.Message = "The requested model or resource was not found"
                apiErr.Suggestion = "Verify that the model name is correct and that the model is available in your region."</span>

        case ErrorTypeServer:<span class="cov0" title="0">
                apiErr.Message = "Gemini API server error occurred"
                apiErr.Suggestion = "This is typically a temporary issue. Wait a few moments and try again."</span>

        case ErrorTypeNetwork:<span class="cov0" title="0">
                apiErr.Message = "Network error while connecting to the Gemini API"
                apiErr.Suggestion = "Check your internet connection and try again. If persistent, there may be connectivity issues to Google's servers."</span>

        case ErrorTypeCancelled:<span class="cov0" title="0">
                apiErr.Message = "Request to Gemini API was cancelled"
                apiErr.Suggestion = "The operation was interrupted. Try again with a longer timeout if needed."</span>

        case ErrorTypeInputLimit:<span class="cov0" title="0">
                apiErr.Message = "Input token limit exceeded for the Gemini model"
                apiErr.Suggestion = "Reduce the input size by using --include, --exclude, or --exclude-names flags to filter the context."</span>

        case ErrorTypeContentFiltered:<span class="cov0" title="0">
                apiErr.Message = "Content was filtered by Gemini API safety settings"
                apiErr.Suggestion = "Your prompt or content may have triggered safety filters. Review and modify your input to comply with content policies."</span>

        default:<span class="cov0" title="0">
                apiErr.Message = fmt.Sprintf("Error calling Gemini API: %v", err)
                apiErr.Suggestion = "Check the logs for more details or try again."</span>
        }

        <span class="cov0" title="0">return apiErr</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// internal/gemini/gemini_client.go
package gemini

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "strings"
        "sync"
        "time"

        "github.com/phrazzld/architect/internal/logutil"

        genai "github.com/google/generative-ai-go/genai"
        "google.golang.org/api/option"
)

// geminiClient implements the Client interface using Google's genai SDK
type geminiClient struct {
        client      *genai.Client
        model       *genai.GenerativeModel
        modelName   string
        apiKey      string
        apiEndpoint string
        logger      logutil.LoggerInterface

        // Model info caching
        modelInfoCache map[string]*ModelInfo
        modelInfoMutex sync.RWMutex
        httpClient     *http.Client
}

// newGeminiClient creates a new Gemini client with Google's genai SDK
func newGeminiClient(ctx context.Context, apiKey, modelName, apiEndpoint string) (Client, error) <span class="cov0" title="0">{
        if apiKey == "" </span><span class="cov0" title="0">{
                return nil, errors.New("API key cannot be empty")
        }</span>

        <span class="cov0" title="0">if modelName == "" </span><span class="cov0" title="0">{
                return nil, errors.New("model name cannot be empty")
        }</span>

        // Create standard logger for internal client use
        <span class="cov0" title="0">logger := logutil.NewLogger(logutil.InfoLevel, nil, "[gemini] ")

        // Prepare client options
        var opts []option.ClientOption

        if apiEndpoint != "" </span><span class="cov0" title="0">{
                // Custom endpoint (likely for testing)
                logger.Debug("Using custom Gemini API endpoint: %s", apiEndpoint)
                opts = append(opts,
                        option.WithEndpoint(apiEndpoint),
                        option.WithoutAuthentication()) // Skip auth for mock server
        }</span> else<span class="cov0" title="0"> {
                // Default endpoint with API key
                opts = append(opts, option.WithAPIKey(apiKey))
        }</span>

        // Initialize the Google genai client
        <span class="cov0" title="0">client, err := genai.NewClient(ctx, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Gemini client: %w", err)
        }</span>

        // Initialize the model with default settings
        <span class="cov0" title="0">model := client.GenerativeModel(modelName)
        config := DefaultModelConfig()
        model.SetMaxOutputTokens(config.MaxOutputTokens)
        model.SetTemperature(config.Temperature)
        model.SetTopP(config.TopP)

        return &amp;geminiClient{
                client:         client,
                model:          model,
                modelName:      modelName,
                apiKey:         apiKey,
                apiEndpoint:    apiEndpoint,
                logger:         logger,
                modelInfoCache: make(map[string]*ModelInfo),
                modelInfoMutex: sync.RWMutex{},
                httpClient:     &amp;http.Client{Timeout: 10 * time.Second},
        }, nil</span>
}

// GenerateContent sends a text prompt to Gemini and returns the generated content
func (c *geminiClient) GenerateContent(ctx context.Context, prompt string) (*GenerationResult, error) <span class="cov0" title="0">{
        if prompt == "" </span><span class="cov0" title="0">{
                return nil, &amp;APIError{
                        Original:   errors.New("prompt cannot be empty"),
                        Type:       ErrorTypeInvalidRequest,
                        Message:    "Cannot generate content with an empty prompt",
                        Suggestion: "Provide a task description using the --task flag or --task-file option",
                }
        }</span>

        // Generate content
        <span class="cov0" title="0">resp, err := c.model.GenerateContent(ctx, genai.Text(prompt))
        if err != nil </span><span class="cov0" title="0">{
                apiErr := FormatAPIError(err, 0)
                // Log detailed info for debugging
                c.logger.Debug("Gemini API Error: %s", apiErr.DebugInfo())
                return nil, apiErr
        }</span>

        // Check for empty response
        <span class="cov0" title="0">if resp == nil </span><span class="cov0" title="0">{
                return nil, &amp;APIError{
                        Original:   errors.New("received nil response from Gemini API"),
                        Type:       ErrorTypeUnknown,
                        Message:    "Received an empty response from the Gemini API",
                        Suggestion: "This is likely a temporary issue. Please try again in a few moments.",
                }
        }</span>

        // Check for empty candidates
        <span class="cov0" title="0">if len(resp.Candidates) == 0 </span><span class="cov0" title="0">{
                return nil, &amp;APIError{
                        Original:   errors.New("received empty candidates from Gemini API"),
                        Type:       ErrorTypeUnknown,
                        Message:    "The Gemini API returned no generation candidates",
                        Suggestion: "This could be due to content filtering. Try modifying your prompt or task description.",
                }
        }</span>

        <span class="cov0" title="0">candidate := resp.Candidates[0]

        // Check for empty content
        if candidate.Content == nil || len(candidate.Content.Parts) == 0 </span><span class="cov0" title="0">{
                return &amp;GenerationResult{
                        Content:       "",
                        FinishReason:  string(candidate.FinishReason),
                        SafetyRatings: mapSafetyRatings(candidate.SafetyRatings),
                        Truncated:     candidate.FinishReason == genai.FinishReasonMaxTokens,
                }, nil
        }</span>

        // Extract text content
        <span class="cov0" title="0">var contentBuilder strings.Builder
        for _, part := range candidate.Content.Parts </span><span class="cov0" title="0">{
                if textPart, ok := part.(genai.Text); ok </span><span class="cov0" title="0">{
                        contentBuilder.WriteString(string(textPart))
                }</span>
        }

        // Get token usage if available
        <span class="cov0" title="0">var tokenCount int32
        if resp.UsageMetadata != nil </span><span class="cov0" title="0">{
                tokenCount = resp.UsageMetadata.TotalTokenCount
        }</span>

        // Build result
        <span class="cov0" title="0">result := &amp;GenerationResult{
                Content:       contentBuilder.String(),
                FinishReason:  string(candidate.FinishReason),
                SafetyRatings: mapSafetyRatings(candidate.SafetyRatings),
                TokenCount:    tokenCount,
                Truncated:     candidate.FinishReason == genai.FinishReasonMaxTokens,
        }

        return result, nil</span>
}

// CountTokens counts the tokens in a given prompt
func (c *geminiClient) CountTokens(ctx context.Context, prompt string) (*TokenCount, error) <span class="cov0" title="0">{
        if prompt == "" </span><span class="cov0" title="0">{
                return &amp;TokenCount{Total: 0}, nil
        }</span>

        <span class="cov0" title="0">resp, err := c.model.CountTokens(ctx, genai.Text(prompt))
        if err != nil </span><span class="cov0" title="0">{
                apiErr := FormatAPIError(err, 0)
                apiErr.Message = "Failed to count tokens in prompt"
                apiErr.Suggestion = "Check your API key and internet connection. This operation is required before sending content to the API."

                // Log detailed info for debugging
                c.logger.Debug("Token counting error: %s", apiErr.DebugInfo())

                return nil, apiErr
        }</span>

        <span class="cov0" title="0">return &amp;TokenCount{
                Total: resp.TotalTokens,
        }, nil</span>
}

// ModelDetailsResponse represents the API response for model details
type ModelDetailsResponse struct {
        Name                       string   `json:"name"`
        BaseModelID                string   `json:"baseModelId"`
        Version                    string   `json:"version"`
        DisplayName                string   `json:"displayName"`
        Description                string   `json:"description"`
        InputTokenLimit            int32    `json:"inputTokenLimit"`
        OutputTokenLimit           int32    `json:"outputTokenLimit"`
        SupportedGenerationMethods []string `json:"supportedGenerationMethods"`
        Temperature                float32  `json:"temperature"`
        TopP                       float32  `json:"topP"`
        TopK                       int32    `json:"topK"`
}

// GetModelInfo retrieves information about the current model
func (c *geminiClient) GetModelInfo(ctx context.Context) (*ModelInfo, error) <span class="cov0" title="0">{
        // Check cache first
        c.modelInfoMutex.RLock()
        if info, ok := c.modelInfoCache[c.modelName]; ok </span><span class="cov0" title="0">{
                c.modelInfoMutex.RUnlock()
                return info, nil
        }</span>
        <span class="cov0" title="0">c.modelInfoMutex.RUnlock()

        // Not in cache, fetch from API
        info, err := c.fetchModelInfo(ctx, c.modelName)
        if err != nil </span><span class="cov0" title="0">{
                // If API fetch fails, use conservative defaults
                c.logger.Warn("Failed to fetch model info for %s: %v. Using default values.", c.modelName, err)

                info = &amp;ModelInfo{
                        Name:             c.modelName,
                        InputTokenLimit:  30720, // Conservative default
                        OutputTokenLimit: 8192,  // Conservative default
                }
        }</span>

        // Cache the result (even default values to avoid repeated failures)
        <span class="cov0" title="0">c.modelInfoMutex.Lock()
        c.modelInfoCache[c.modelName] = info
        c.modelInfoMutex.Unlock()

        return info, nil</span>
}

// fetchModelInfo calls the Generative Language API to get model details
func (c *geminiClient) fetchModelInfo(ctx context.Context, modelName string) (*ModelInfo, error) <span class="cov0" title="0">{
        var url string

        if c.apiEndpoint != "" </span><span class="cov0" title="0">{
                // Use custom endpoint with no authentication
                url = fmt.Sprintf("%s/v1beta/models/%s",
                        strings.TrimSuffix(c.apiEndpoint, "/"), modelName)
        }</span> else<span class="cov0" title="0"> {
                // Use default endpoint with API key
                url = fmt.Sprintf("https://generativelanguage.googleapis.com/v1beta/models/%s?key=%s",
                        modelName, c.apiKey)
        }</span>

        // Create request
        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                apiErr := &amp;APIError{
                        Original:   err,
                        Type:       ErrorTypeNetwork,
                        Message:    "Failed to create HTTP request for model information",
                        Suggestion: "This is likely a temporary issue with network connectivity. Check your internet connection and try again.",
                }
                return nil, apiErr
        }</span>

        // Make the request
        <span class="cov0" title="0">resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                apiErr := &amp;APIError{
                        Original:   err,
                        Type:       ErrorTypeNetwork,
                        Message:    "Failed to connect to Gemini API to fetch model information",
                        Suggestion: "Check your internet connection and try again. If the issue persists, the API might be experiencing downtime.",
                        Details:    err.Error(),
                }
                return nil, apiErr
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Check status code
        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                bodyStr := string(body)

                apiErr := FormatAPIError(
                        fmt.Errorf("API returned error: %s", bodyStr),
                        resp.StatusCode,
                )

                // Add model-specific details
                apiErr.Details = fmt.Sprintf("Model: %s, Status: %d, Response: %s",
                        modelName, resp.StatusCode, bodyStr)

                // For 404 errors, provide more context about the model
                if resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                        apiErr.Message = fmt.Sprintf("Model '%s' not found or not accessible", modelName)
                        apiErr.Suggestion = "Check that the model name is correct and that you have access to it. Consider using a different model."
                }</span>

                // Log detailed error for debugging
                <span class="cov0" title="0">c.logger.Debug("Model info error: %s", apiErr.DebugInfo())

                return nil, apiErr</span>
        }

        // Parse response
        <span class="cov0" title="0">var modelDetails ModelDetailsResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;modelDetails); err != nil </span><span class="cov0" title="0">{
                apiErr := &amp;APIError{
                        Original:   err,
                        Type:       ErrorTypeInvalidRequest,
                        Message:    "Failed to parse model information response from Gemini API",
                        Suggestion: "This is likely a temporary API issue or a change in the API response format. Try again later.",
                        Details:    err.Error(),
                }
                return nil, apiErr
        }</span>

        // Convert to our internal model
        <span class="cov0" title="0">info := &amp;ModelInfo{
                Name:             modelDetails.Name,
                InputTokenLimit:  modelDetails.InputTokenLimit,
                OutputTokenLimit: modelDetails.OutputTokenLimit,
        }

        c.logger.Debug("Fetched model info for %s: input limit=%d, output limit=%d",
                modelName, info.InputTokenLimit, info.OutputTokenLimit)

        return info, nil</span>
}

// Close releases resources used by the client
func (c *geminiClient) Close() error <span class="cov0" title="0">{
        if c.client != nil </span><span class="cov0" title="0">{
                return c.client.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetModelName returns the name of the model being used
func (c *geminiClient) GetModelName() string <span class="cov0" title="0">{
        return c.modelName
}</span>

// GetTemperature returns the temperature setting for the model
func (c *geminiClient) GetTemperature() float32 <span class="cov0" title="0">{
        if c.model != nil &amp;&amp; c.model.Temperature != nil </span><span class="cov0" title="0">{
                return *c.model.Temperature
        }</span>
        <span class="cov0" title="0">return DefaultModelConfig().Temperature</span>
}

// GetMaxOutputTokens returns the max output tokens setting for the model
func (c *geminiClient) GetMaxOutputTokens() int32 <span class="cov0" title="0">{
        if c.model != nil &amp;&amp; c.model.MaxOutputTokens != nil </span><span class="cov0" title="0">{
                return int32(*c.model.MaxOutputTokens)
        }</span>
        <span class="cov0" title="0">return DefaultModelConfig().MaxOutputTokens</span>
}

// GetTopP returns the topP setting for the model
func (c *geminiClient) GetTopP() float32 <span class="cov0" title="0">{
        if c.model != nil &amp;&amp; c.model.TopP != nil </span><span class="cov0" title="0">{
                return *c.model.TopP
        }</span>
        <span class="cov0" title="0">return DefaultModelConfig().TopP</span>
}

// mapSafetyRatings converts genai safety ratings to our internal format
func mapSafetyRatings(ratings []*genai.SafetyRating) []SafetyRating <span class="cov0" title="0">{
        if ratings == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := make([]SafetyRating, len(ratings))
        for i, rating := range ratings </span><span class="cov0" title="0">{
                result[i] = SafetyRating{
                        Category: string(rating.Category),
                        Blocked:  rating.Blocked,
                        Score:    float32(rating.Probability),
                }
        }</span>

        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// internal/gemini/mock_client.go
package gemini

import (
        "context"
)

// MockClient implements Client interface for testing
type MockClient struct {
        GenerateContentFunc    func(ctx context.Context, prompt string) (*GenerationResult, error)
        CountTokensFunc        func(ctx context.Context, prompt string) (*TokenCount, error)
        GetModelInfoFunc       func(ctx context.Context) (*ModelInfo, error)
        GetModelNameFunc       func() string
        GetTemperatureFunc     func() float32
        GetMaxOutputTokensFunc func() int32
        GetTopPFunc            func() float32
        CloseFunc              func() error
}

// GenerateContent calls the mocked implementation
func (m *MockClient) GenerateContent(ctx context.Context, prompt string) (*GenerationResult, error) <span class="cov0" title="0">{
        if m.GenerateContentFunc != nil </span><span class="cov0" title="0">{
                return m.GenerateContentFunc(ctx, prompt)
        }</span>
        <span class="cov0" title="0">return &amp;GenerationResult{Content: "Mock response"}, nil</span>
}

// CountTokens calls the mocked implementation
func (m *MockClient) CountTokens(ctx context.Context, prompt string) (*TokenCount, error) <span class="cov0" title="0">{
        if m.CountTokensFunc != nil </span><span class="cov0" title="0">{
                return m.CountTokensFunc(ctx, prompt)
        }</span>
        <span class="cov0" title="0">return &amp;TokenCount{Total: 10}, nil</span> // Simple default
}

// GetModelInfo calls the mocked implementation
func (m *MockClient) GetModelInfo(ctx context.Context) (*ModelInfo, error) <span class="cov8" title="1">{
        if m.GetModelInfoFunc != nil </span><span class="cov8" title="1">{
                return m.GetModelInfoFunc(ctx)
        }</span>
        <span class="cov0" title="0">return &amp;ModelInfo{
                Name:             "mock-model",
                InputTokenLimit:  32000,
                OutputTokenLimit: 8192,
        }, nil</span>
}

// Close calls the mocked implementation
func (m *MockClient) Close() error <span class="cov0" title="0">{
        if m.CloseFunc != nil </span><span class="cov0" title="0">{
                return m.CloseFunc()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetModelName returns the mocked model name
func (m *MockClient) GetModelName() string <span class="cov0" title="0">{
        if m.GetModelNameFunc != nil </span><span class="cov0" title="0">{
                return m.GetModelNameFunc()
        }</span>
        <span class="cov0" title="0">return "mock-model"</span>
}

// GetTemperature returns the mocked temperature
func (m *MockClient) GetTemperature() float32 <span class="cov0" title="0">{
        if m.GetTemperatureFunc != nil </span><span class="cov0" title="0">{
                return m.GetTemperatureFunc()
        }</span>
        <span class="cov0" title="0">return DefaultModelConfig().Temperature</span>
}

// GetMaxOutputTokens returns the mocked max output tokens
func (m *MockClient) GetMaxOutputTokens() int32 <span class="cov0" title="0">{
        if m.GetMaxOutputTokensFunc != nil </span><span class="cov0" title="0">{
                return m.GetMaxOutputTokensFunc()
        }</span>
        <span class="cov0" title="0">return DefaultModelConfig().MaxOutputTokens</span>
}

// GetTopP returns the mocked topP
func (m *MockClient) GetTopP() float32 <span class="cov0" title="0">{
        if m.GetTopPFunc != nil </span><span class="cov0" title="0">{
                return m.GetTopPFunc()
        }</span>
        <span class="cov0" title="0">return DefaultModelConfig().TopP</span>
}

// NewMockClient creates a new mock client for testing
func NewMockClient() *MockClient <span class="cov8" title="1">{
        return &amp;MockClient{
                GetModelInfoFunc: func(ctx context.Context) (*ModelInfo, error) </span><span class="cov8" title="1">{
                        return &amp;ModelInfo{
                                Name:             "mock-model",
                                InputTokenLimit:  32000,
                                OutputTokenLimit: 8192,
                        }, nil
                }</span>,
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// internal/logutil/logutil.go
package logutil

import (
        "fmt"
        "io"
        "log"
        "os"
        "sync"
        "time"
)

// LoggerInterface defines the common logging interface
// This allows both our structured Logger and the standard log.Logger
// to be used interchangeably
type LoggerInterface interface {
        Println(v ...interface{})
        Printf(format string, v ...interface{})
        Debug(format string, v ...interface{})
        Info(format string, v ...interface{})
        Warn(format string, v ...interface{})
        Error(format string, v ...interface{})
        Fatal(format string, v ...interface{})
}

// StdLoggerAdapter provides a compatibility layer for standard log.Logger
type StdLoggerAdapter struct {
        *log.Logger
}

// NewStdLoggerAdapter wraps a standard logger
func NewStdLoggerAdapter(logger *log.Logger) *StdLoggerAdapter <span class="cov0" title="0">{
        return &amp;StdLoggerAdapter{Logger: logger}
}</span>

// Debug implements LoggerInterface.Debug
func (s *StdLoggerAdapter) Debug(format string, v ...interface{}) <span class="cov0" title="0">{
        s.Logger.Printf("[DEBUG] "+format, v...)
}</span>

// Info implements LoggerInterface.Info
func (s *StdLoggerAdapter) Info(format string, v ...interface{}) <span class="cov0" title="0">{
        s.Logger.Printf("[INFO] "+format, v...)
}</span>

// Warn implements LoggerInterface.Warn
func (s *StdLoggerAdapter) Warn(format string, v ...interface{}) <span class="cov0" title="0">{
        s.Logger.Printf("[WARN] "+format, v...)
}</span>

// Error implements LoggerInterface.Error
func (s *StdLoggerAdapter) Error(format string, v ...interface{}) <span class="cov0" title="0">{
        s.Logger.Printf("[ERROR] "+format, v...)
}</span>

// Fatal implements LoggerInterface.Fatal
func (s *StdLoggerAdapter) Fatal(format string, v ...interface{}) <span class="cov0" title="0">{
        s.Logger.Fatalf("[FATAL] "+format, v...)
}</span>

// LogLevel represents different logging severity levels
type LogLevel int

const (
        // Log levels in increasing order of severity
        DebugLevel LogLevel = iota
        InfoLevel
        WarnLevel
        ErrorLevel
)

// String returns the string representation of a log level
func (l LogLevel) String() string <span class="cov8" title="1">{
        switch l </span>{
        case DebugLevel:<span class="cov8" title="1">
                return "DEBUG"</span>
        case InfoLevel:<span class="cov8" title="1">
                return "INFO"</span>
        case WarnLevel:<span class="cov8" title="1">
                return "WARN"</span>
        case ErrorLevel:<span class="cov8" title="1">
                return "ERROR"</span>
        default:<span class="cov8" title="1">
                return "UNKNOWN"</span>
        }
}

// Logger provides structured logging with levels
type Logger struct {
        mu     sync.Mutex // Mutex to protect concurrent access
        level  LogLevel   // Current log level
        writer io.Writer  // Where to write logs (typically os.Stderr)
        prefix string     // Prefix for all log messages
}

// Ensure Logger implements LoggerInterface
var _ LoggerInterface = (*Logger)(nil)

// NewLogger creates a new logger with the specified configuration
func NewLogger(level LogLevel, writer io.Writer, prefix string) *Logger <span class="cov8" title="1">{
        if writer == nil </span><span class="cov0" title="0">{
                writer = os.Stderr
        }</span>

        <span class="cov8" title="1">logger := &amp;Logger{
                level:  level,
                writer: writer,
                prefix: prefix,
        }

        return logger</span>
}

// formatMessage creates a formatted log message with timestamp and level
func (l *Logger) formatMessage(level LogLevel, format string, args ...interface{}) string <span class="cov8" title="1">{
        timestamp := time.Now().Format("2006-01-02 15:04:05.000")
        msg := fmt.Sprintf(format, args...)
        return fmt.Sprintf("%s [%s] %s%s", timestamp, level.String(), l.prefix, msg)
}</span>

// log logs a message at the specified level if it meets the threshold
func (l *Logger) log(level LogLevel, format string, args ...interface{}) <span class="cov8" title="1">{
        l.mu.Lock()
        defer l.mu.Unlock()

        if level &lt; l.level </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">formattedMsg := l.formatMessage(level, format, args...)
        fmt.Fprintln(l.writer, formattedMsg)</span>
}

// Debug logs a message at DEBUG level
func (l *Logger) Debug(format string, args ...interface{}) <span class="cov8" title="1">{
        l.log(DebugLevel, format, args...)
}</span>

// Info logs a message at INFO level
func (l *Logger) Info(format string, args ...interface{}) <span class="cov8" title="1">{
        l.log(InfoLevel, format, args...)
}</span>

// Warn logs a message at WARN level
func (l *Logger) Warn(format string, args ...interface{}) <span class="cov0" title="0">{
        l.log(WarnLevel, format, args...)
}</span>

// Error logs a message at ERROR level
func (l *Logger) Error(format string, args ...interface{}) <span class="cov0" title="0">{
        l.log(ErrorLevel, format, args...)
}</span>

// Fatal logs a message at ERROR level and then exits the program
func (l *Logger) Fatal(format string, args ...interface{}) <span class="cov0" title="0">{
        l.log(ErrorLevel, format, args...)
        os.Exit(1)
}</span>

// SetLevel changes the current log level
func (l *Logger) SetLevel(level LogLevel) <span class="cov8" title="1">{
        l.mu.Lock()
        defer l.mu.Unlock()
        l.level = level
}</span>

// SetPrefix changes the prefix used in log messages
func (l *Logger) SetPrefix(prefix string) <span class="cov8" title="1">{
        l.mu.Lock()
        defer l.mu.Unlock()
        l.prefix = prefix
}</span>

// Println implements LoggerInterface by logging at info level
func (l *Logger) Println(v ...interface{}) <span class="cov0" title="0">{
        l.Info(fmt.Sprintln(v...))
}</span>

// Printf implements LoggerInterface by logging at info level
func (l *Logger) Printf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.Info(format, v...)
}</span>

// ParseLogLevel converts a string to a LogLevel
func ParseLogLevel(level string) (LogLevel, error) <span class="cov8" title="1">{
        switch level </span>{
        case "debug":<span class="cov8" title="1">
                return DebugLevel, nil</span>
        case "info":<span class="cov8" title="1">
                return InfoLevel, nil</span>
        case "warn":<span class="cov8" title="1">
                return WarnLevel, nil</span>
        case "error":<span class="cov8" title="1">
                return ErrorLevel, nil</span>
        default:<span class="cov8" title="1">
                return InfoLevel, fmt.Errorf("unknown log level: %s", level)</span>
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Package ratelimit provides concurrency control and rate limiting functionality
package ratelimit

import (
        "context"
        "errors"
        "sync"

        "golang.org/x/time/rate"
)

var (
        // ErrContextCanceled is returned when the context is canceled during acquisition
        ErrContextCanceled = errors.New("context canceled while waiting for resource")
)

// Semaphore provides a simple mechanism for limiting concurrent operations
type Semaphore struct {
        tickets chan struct{}
}

// NewSemaphore creates a new semaphore with the given capacity
// If maxConcurrent is &lt;= 0, returns nil (no limiting)
func NewSemaphore(maxConcurrent int) *Semaphore <span class="cov8" title="1">{
        if maxConcurrent &lt;= 0 </span><span class="cov8" title="1">{
                return nil // No limit
        }</span>
        <span class="cov8" title="1">return &amp;Semaphore{
                tickets: make(chan struct{}, maxConcurrent),
        }</span>
}

// Acquire gets a ticket from the semaphore, blocking if none are available
// Returns nil if successful, or error if the context is canceled
// Does nothing if semaphore is nil (no limiting)
func (s *Semaphore) Acquire(ctx context.Context) error <span class="cov8" title="1">{
        if s == nil </span><span class="cov8" title="1">{
                return nil // No limiting
        }</span>

        <span class="cov8" title="1">select </span>{
        case s.tickets &lt;- struct{}{}:<span class="cov8" title="1">
                return nil</span>
        case &lt;-ctx.Done():<span class="cov8" title="1">
                return ErrContextCanceled</span>
        }
}

// Release returns a ticket to the semaphore
// Does nothing if semaphore is nil (no limiting)
func (s *Semaphore) Release() <span class="cov8" title="1">{
        if s == nil </span><span class="cov8" title="1">{
                return // No limiting
        }</span>
        <span class="cov8" title="1">select </span>{
        case &lt;-s.tickets:<span class="cov8" title="1"></span>
                // Successfully released a ticket
        default:<span class="cov0" title="0"></span>
                // This should never happen in correct usage
                // but prevents deadlock if Release is called without Acquire
        }
}

// TokenBucket manages rate limiting using a token bucket algorithm
type TokenBucket struct {
        // Map of model names to limiters
        limiters   map[string]*rate.Limiter
        mutex      sync.RWMutex
        ratePerMin int
        limit      rate.Limit
        burst      int
}

// NewTokenBucket creates a new token bucket rate limiter
// If ratePerMin is &lt;= 0, returns nil (no limiting)
func NewTokenBucket(ratePerMin, maxBurst int) *TokenBucket <span class="cov8" title="1">{
        if ratePerMin &lt;= 0 </span><span class="cov8" title="1">{
                return nil // No limit
        }</span>

        // Convert from per-minute to per-second (which is what rate.Limit uses)
        <span class="cov8" title="1">rps := rate.Limit(float64(ratePerMin) / 60.0)

        // Set burst size, defaulting to 1/10 of rate (min 1, max 10)
        if maxBurst &lt;= 0 </span><span class="cov0" title="0">{
                maxBurst = min(max(1, ratePerMin/10), 10)
        }</span>

        <span class="cov8" title="1">return &amp;TokenBucket{
                limiters:   make(map[string]*rate.Limiter),
                ratePerMin: ratePerMin,
                limit:      rps,
                burst:      maxBurst,
        }</span>
}

// getLimiter returns the rate limiter for a specific model, creating it if needed
func (tb *TokenBucket) getLimiter(modelName string) *rate.Limiter <span class="cov8" title="1">{
        // For no limit case
        if tb == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Check if we already have a limiter for this model
        <span class="cov8" title="1">tb.mutex.RLock()
        limiter, exists := tb.limiters[modelName]
        tb.mutex.RUnlock()

        if exists </span><span class="cov8" title="1">{
                return limiter
        }</span>

        // Create a new limiter for this model
        <span class="cov8" title="1">tb.mutex.Lock()
        defer tb.mutex.Unlock()

        // Double-check in case another goroutine created it
        if limiter, exists = tb.limiters[modelName]; exists </span><span class="cov0" title="0">{
                return limiter
        }</span>

        <span class="cov8" title="1">limiter = rate.NewLimiter(tb.limit, tb.burst)
        tb.limiters[modelName] = limiter
        return limiter</span>
}

// Acquire waits to acquire a token, returns error if context canceled
func (tb *TokenBucket) Acquire(ctx context.Context, modelName string) error <span class="cov8" title="1">{
        if tb == nil </span><span class="cov8" title="1">{
                return nil // No limiting
        }</span>

        <span class="cov8" title="1">limiter := tb.getLimiter(modelName)
        if limiter.Allow() </span><span class="cov8" title="1">{
                // Fast path - if we can get a token without waiting
                return nil
        }</span>

        // Slow path - wait for a token to become available
        <span class="cov8" title="1">return limiter.Wait(ctx)</span>
}

// RateLimiter combines semaphore and token bucket limiters
// BUGFIX: Remove unnecessary mutex causing deadlocks in concurrent Acquire/Release calls.
// CAUSE: Holding rl.mu across blocking calls (semaphore.Acquire, tokenBucket.Acquire)
//
//        prevented Release calls (which also needed rl.mu) from freeing resources,
//        leading to deadlock when resources were contended.
//
// FIX: Removed rl.mu entirely. Acquire semaphore then token bucket sequentially.
//
//        Release semaphore immediately if token bucket acquisition fails.
//        The underlying Semaphore and TokenBucket handle their own concurrency.
type RateLimiter struct {
        semaphore   *Semaphore
        tokenBucket *TokenBucket
}

// NewRateLimiter creates a new combined rate limiter
// By default, uses a burst size of 1 for the token bucket to make rate limiting more strict
func NewRateLimiter(maxConcurrent, ratePerMin int) *RateLimiter <span class="cov8" title="1">{
        return &amp;RateLimiter{
                semaphore:   NewSemaphore(maxConcurrent),
                tokenBucket: NewTokenBucket(ratePerMin, 1), // Use explicit burst size of 1 for stricter rate limiting
        }
}</span>

// Acquire waits to acquire both semaphore and rate limit permissions
func (rl *RateLimiter) Acquire(ctx context.Context, modelName string) error <span class="cov8" title="1">{
        // First try to acquire the semaphore
        if err := rl.semaphore.Acquire(ctx); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // If we got the semaphore but fail to get the rate limit, release the semaphore
        <span class="cov8" title="1">if err := rl.tokenBucket.Acquire(ctx, modelName); err != nil </span><span class="cov8" title="1">{
                rl.semaphore.Release()
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Release releases the semaphore (token bucket doesn't need explicit release)
func (rl *RateLimiter) Release() <span class="cov8" title="1">{
        rl.semaphore.Release()
        // No explicit release needed for token bucket
}</span>

// Helper functions for min/max (Go 1.21+ has these in standard math package)
func min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

func max(a, b int) int <span class="cov0" title="0">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package runutil provides utilities for generating and managing run names
package runutil

import (
        "math/rand"
        "time"
)

// randomSource is a dedicated random source for generating run names
var randomSource = rand.New(rand.NewSource(time.Now().UnixNano()))

// List of adjectives for generating run names
var adjectives = []string{
        "amber", "ancient", "autumn", "bold", "brave", "bright", "calm", "clever",
        "coastal", "cosmic", "crimson", "crystal", "curious", "daring", "deep",
        "distant", "eager", "elegant", "emerald", "enchanted", "endless", "energetic",
        "ethereal", "fierce", "floral", "flowing", "flying", "forest", "gentle",
        "golden", "graceful", "grand", "hidden", "humming", "icy", "infinite",
        "jade", "jolly", "kind", "lively", "lunar", "majestic", "melodic", "mighty",
        "misty", "morning", "mountain", "noble", "ocean", "patient", "peaceful",
        "playful", "poetic", "proud", "purple", "quick", "quiet", "radiant", "rapid",
        "royal", "ruby", "rustic", "serene", "shining", "silent", "silver", "sincere",
        "singing", "skillful", "sleepy", "smiling", "snowy", "solar", "sparkling",
        "spring", "starry", "steadfast", "stormy", "summer", "sunny", "swift",
        "thoughtful", "thundering", "tranquil", "twilight", "vibrant", "wandering",
        "whispering", "wild", "winter", "wise", "zephyr",
}

// List of nouns for generating run names
var nouns = []string{
        "acorn", "archipelago", "aurora", "badger", "beacon", "bear", "birch",
        "bison", "brook", "buzzard", "canyon", "cardinal", "cascade", "cave",
        "cheetah", "cliff", "cloud", "coast", "condor", "coral", "cove", "crater",
        "creek", "dawn", "deer", "delta", "dolphin", "dove", "dragon", "driftwood",
        "dusk", "eagle", "elm", "falcon", "fern", "firefly", "fjord", "flower",
        "forest", "galaxy", "gazelle", "geyser", "glacier", "grove", "harbor",
        "hawk", "heron", "hill", "horizon", "ibex", "iceberg", "island", "jackal",
        "jaguar", "jay", "journey", "koala", "lagoon", "lantern", "leopard", "lighthouse",
        "lightning", "lynx", "maple", "marsh", "meadow", "meteor", "mist", "moon",
        "moose", "mountain", "nebula", "ocean", "osprey", "otter", "owl", "panther",
        "path", "peak", "penguin", "phoenix", "pine", "planet", "plateau", "puma",
        "quail", "rabbit", "raccoon", "rain", "raven", "reef", "ridge", "river",
        "robin", "rock", "satellite", "sea", "sequoia", "shadow", "shore", "sparrow",
        "squirrel", "star", "storm", "stream", "summit", "sun", "sunset", "swift",
        "thunder", "tiger", "tortoise", "trail", "valley", "vapor", "volcano", "wave",
        "willow", "wind", "wolf", "zenith",
}

// GenerateRunName creates a random adjective-noun combination suitable for use
// as a run name or directory name. The result follows the pattern "adjective-noun"
// with all lowercase and a hyphen as separator.
func GenerateRunName() string <span class="cov8" title="1">{
        adjective := adjectives[randomSource.Intn(len(adjectives))]
        noun := nouns[randomSource.Intn(len(nouns))]

        return adjective + "-" + noun
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
