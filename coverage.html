
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>architect: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">github.com/phrazzld/architect/cmd/architect/api.go (100.0%)</option>

				<option value="file1">github.com/phrazzld/architect/cmd/architect/api_test_helper.go (0.0%)</option>

				<option value="file2">github.com/phrazzld/architect/cmd/architect/cli.go (98.8%)</option>

				<option value="file3">github.com/phrazzld/architect/cmd/architect/main.go (0.0%)</option>

				<option value="file4">github.com/phrazzld/architect/cmd/architect/output.go (78.9%)</option>

				<option value="file5">github.com/phrazzld/architect/cmd/architect/token.go (97.4%)</option>

				<option value="file6">github.com/phrazzld/architect/internal/architect/adapters.go (100.0%)</option>

				<option value="file7">github.com/phrazzld/architect/internal/architect/api.go (0.0%)</option>

				<option value="file8">github.com/phrazzld/architect/internal/architect/app.go (74.5%)</option>

				<option value="file9">github.com/phrazzld/architect/internal/architect/context.go (77.0%)</option>

				<option value="file10">github.com/phrazzld/architect/internal/architect/filewriter.go (51.5%)</option>

				<option value="file11">github.com/phrazzld/architect/internal/architect/modelproc/processor.go (64.2%)</option>

				<option value="file12">github.com/phrazzld/architect/internal/architect/orchestrator/orchestrator.go (93.5%)</option>

				<option value="file13">github.com/phrazzld/architect/internal/architect/prompt/prompt.go (100.0%)</option>

				<option value="file14">github.com/phrazzld/architect/internal/architect/token.go (57.4%)</option>

				<option value="file15">github.com/phrazzld/architect/internal/auditlog/logger.go (80.6%)</option>

				<option value="file16">github.com/phrazzld/architect/internal/config/config.go (100.0%)</option>

				<option value="file17">github.com/phrazzld/architect/internal/fileutil/fileutil.go (97.8%)</option>

				<option value="file18">github.com/phrazzld/architect/internal/fileutil/mock_logger.go (24.1%)</option>

				<option value="file19">github.com/phrazzld/architect/internal/gemini/client.go (77.8%)</option>

				<option value="file20">github.com/phrazzld/architect/internal/gemini/errors.go (100.0%)</option>

				<option value="file21">github.com/phrazzld/architect/internal/gemini/gemini_client.go (64.1%)</option>

				<option value="file22">github.com/phrazzld/architect/internal/gemini/mock_client.go (96.2%)</option>

				<option value="file23">github.com/phrazzld/architect/internal/integration/test_helpers.go (36.4%)</option>

				<option value="file24">github.com/phrazzld/architect/internal/integration/test_runner.go (35.3%)</option>

				<option value="file25">github.com/phrazzld/architect/internal/logutil/logutil.go (66.7%)</option>

				<option value="file26">github.com/phrazzld/architect/internal/ratelimit/ratelimit.go (82.4%)</option>

				<option value="file27">github.com/phrazzld/architect/internal/runutil/runutil.go (100.0%)</option>

				<option value="file28">github.com/phrazzld/architect/main.go (0.0%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">// Package architect provides the command-line interface for the architect tool
package architect

import (
        "github.com/phrazzld/architect/internal/architect"
        "github.com/phrazzld/architect/internal/logutil"
)

// Re-export error types from internal/architect for backward compatibility with tests
var (
        ErrEmptyResponse        = architect.ErrEmptyResponse
        ErrWhitespaceContent    = architect.ErrWhitespaceContent
        ErrSafetyBlocked        = architect.ErrSafetyBlocked
        ErrAPICall              = architect.ErrAPICall
        ErrClientInitialization = architect.ErrClientInitialization
)

// APIService is an alias to the internal one
type APIService = architect.APIService

// NewAPIService is a wrapper for the internal one
func NewAPIService(logger logutil.LoggerInterface) APIService <span class="cov8" title="1">{
        return architect.NewAPIService(logger)
}</span>
</pre>

		<pre class="file" id="file1" style="display: none">package architect

import (
        "context"
        "github.com/phrazzld/architect/internal/gemini"
)

// MockClient is a mock implementation of gemini.Client for testing
type MockClient struct {
        CountTokensFunc     func(ctx context.Context, prompt string) (*gemini.TokenCount, error)
        GenerateContentFunc func(ctx context.Context, prompt string) (*gemini.GenerationResult, error)
        GetModelInfoFunc    func(ctx context.Context) (*gemini.ModelInfo, error)
        CloseFunc           func() error
}

func (m *MockClient) CountTokens(ctx context.Context, prompt string) (*gemini.TokenCount, error) <span class="cov0" title="0">{
        if m.CountTokensFunc != nil </span><span class="cov0" title="0">{
                return m.CountTokensFunc(ctx, prompt)
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

func (m *MockClient) GenerateContent(ctx context.Context, prompt string) (*gemini.GenerationResult, error) <span class="cov0" title="0">{
        if m.GenerateContentFunc != nil </span><span class="cov0" title="0">{
                return m.GenerateContentFunc(ctx, prompt)
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

func (m *MockClient) GetModelInfo(ctx context.Context) (*gemini.ModelInfo, error) <span class="cov0" title="0">{
        if m.GetModelInfoFunc != nil </span><span class="cov0" title="0">{
                return m.GetModelInfoFunc(ctx)
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

func (m *MockClient) Close() error <span class="cov0" title="0">{
        if m.CloseFunc != nil </span><span class="cov0" title="0">{
                return m.CloseFunc()
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>

		<pre class="file" id="file2" style="display: none">// Package architect provides the command-line interface for the architect tool
package architect

import (
        "flag"
        "fmt"
        "io"
        "os"
        "strings"

        "github.com/phrazzld/architect/internal/config"
        "github.com/phrazzld/architect/internal/logutil"
)

// stringSliceFlag is a slice of strings that implements flag.Value interface
// to handle repeatable flags for multiple values
type stringSliceFlag []string

// String returns a comma-separated string representation of the flag values
// This method is required by the flag.Value interface
func (s *stringSliceFlag) String() string <span class="cov8" title="1">{
        return strings.Join(*s, ",")
}</span>

// Set appends the value to the slice of values
// This method is required by the flag.Value interface
func (s *stringSliceFlag) Set(value string) error <span class="cov8" title="1">{
        *s = append(*s, value)
        return nil
}</span>

// Constants referencing the config package defaults
const (
        defaultOutputFile   = config.DefaultOutputFile
        defaultModel        = config.DefaultModel
        apiKeyEnvVar        = config.APIKeyEnvVar
        apiEndpointEnvVar   = config.APIEndpointEnvVar
        defaultFormat       = config.DefaultFormat
        defaultExcludes     = config.DefaultExcludes
        defaultExcludeNames = config.DefaultExcludeNames
)

// ValidateInputs checks if the configuration is valid and returns an error if not
func ValidateInputs(config *config.CliConfig, logger logutil.LoggerInterface) error <span class="cov8" title="1">{
        // Check for instructions file
        if config.InstructionsFile == "" &amp;&amp; !config.DryRun </span><span class="cov8" title="1">{
                logger.Error("The required --instructions flag is missing.")
                return fmt.Errorf("missing required --instructions flag")
        }</span>

        // Check for input paths
        <span class="cov8" title="1">if len(config.Paths) == 0 </span><span class="cov8" title="1">{
                logger.Error("At least one file or directory path must be provided as an argument.")
                return fmt.Errorf("no paths specified")
        }</span>

        // Check for API key
        <span class="cov8" title="1">if config.APIKey == "" </span><span class="cov8" title="1">{
                logger.Error("%s environment variable not set.", apiKeyEnvVar)
                return fmt.Errorf("API key not set")
        }</span>

        // Check for model names
        <span class="cov8" title="1">if len(config.ModelNames) == 0 &amp;&amp; !config.DryRun </span><span class="cov8" title="1">{
                logger.Error("At least one model must be specified with --model flag.")
                return fmt.Errorf("no models specified")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ParseFlags handles command line argument parsing and returns the configuration
func ParseFlags() (*config.CliConfig, error) <span class="cov0" title="0">{
        return ParseFlagsWithEnv(flag.CommandLine, os.Args[1:], os.Getenv)
}</span>

// ParseFlagsWithEnv handles command-line flag parsing with custom flag set and environment lookup
// This improves testability by allowing tests to provide mock flag sets and environment functions
func ParseFlagsWithEnv(flagSet *flag.FlagSet, args []string, getenv func(string) string) (*config.CliConfig, error) <span class="cov8" title="1">{
        cfg := config.NewDefaultCliConfig()

        // Define flags
        instructionsFileFlag := flagSet.String("instructions", "", "Path to a file containing the static instructions for the LLM.")
        outputDirFlag := flagSet.String("output-dir", "", "Directory path to store generated plans (one per model).")
        verboseFlag := flagSet.Bool("verbose", false, "Enable verbose logging output (shorthand for --log-level=debug).")
        logLevelFlag := flagSet.String("log-level", "info", "Set logging level (debug, info, warn, error).")
        includeFlag := flagSet.String("include", "", "Comma-separated list of file extensions to include (e.g., .go,.md)")
        excludeFlag := flagSet.String("exclude", defaultExcludes, "Comma-separated list of file extensions to exclude.")
        excludeNamesFlag := flagSet.String("exclude-names", defaultExcludeNames, "Comma-separated list of file/dir names to exclude.")
        formatFlag := flagSet.String("format", defaultFormat, "Format string for each file. Use {path} and {content}.")
        dryRunFlag := flagSet.Bool("dry-run", false, "Show files that would be included and token count, but don't call the API.")
        confirmTokensFlag := flagSet.Int("confirm-tokens", 0, "Prompt for confirmation if token count exceeds this value (0 = never prompt)")
        auditLogFileFlag := flagSet.String("audit-log-file", "", "Path to write structured audit logs (JSON Lines). Disabled if empty.")

        // Rate limiting flags
        maxConcurrentFlag := flagSet.Int("max-concurrent", 5, // Use hardcoded default for backward compatibility with tests
                "Maximum number of concurrent API requests (0 = no limit)")
        rateLimitRPMFlag := flagSet.Int("rate-limit", 60, // Use hardcoded default for backward compatibility with tests
                "Maximum requests per minute (RPM) per model (0 = no limit)")

        // Define the model flag using our custom stringSliceFlag type to support multiple values
        modelFlag := &amp;stringSliceFlag{}
        flagSet.Var(modelFlag, "model", fmt.Sprintf("Gemini model to use for generation (repeatable). Default: %s", defaultModel))

        // Set custom usage message
        flagSet.Usage = func() </span><span class="cov8" title="1">{
                fmt.Fprintf(os.Stderr, "Usage: %s --instructions &lt;file&gt; [options] &lt;path1&gt; [path2...]\n\n", os.Args[0])

                fmt.Fprintf(os.Stderr, "Arguments:\n")
                fmt.Fprintf(os.Stderr, "  &lt;path1&gt; [path2...]   One or more file or directory paths for project context.\n\n")

                fmt.Fprintf(os.Stderr, "Example Commands:\n")
                fmt.Fprintf(os.Stderr, "  %s --instructions instructions.txt ./src                        Generate plan using default model\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  %s --instructions instructions.txt --output-dir custom-dir ./       Generate plans in custom directory\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  %s --instructions instructions.txt --model model1 --model model2 ./  Generate plans for multiple models\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  %s --dry-run ./                                                 Show files without generating plan\n\n", os.Args[0])

                fmt.Fprintf(os.Stderr, "Options:\n")
                flagSet.PrintDefaults()

                fmt.Fprintf(os.Stderr, "\nEnvironment Variables:\n")
                fmt.Fprintf(os.Stderr, "  %s: Required. Your Google AI Gemini API key.\n", apiKeyEnvVar)
        }</span>

        // Parse the flags
        <span class="cov8" title="1">if err := flagSet.Parse(args); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error parsing flags: %w", err)
        }</span>

        // Store flag values in configuration
        <span class="cov8" title="1">cfg.InstructionsFile = *instructionsFileFlag

        // Set output directory
        cfg.OutputDir = *outputDirFlag

        cfg.AuditLogFile = *auditLogFileFlag
        cfg.Verbose = *verboseFlag
        cfg.Include = *includeFlag
        cfg.Exclude = *excludeFlag
        cfg.ExcludeNames = *excludeNamesFlag
        cfg.Format = *formatFlag
        cfg.DryRun = *dryRunFlag
        cfg.ConfirmTokens = *confirmTokensFlag
        cfg.Paths = flagSet.Args()

        // Store rate limiting configuration
        cfg.MaxConcurrentRequests = *maxConcurrentFlag
        cfg.RateLimitRequestsPerMinute = *rateLimitRPMFlag

        // Set model names from the flag, defaulting to a single default model if none provided
        if len(*modelFlag) &gt; 0 </span><span class="cov8" title="1">{
                cfg.ModelNames = *modelFlag
        }</span> else<span class="cov8" title="1"> {
                // If no models were specified on the command line, use the default model
                cfg.ModelNames = []string{defaultModel}
        }</span>

        // Determine initial log level from flag
        <span class="cov8" title="1">parsedLogLevel := logutil.InfoLevel // Default
        if *logLevelFlag != "info" </span><span class="cov8" title="1">{
                ll, err := logutil.ParseLogLevel(*logLevelFlag)
                if err == nil </span><span class="cov8" title="1">{
                        parsedLogLevel = ll
                }</span>
        }
        <span class="cov8" title="1">cfg.LogLevel = parsedLogLevel

        // Apply verbose override *after* parsing the specific level
        if cfg.Verbose </span><span class="cov8" title="1">{
                cfg.LogLevel = logutil.DebugLevel
        }</span>
        <span class="cov8" title="1">cfg.APIKey = getenv(apiKeyEnvVar)
        cfg.APIEndpoint = getenv(apiEndpointEnvVar)

        // ParseFlagsWithEnv no longer does logical validation (just parsing errors)
        // Validation is now exclusively handled by ValidateInputs
        return cfg, nil</span>
}

// setupLoggingCustomImpl is the implementation of SetupLoggingCustom
func setupLoggingCustomImpl(config *config.CliConfig, _ *flag.Flag, output io.Writer) logutil.LoggerInterface <span class="cov8" title="1">{
        // Apply verbose override if set
        if config.Verbose </span><span class="cov8" title="1">{
                config.LogLevel = logutil.DebugLevel
        }</span>

        // Use the LogLevel set in the config
        <span class="cov8" title="1">logger := logutil.NewLogger(config.LogLevel, output, "[architect] ")
        return logger</span>
}

// SetupLoggingCustom is a variable holding the implementation for easier testing
var SetupLoggingCustom = setupLoggingCustomImpl

// SetupLogging initializes the logger based on configuration
func SetupLogging(config *config.CliConfig) logutil.LoggerInterface <span class="cov8" title="1">{
        return SetupLoggingCustom(config, flag.Lookup("log-level"), os.Stderr)
}</span>
</pre>

		<pre class="file" id="file3" style="display: none">// Package architect provides the command-line interface for the architect tool
package architect

import (
        "context"
        "fmt"
        "os"

        "github.com/phrazzld/architect/internal/architect"
        "github.com/phrazzld/architect/internal/auditlog"
)

// Main is the entry point for the architect CLI
func Main() <span class="cov0" title="0">{
        // Create a base context
        ctx := context.Background()

        // Parse command line flags
        config, err := ParseFlags()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>

        // Setup logging early for error reporting
        <span class="cov0" title="0">logger := SetupLogging(config)
        logger.Info("Starting Architect - AI-assisted content generation tool")

        // Initialize the audit logger
        // Note: The auditLogger will be passed to Execute() in a future task
        var auditLogger auditlog.AuditLogger
        if config.AuditLogFile != "" </span><span class="cov0" title="0">{
                fileLogger, err := auditlog.NewFileAuditLogger(config.AuditLogFile, logger)
                if err != nil </span><span class="cov0" title="0">{
                        // Log error and fall back to NoOp implementation
                        logger.Error("Failed to initialize file audit logger: %v. Audit logging disabled.", err)
                        auditLogger = auditlog.NewNoOpAuditLogger()
                }</span> else<span class="cov0" title="0"> {
                        auditLogger = fileLogger
                        logger.Info("Audit logging enabled to file: %s", config.AuditLogFile)
                }</span>
        } else<span class="cov0" title="0"> {
                auditLogger = auditlog.NewNoOpAuditLogger()
                logger.Debug("Audit logging is disabled")
        }</span>

        // Ensure the audit logger is properly closed when the application exits
        <span class="cov0" title="0">defer auditLogger.Close()

        // Configuration is now managed via CLI flags and environment variables only

        // Validate inputs before proceeding
        if err := ValidateInputs(config, logger); err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>

        // CLI flags and environment variables are now the only source of configuration

        // Initialize APIService
        <span class="cov0" title="0">apiService := architect.NewAPIService(logger)

        // Execute the core application logic
        err = architect.Execute(ctx, config, logger, auditLogger, apiService)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Application failed: %v", err)
                os.Exit(1)
        }</span>
}
</pre>

		<pre class="file" id="file4" style="display: none">// Package architect provides the command-line interface for the architect tool
package architect

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/phrazzld/architect/internal/logutil"
)

// FileWriter defines the interface for file writing
type FileWriter interface {
        // SaveToFile writes content to the specified file
        SaveToFile(content, outputFile string) error
}

// fileWriter implements the FileWriter interface
type fileWriter struct {
        logger logutil.LoggerInterface
}

// NewFileWriter creates a new FileWriter instance
func NewFileWriter(logger logutil.LoggerInterface) FileWriter <span class="cov8" title="1">{
        return &amp;fileWriter{
                logger: logger,
        }
}</span>

// SaveToFile writes content to the specified file
func (fw *fileWriter) SaveToFile(content, outputFile string) error <span class="cov8" title="1">{
        // Ensure output path is absolute
        outputPath := outputFile
        if !filepath.IsAbs(outputPath) </span><span class="cov8" title="1">{
                cwd, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        fw.logger.Error("Error getting current working directory: %v", err)
                        return fmt.Errorf("error getting current working directory: %w", err)
                }</span>
                <span class="cov8" title="1">outputPath = filepath.Join(cwd, outputPath)</span>
        }

        // Ensure the output directory exists
        <span class="cov8" title="1">outputDir := filepath.Dir(outputPath)
        if err := os.MkdirAll(outputDir, 0755); err != nil </span><span class="cov8" title="1">{
                fw.logger.Error("Error creating output directory %s: %v", outputDir, err)
                return fmt.Errorf("error creating output directory %s: %w", outputDir, err)
        }</span>

        // Write to file
        <span class="cov8" title="1">fw.logger.Info("Writing to file %s...", outputPath)
        err := os.WriteFile(outputPath, []byte(content), 0644)
        if err != nil </span><span class="cov0" title="0">{
                fw.logger.Error("Error writing to file %s: %v", outputPath, err)
                return fmt.Errorf("error writing to file %s: %w", outputPath, err)
        }</span>

        <span class="cov8" title="1">fw.logger.Info("Successfully saved to %s", outputPath)
        return nil</span>
}
</pre>

		<pre class="file" id="file5" style="display: none">// Package architect provides the command-line interface for the architect tool
package architect

import (
        "bufio"
        "context"
        "fmt"
        "os"
        "strings"

        "github.com/phrazzld/architect/internal/gemini"
        "github.com/phrazzld/architect/internal/logutil"
)

// TokenResult holds information about token counts and limits
type TokenResult struct {
        TokenCount   int32
        InputLimit   int32
        ExceedsLimit bool
        LimitError   string
        Percentage   float64
}

// TokenManager defines the interface for token counting and management
type TokenManager interface {
        // GetTokenInfo retrieves token count information and checks limits
        GetTokenInfo(ctx context.Context, prompt string) (*TokenResult, error)

        // CheckTokenLimit verifies the prompt doesn't exceed the model's token limit
        CheckTokenLimit(ctx context.Context, prompt string) error

        // PromptForConfirmation asks for user confirmation to proceed if token count exceeds threshold
        PromptForConfirmation(tokenCount int32, threshold int) bool
}

// tokenManager implements the TokenManager interface
type tokenManager struct {
        logger logutil.LoggerInterface
        client gemini.Client
}

// NewTokenManager creates a new TokenManager instance
func NewTokenManager(logger logutil.LoggerInterface, client gemini.Client) (TokenManager, error) <span class="cov8" title="1">{
        if client == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("client cannot be nil for TokenManager")
        }</span>
        <span class="cov8" title="1">return &amp;tokenManager{
                logger: logger,
                client: client,
        }, nil</span>
}

// GetTokenInfo retrieves token count information and checks limits
func (tm *tokenManager) GetTokenInfo(ctx context.Context, prompt string) (*TokenResult, error) <span class="cov8" title="1">{
        // Create result structure
        result := &amp;TokenResult{
                ExceedsLimit: false,
        }

        // Get model information (limits)
        modelInfo, err := tm.client.GetModelInfo(ctx)
        if err != nil </span><span class="cov8" title="1">{
                // Pass through API errors directly for better error messages
                if _, ok := gemini.IsAPIError(err); ok </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                // Wrap other errors
                <span class="cov8" title="1">return nil, fmt.Errorf("failed to get model info for token limit check: %w", err)</span>
        }

        // Store input limit
        <span class="cov8" title="1">result.InputLimit = modelInfo.InputTokenLimit

        // Count tokens in the prompt
        tokenResult, err := tm.client.CountTokens(ctx, prompt)
        if err != nil </span><span class="cov8" title="1">{
                // Pass through API errors directly for better error messages
                if _, ok := gemini.IsAPIError(err); ok </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Wrap other errors
                <span class="cov8" title="1">return nil, fmt.Errorf("failed to count tokens for token limit check: %w", err)</span>
        }

        // Store token count
        <span class="cov8" title="1">result.TokenCount = tokenResult.Total

        // Calculate percentage of limit
        result.Percentage = float64(result.TokenCount) / float64(result.InputLimit) * 100

        // Log token usage information
        tm.logger.Debug("Token usage: %d / %d (%.1f%%)",
                result.TokenCount,
                result.InputLimit,
                result.Percentage)

        // Check if the prompt exceeds the token limit
        if result.TokenCount &gt; result.InputLimit </span><span class="cov8" title="1">{
                result.ExceedsLimit = true
                result.LimitError = fmt.Sprintf("prompt exceeds token limit (%d tokens &gt; %d token limit)",
                        result.TokenCount, result.InputLimit)
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// CheckTokenLimit verifies the prompt doesn't exceed the model's token limit
func (tm *tokenManager) CheckTokenLimit(ctx context.Context, prompt string) error <span class="cov8" title="1">{
        tokenInfo, err := tm.GetTokenInfo(ctx, prompt)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if tokenInfo.ExceedsLimit </span><span class="cov8" title="1">{
                return fmt.Errorf(tokenInfo.LimitError)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// PromptForConfirmation asks for user confirmation to proceed
func (tm *tokenManager) PromptForConfirmation(tokenCount int32, threshold int) bool <span class="cov8" title="1">{
        if threshold &lt;= 0 || int32(threshold) &gt; tokenCount </span><span class="cov8" title="1">{
                // No confirmation needed if threshold is disabled (0) or token count is below threshold
                return true
        }</span>

        <span class="cov8" title="1">tm.logger.Info("Token count (%d) exceeds confirmation threshold (%d).", tokenCount, threshold)
        tm.logger.Info("Do you want to proceed with the API call? [y/N]: ")

        reader := bufio.NewReader(os.Stdin)
        response, err := reader.ReadString('\n')
        if err != nil </span><span class="cov8" title="1">{
                tm.logger.Error("Error reading input: %v", err)
                return false
        }</span>

        // Trim whitespace and convert to lowercase
        <span class="cov8" title="1">response = strings.ToLower(strings.TrimSpace(response))

        // Only proceed if the user explicitly confirms with 'y' or 'yes'
        return response == "y" || response == "yes"</span>
}
</pre>

		<pre class="file" id="file6" style="display: none">package architect

import (
        "context"

        "github.com/phrazzld/architect/internal/architect/interfaces"
        "github.com/phrazzld/architect/internal/architect/modelproc"
        "github.com/phrazzld/architect/internal/fileutil"
        "github.com/phrazzld/architect/internal/gemini"
)

// APIServiceAdapter adapts internal APIService to interfaces.APIService
type APIServiceAdapter struct {
        APIService APIService
}

func (a *APIServiceAdapter) InitClient(ctx context.Context, apiKey, modelName, apiEndpoint string) (gemini.Client, error) <span class="cov8" title="1">{
        return a.APIService.InitClient(ctx, apiKey, modelName, apiEndpoint)
}</span>

func (a *APIServiceAdapter) ProcessResponse(result *gemini.GenerationResult) (string, error) <span class="cov8" title="1">{
        return a.APIService.ProcessResponse(result)
}</span>

func (a *APIServiceAdapter) IsEmptyResponseError(err error) bool <span class="cov8" title="1">{
        return a.APIService.IsEmptyResponseError(err)
}</span>

func (a *APIServiceAdapter) IsSafetyBlockedError(err error) bool <span class="cov8" title="1">{
        return a.APIService.IsSafetyBlockedError(err)
}</span>

func (a *APIServiceAdapter) GetErrorDetails(err error) string <span class="cov8" title="1">{
        return a.APIService.GetErrorDetails(err)
}</span>

// TokenResultAdapter adapts TokenResult to modelproc.TokenResult
func TokenResultAdapter(tr *TokenResult) *modelproc.TokenResult <span class="cov8" title="1">{
        return &amp;modelproc.TokenResult{
                TokenCount:   tr.TokenCount,
                InputLimit:   tr.InputLimit,
                ExceedsLimit: tr.ExceedsLimit,
                LimitError:   tr.LimitError,
                Percentage:   tr.Percentage,
        }
}</span>

// TokenManagerAdapter adapts internal TokenManager to interfaces.TokenManager
type TokenManagerAdapter struct {
        TokenManager TokenManager
}

func (t *TokenManagerAdapter) CheckTokenLimit(ctx context.Context, prompt string) error <span class="cov8" title="1">{
        return t.TokenManager.CheckTokenLimit(ctx, prompt)
}</span>

func (t *TokenManagerAdapter) GetTokenInfo(ctx context.Context, prompt string) (*interfaces.TokenResult, error) <span class="cov8" title="1">{
        result, err := t.TokenManager.GetTokenInfo(ctx, prompt)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Convert the TokenResult to interfaces.TokenResult
        <span class="cov8" title="1">return &amp;interfaces.TokenResult{
                TokenCount:   result.TokenCount,
                InputLimit:   result.InputLimit,
                ExceedsLimit: result.ExceedsLimit,
                LimitError:   result.LimitError,
                Percentage:   result.Percentage,
        }, nil</span>
}

func (t *TokenManagerAdapter) PromptForConfirmation(tokenCount int32, threshold int) bool <span class="cov8" title="1">{
        return t.TokenManager.PromptForConfirmation(tokenCount, threshold)
}</span>

// ContextGathererAdapter adapts internal ContextGatherer to interfaces.ContextGatherer
type ContextGathererAdapter struct {
        ContextGatherer ContextGatherer
}

func (c *ContextGathererAdapter) GatherContext(ctx context.Context, config interfaces.GatherConfig) ([]fileutil.FileMeta, *interfaces.ContextStats, error) <span class="cov8" title="1">{
        // Convert interfaces.GatherConfig to internal GatherConfig
        internalConfig := GatherConfig{
                Paths:        config.Paths,
                Include:      config.Include,
                Exclude:      config.Exclude,
                ExcludeNames: config.ExcludeNames,
                Format:       config.Format,
                Verbose:      config.Verbose,
                LogLevel:     config.LogLevel,
        }

        files, stats, err := c.ContextGatherer.GatherContext(ctx, internalConfig)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, err
        }</span>

        // Convert internal ContextStats to interfaces.ContextStats
        <span class="cov8" title="1">interfaceStats := &amp;interfaces.ContextStats{
                ProcessedFilesCount: stats.ProcessedFilesCount,
                CharCount:           stats.CharCount,
                LineCount:           stats.LineCount,
                TokenCount:          stats.TokenCount,
                ProcessedFiles:      stats.ProcessedFiles,
        }

        return files, interfaceStats, nil</span>
}

func (c *ContextGathererAdapter) DisplayDryRunInfo(ctx context.Context, stats *interfaces.ContextStats) error <span class="cov8" title="1">{
        // Convert interfaces.ContextStats to internal ContextStats
        internalStats := &amp;ContextStats{
                ProcessedFilesCount: stats.ProcessedFilesCount,
                CharCount:           stats.CharCount,
                LineCount:           stats.LineCount,
                TokenCount:          stats.TokenCount,
                ProcessedFiles:      stats.ProcessedFiles,
        }

        return c.ContextGatherer.DisplayDryRunInfo(ctx, internalStats)
}</span>

// FileWriterAdapter adapts internal FileWriter to interfaces.FileWriter
type FileWriterAdapter struct {
        FileWriter FileWriter
}

func (f *FileWriterAdapter) SaveToFile(content, outputFile string) error <span class="cov8" title="1">{
        return f.FileWriter.SaveToFile(content, outputFile)
}</span>
</pre>

		<pre class="file" id="file7" style="display: none">// Package architect contains the core application logic for the architect tool
package architect

import (
        "context"
        "errors"
        "fmt"
        "strings"

        "github.com/phrazzld/architect/internal/gemini"
        "github.com/phrazzld/architect/internal/logutil"
)

// Define package-level error types for better error handling
var (
        // ErrEmptyResponse indicates the API returned an empty response
        ErrEmptyResponse = errors.New("received empty response from Gemini")

        // ErrWhitespaceContent indicates the API returned only whitespace content
        ErrWhitespaceContent = errors.New("Gemini returned an empty output text")

        // ErrSafetyBlocked indicates content was blocked by safety filters
        ErrSafetyBlocked = errors.New("content blocked by Gemini safety filters")

        // ErrAPICall indicates a general API call error
        ErrAPICall = errors.New("error calling Gemini API")

        // ErrClientInitialization indicates client initialization failed
        ErrClientInitialization = errors.New("error creating Gemini client")
)

// APIService defines the interface for API-related operations
type APIService interface {
        // InitClient initializes and returns a Gemini client
        InitClient(ctx context.Context, apiKey, modelName, apiEndpoint string) (gemini.Client, error)

        // ProcessResponse processes the API response and extracts content
        ProcessResponse(result *gemini.GenerationResult) (string, error)

        // IsEmptyResponseError checks if an error is related to empty API responses
        IsEmptyResponseError(err error) bool

        // IsSafetyBlockedError checks if an error is related to safety filters
        IsSafetyBlockedError(err error) bool

        // GetErrorDetails extracts detailed information from an error
        GetErrorDetails(err error) string
}

// apiService implements the APIService interface
type apiService struct {
        logger logutil.LoggerInterface
        // For testing
        newClientFunc func(ctx context.Context, apiKey, modelName, apiEndpoint string) (gemini.Client, error)
}

// newClientWrapper wraps gemini.NewClient to match the expected signature
func newClientWrapper(ctx context.Context, apiKey, modelName, apiEndpoint string) (gemini.Client, error) <span class="cov0" title="0">{
        return gemini.NewClient(ctx, apiKey, modelName, apiEndpoint)
}</span>

// NewAPIService creates a new instance of APIService
func NewAPIService(logger logutil.LoggerInterface) APIService <span class="cov0" title="0">{
        return &amp;apiService{
                logger:        logger,
                newClientFunc: newClientWrapper, // Use our wrapper to match signatures
        }
}</span>

// InitClient initializes and returns a Gemini client
func (s *apiService) InitClient(ctx context.Context, apiKey, modelName, apiEndpoint string) (gemini.Client, error) <span class="cov0" title="0">{
        // Check for empty required parameters
        if apiKey == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: API key is required", ErrClientInitialization)
        }</span>
        <span class="cov0" title="0">if modelName == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: model name is required", ErrClientInitialization)
        }</span>

        // Check for context cancellation
        <span class="cov0" title="0">if ctx.Err() != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: %v", ErrClientInitialization, ctx.Err())
        }</span>

        // Log custom endpoint if provided
        <span class="cov0" title="0">if apiEndpoint != "" </span><span class="cov0" title="0">{
                s.logger.Debug("Using custom API endpoint: %s", apiEndpoint)
        }</span>

        // Initialize the client (using a function that can be swapped out in tests)
        <span class="cov0" title="0">client, err := s.newClientFunc(ctx, apiKey, modelName, apiEndpoint)
        if err != nil </span><span class="cov0" title="0">{
                // Check if it's already an API error with enhanced details
                if apiErr, ok := gemini.IsAPIError(err); ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w: %s", ErrClientInitialization, apiErr.UserFacingError())
                }</span>

                // Wrap the original error
                <span class="cov0" title="0">return nil, fmt.Errorf("%w: %v", ErrClientInitialization, err)</span>
        }

        <span class="cov0" title="0">return client, nil</span>
}

// ProcessResponse processes the API response and extracts content
func (s *apiService) ProcessResponse(result *gemini.GenerationResult) (string, error) <span class="cov0" title="0">{
        // Check for nil result
        if result == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%w: result is nil", ErrEmptyResponse)
        }</span>

        // Check for empty content
        <span class="cov0" title="0">if result.Content == "" </span><span class="cov0" title="0">{
                var errDetails strings.Builder

                // Add finish reason if available
                if result.FinishReason != "" </span><span class="cov0" title="0">{
                        fmt.Fprintf(&amp;errDetails, " (Finish Reason: %s)", result.FinishReason)
                }</span>

                // Check for safety blocks
                <span class="cov0" title="0">if len(result.SafetyRatings) &gt; 0 </span><span class="cov0" title="0">{
                        blocked := false
                        safetyInfo := ""
                        for _, rating := range result.SafetyRatings </span><span class="cov0" title="0">{
                                if rating.Blocked </span><span class="cov0" title="0">{
                                        blocked = true
                                        safetyInfo += fmt.Sprintf(" Blocked by Safety Category: %s;", rating.Category)
                                }</span>
                        }

                        <span class="cov0" title="0">if blocked </span><span class="cov0" title="0">{
                                if errDetails.Len() &gt; 0 </span><span class="cov0" title="0">{
                                        errDetails.WriteString(" ")
                                }</span>
                                <span class="cov0" title="0">errDetails.WriteString("Safety Blocking:")
                                errDetails.WriteString(safetyInfo)

                                // If we have safety blocks, use the specific safety error
                                return "", fmt.Errorf("%w%s", ErrSafetyBlocked, errDetails.String())</span>
                        }
                }

                // If we don't have safety blocks, use the generic empty response error
                <span class="cov0" title="0">return "", fmt.Errorf("%w%s", ErrEmptyResponse, errDetails.String())</span>
        }

        // Check for whitespace-only content
        <span class="cov0" title="0">if strings.TrimSpace(result.Content) == "" </span><span class="cov0" title="0">{
                return "", ErrWhitespaceContent
        }</span>

        <span class="cov0" title="0">return result.Content, nil</span>
}

// IsEmptyResponseError checks if an error is related to empty API responses
func (s *apiService) IsEmptyResponseError(err error) bool <span class="cov0" title="0">{
        return errors.Is(err, ErrEmptyResponse) || errors.Is(err, ErrWhitespaceContent)
}</span>

// IsSafetyBlockedError checks if an error is related to safety filters
func (s *apiService) IsSafetyBlockedError(err error) bool <span class="cov0" title="0">{
        return errors.Is(err, ErrSafetyBlocked)
}</span>

// GetErrorDetails extracts detailed information from an error
func (s *apiService) GetErrorDetails(err error) string <span class="cov0" title="0">{
        // Handle nil error case
        if err == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Check if it's an API error with enhanced details
        <span class="cov0" title="0">if apiErr, ok := gemini.IsAPIError(err); ok </span><span class="cov0" title="0">{
                return apiErr.UserFacingError()
        }</span>

        // Return the error string for other error types
        <span class="cov0" title="0">return err.Error()</span>
}
</pre>

		<pre class="file" id="file8" style="display: none">// Package architect contains the core application logic for the architect tool
package architect

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "time"

        "github.com/phrazzld/architect/internal/architect/interfaces"
        "github.com/phrazzld/architect/internal/architect/orchestrator"
        "github.com/phrazzld/architect/internal/auditlog"
        "github.com/phrazzld/architect/internal/config"
        "github.com/phrazzld/architect/internal/logutil"
        "github.com/phrazzld/architect/internal/ratelimit"
        "github.com/phrazzld/architect/internal/runutil"
)

// Execute is the main entry point for the core application logic.
// It handles initial setup, logging, dependency initialization, and orchestration.
func Execute(
        ctx context.Context,
        cliConfig *config.CliConfig,
        logger logutil.LoggerInterface,
        auditLogger auditlog.AuditLogger,
        apiService APIService,
) (err error) <span class="cov8" title="1">{
        // Use a deferred function to ensure ExecuteEnd is always logged
        defer func() </span><span class="cov8" title="1">{
                status := "Success"
                var errorInfo *auditlog.ErrorInfo
                if err != nil </span><span class="cov8" title="1">{
                        status = "Failure"
                        errorInfo = &amp;auditlog.ErrorInfo{
                                Message: err.Error(),
                                Type:    "ExecutionError",
                        }
                }</span>

                <span class="cov8" title="1">if logErr := auditLogger.Log(auditlog.AuditEntry{
                        Timestamp: time.Now().UTC(),
                        Operation: "ExecuteEnd",
                        Status:    status,
                        Error:     errorInfo,
                        Message:   fmt.Sprintf("Execution completed with status: %s", status),
                }); logErr != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to write audit log: %v", logErr)
                }</span>
        }()

        // 1. Set up the output directory
        <span class="cov8" title="1">if err := setupOutputDirectory(cliConfig, logger); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // 2. Log the start of the Execute operation
        <span class="cov8" title="1">inputs := map[string]interface{}{
                "instructions_file": cliConfig.InstructionsFile,
                "output_dir":        cliConfig.OutputDir,
                "audit_log_file":    cliConfig.AuditLogFile,
                "format":            cliConfig.Format,
                "paths_count":       len(cliConfig.Paths),
                "include":           cliConfig.Include,
                "exclude":           cliConfig.Exclude,
                "exclude_names":     cliConfig.ExcludeNames,
                "dry_run":           cliConfig.DryRun,
                "verbose":           cliConfig.Verbose,
                "model_names":       cliConfig.ModelNames,
                "confirm_tokens":    cliConfig.ConfirmTokens,
                "log_level":         cliConfig.LogLevel,
        }

        if err := auditLogger.Log(auditlog.AuditEntry{
                Timestamp: time.Now().UTC(),
                Operation: "ExecuteStart",
                Status:    "InProgress",
                Inputs:    inputs,
                Message:   "Starting execution of architect tool",
        }); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to write audit log: %v", err)
        }</span>

        // 3. Read instructions from file
        <span class="cov8" title="1">instructionsContent, err := os.ReadFile(cliConfig.InstructionsFile)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Failed to read instructions file %s: %v", cliConfig.InstructionsFile, err)

                // Log the failure to read the instructions file to the audit log
                if logErr := auditLogger.Log(auditlog.AuditEntry{
                        Timestamp: time.Now().UTC(),
                        Operation: "ReadInstructions",
                        Status:    "Failure",
                        Inputs: map[string]interface{}{
                                "path": cliConfig.InstructionsFile,
                        },
                        Error: &amp;auditlog.ErrorInfo{
                                Message: fmt.Sprintf("Failed to read instructions file: %v", err),
                                Type:    "FileIOError",
                        },
                }); logErr != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to write audit log: %v", logErr)
                }</span>

                <span class="cov8" title="1">return fmt.Errorf("failed to read instructions file %s: %w", cliConfig.InstructionsFile, err)</span>
        }
        <span class="cov8" title="1">instructions := string(instructionsContent)
        logger.Info("Successfully read instructions from %s", cliConfig.InstructionsFile)

        // Log the successful reading of the instructions file to the audit log
        if logErr := auditLogger.Log(auditlog.AuditEntry{
                Timestamp: time.Now().UTC(),
                Operation: "ReadInstructions",
                Status:    "Success",
                Inputs: map[string]interface{}{
                        "path": cliConfig.InstructionsFile,
                },
                Outputs: map[string]interface{}{
                        "content_length": len(instructions),
                },
                Message: "Successfully read instructions file",
        }); logErr != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to write audit log: %v", logErr)
        }</span>

        // 4. Use the injected APIService

        // Create a reference client for token counting in context gathering
        <span class="cov8" title="1">referenceClient, err := apiService.InitClient(ctx, cliConfig.APIKey, cliConfig.ModelNames[0], cliConfig.APIEndpoint)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Failed to initialize reference client for context gathering: %v", err)
                return fmt.Errorf("failed to initialize reference client for context gathering: %w", err)
        }</span>
        <span class="cov8" title="1">defer referenceClient.Close()

        // Create TokenManager with the reference client
        tokenManager, tokenManagerErr := NewTokenManager(logger, auditLogger, referenceClient)
        if tokenManagerErr != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create token manager: %v", tokenManagerErr)
                return fmt.Errorf("failed to create token manager: %w", tokenManagerErr)
        }</span>

        <span class="cov8" title="1">contextGatherer := NewContextGatherer(logger, cliConfig.DryRun, tokenManager, referenceClient, auditLogger)
        fileWriter := NewFileWriter(logger, auditLogger)

        // Create rate limiter from configuration
        rateLimiter := ratelimit.NewRateLimiter(
                cliConfig.MaxConcurrentRequests,
                cliConfig.RateLimitRequestsPerMinute,
        )

        // 5. Create and run the orchestrator
        // Create adapters for the interfaces
        apiServiceAdapter := &amp;APIServiceAdapter{APIService: apiService}
        tokenManagerAdapter := &amp;TokenManagerAdapter{TokenManager: tokenManager}
        contextGathererAdapter := &amp;ContextGathererAdapter{ContextGatherer: contextGatherer}
        fileWriterAdapter := &amp;FileWriterAdapter{FileWriter: fileWriter}

        orch := orchestratorConstructor(
                apiServiceAdapter,
                contextGathererAdapter,
                tokenManagerAdapter,
                fileWriterAdapter,
                auditLogger,
                rateLimiter,
                cliConfig,
                logger,
        )

        return orch.Run(ctx, instructions)</span>
}

// Note: RunInternal has been removed as part of the refactoring.
// The Execute function now properly handles dependency injection and can be
// used directly for testing by providing appropriate mocks.

// Note: processModel, processModelConcurrently, sanitizeFilename, and saveOutputToFile functions
// have been removed as part of the refactoring. Their functionality has been moved to the
// ModelProcessor in the modelproc package.

// Orchestrator defines the interface for the orchestration component.
// This interface is defined here to allow for testing without introducing import cycles.
type Orchestrator interface {
        Run(ctx context.Context, instructions string) error
}

// orchestratorConstructor is the function used to create an Orchestrator.
// This can be overridden in tests to return a mock orchestrator.
var orchestratorConstructor = func(
        apiService APIService,
        contextGatherer interfaces.ContextGatherer,
        tokenManager interfaces.TokenManager,
        fileWriter interfaces.FileWriter,
        auditLogger auditlog.AuditLogger,
        rateLimiter *ratelimit.RateLimiter,
        config *config.CliConfig,
        logger logutil.LoggerInterface,
) Orchestrator <span class="cov0" title="0">{
        return orchestrator.NewOrchestrator(
                apiService,
                contextGatherer,
                tokenManager,
                fileWriter,
                auditLogger,
                rateLimiter,
                config,
                logger,
        )
}</span>

// setupOutputDirectory ensures that the output directory is set and exists.
// If outputDir in cliConfig is empty, it generates a unique directory name.
func setupOutputDirectory(cliConfig *config.CliConfig, logger logutil.LoggerInterface) error <span class="cov8" title="1">{
        if cliConfig.OutputDir == "" </span><span class="cov0" title="0">{
                // Generate a unique run name (e.g., "curious-panther")
                runName := runutil.GenerateRunName()
                // Get the current working directory
                cwd, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error getting current working directory: %v", err)
                        return fmt.Errorf("error getting current working directory: %w", err)
                }</span>
                // Set the output directory to the run name in the current working directory
                <span class="cov0" title="0">cliConfig.OutputDir = filepath.Join(cwd, runName)
                logger.Info("Generated output directory: %s", cliConfig.OutputDir)</span>
        }

        // Ensure the output directory exists
        <span class="cov8" title="1">if err := os.MkdirAll(cliConfig.OutputDir, 0755); err != nil </span><span class="cov8" title="1">{
                logger.Error("Error creating output directory %s: %v", cliConfig.OutputDir, err)
                return fmt.Errorf("error creating output directory %s: %w", cliConfig.OutputDir, err)
        }</span>

        <span class="cov8" title="1">logger.Info("Using output directory: %s", cliConfig.OutputDir)
        return nil</span>
}
</pre>

		<pre class="file" id="file9" style="display: none">// Package architect contains the core application logic for the architect tool
package architect

import (
        "context"
        "fmt"
        "strings"
        "time"
        "unicode"

        "github.com/phrazzld/architect/internal/auditlog"
        "github.com/phrazzld/architect/internal/fileutil"
        "github.com/phrazzld/architect/internal/gemini"
        "github.com/phrazzld/architect/internal/logutil"
)

// ContextStats holds information about processed files and context size
type ContextStats struct {
        ProcessedFilesCount int
        CharCount           int
        LineCount           int
        TokenCount          int32
        ProcessedFiles      []string
}

// GatherConfig holds parameters needed for gathering context
type GatherConfig struct {
        Paths        []string
        Include      string
        Exclude      string
        ExcludeNames string
        Format       string
        Verbose      bool
        LogLevel     logutil.LogLevel
}

// ContextGatherer defines the interface for gathering project context
type ContextGatherer interface {
        // GatherContext collects and processes files based on configuration
        GatherContext(ctx context.Context, config GatherConfig) ([]fileutil.FileMeta, *ContextStats, error)

        // DisplayDryRunInfo shows detailed information for dry run mode
        DisplayDryRunInfo(ctx context.Context, stats *ContextStats) error
}

// contextGatherer implements the ContextGatherer interface
type contextGatherer struct {
        logger       logutil.LoggerInterface
        dryRun       bool
        tokenManager TokenManager
        client       gemini.Client
        auditLogger  auditlog.AuditLogger
}

// NewContextGatherer creates a new ContextGatherer instance
func NewContextGatherer(logger logutil.LoggerInterface, dryRun bool, tokenManager TokenManager, client gemini.Client, auditLogger auditlog.AuditLogger) ContextGatherer <span class="cov8" title="1">{
        return &amp;contextGatherer{
                logger:       logger,
                dryRun:       dryRun,
                tokenManager: tokenManager,
                client:       client,
                auditLogger:  auditLogger,
        }
}</span>

// estimateTokenCount counts tokens simply by whitespace boundaries.
// This is kept as a fallback method in case the API token counting fails.
func estimateTokenCount(text string) int <span class="cov0" title="0">{
        count := 0
        inToken := false
        for _, r := range text </span><span class="cov0" title="0">{
                if unicode.IsSpace(r) </span><span class="cov0" title="0">{
                        if inToken </span><span class="cov0" title="0">{
                                count++
                                inToken = false
                        }</span>
                } else<span class="cov0" title="0"> {
                        inToken = true
                }</span>
        }
        <span class="cov0" title="0">if inToken </span><span class="cov0" title="0">{
                count++
        }</span>
        <span class="cov0" title="0">return count</span>
}

// GatherContext collects and processes files based on configuration
func (cg *contextGatherer) GatherContext(ctx context.Context, config GatherConfig) ([]fileutil.FileMeta, *ContextStats, error) <span class="cov8" title="1">{
        // Log start of context gathering operation to audit log
        gatherStartTime := time.Now()
        if logErr := cg.auditLogger.Log(auditlog.AuditEntry{
                Timestamp: gatherStartTime,
                Operation: "GatherContextStart",
                Status:    "InProgress",
                Inputs: map[string]interface{}{
                        "paths":         config.Paths,
                        "include":       config.Include,
                        "exclude":       config.Exclude,
                        "exclude_names": config.ExcludeNames,
                        "format":        config.Format,
                },
                Message: "Starting to gather project context files",
        }); logErr != nil </span><span class="cov0" title="0">{
                cg.logger.Error("Failed to write audit log: %v", logErr)
        }</span>

        // Log appropriate message based on mode
        <span class="cov8" title="1">if cg.dryRun </span><span class="cov8" title="1">{
                cg.logger.Info("Dry run mode: gathering files that would be included in context...")
                cg.logger.Debug("Processing files with include filters: %v", config.Include)
                cg.logger.Debug("Processing files with exclude filters: %v", config.Exclude)
                cg.logger.Debug("Processing files with exclude names: %v", config.ExcludeNames)
                cg.logger.Debug("Paths being processed: %v", config.Paths)
        }</span> else<span class="cov8" title="1"> {
                cg.logger.Info("Gathering project context from %d paths...", len(config.Paths))
                cg.logger.Debug("Include filters: %v", config.Include)
                cg.logger.Debug("Exclude filters: %v", config.Exclude)
                cg.logger.Debug("Exclude names: %v", config.ExcludeNames)
                cg.logger.Debug("Paths being processed: %v", config.Paths)
        }</span>

        // Setup file processing configuration
        <span class="cov8" title="1">fileConfig := fileutil.NewConfig(config.Verbose, config.Include, config.Exclude, config.ExcludeNames, config.Format, cg.logger)

        // Initialize ContextStats
        stats := &amp;ContextStats{
                ProcessedFiles: make([]string, 0),
        }

        // Track processed files for dry run mode
        if cg.dryRun </span><span class="cov8" title="1">{
                collector := func(path string) </span><span class="cov8" title="1">{
                        stats.ProcessedFiles = append(stats.ProcessedFiles, path)
                }</span>
                <span class="cov8" title="1">fileConfig.SetFileCollector(collector)</span>
        }

        // Gather project context
        <span class="cov8" title="1">contextFiles, processedFilesCount, err := fileutil.GatherProjectContext(config.Paths, fileConfig)

        // Calculate duration in milliseconds
        gatherDurationMs := time.Since(gatherStartTime).Milliseconds()

        if err != nil </span><span class="cov0" title="0">{
                cg.logger.Error("Failed during project context gathering: %v", err)

                // Log the failure of context gathering to audit log
                if logErr := cg.auditLogger.Log(auditlog.AuditEntry{
                        Timestamp:  time.Now().UTC(),
                        Operation:  "GatherContextEnd",
                        Status:     "Failure",
                        DurationMs: &amp;gatherDurationMs,
                        Inputs: map[string]interface{}{
                                "paths":         config.Paths,
                                "include":       config.Include,
                                "exclude":       config.Exclude,
                                "exclude_names": config.ExcludeNames,
                        },
                        Error: &amp;auditlog.ErrorInfo{
                                Message: fmt.Sprintf("Failed to gather project context: %v", err),
                                Type:    "ContextGatheringError",
                        },
                }); logErr != nil </span><span class="cov0" title="0">{
                        cg.logger.Error("Failed to write audit log: %v", logErr)
                }</span>

                <span class="cov0" title="0">return nil, nil, fmt.Errorf("failed during project context gathering: %w", err)</span>
        }

        // Set the processed files count in stats
        <span class="cov8" title="1">stats.ProcessedFilesCount = processedFilesCount

        // Log warning if no files were processed
        if processedFilesCount == 0 </span><span class="cov8" title="1">{
                cg.logger.Warn("No files were processed for context. Check paths and filters.")
                return contextFiles, stats, nil
        }</span>

        // Create a combined string for token counting
        <span class="cov8" title="1">var combinedContent strings.Builder
        for _, file := range contextFiles </span><span class="cov8" title="1">{
                combinedContent.WriteString(file.Content)
                combinedContent.WriteString("\n")
        }</span>
        <span class="cov8" title="1">projectContext := combinedContent.String()

        // Calculate basic statistics
        cg.logger.Info("Calculating token statistics for %d processed files...", stats.ProcessedFilesCount)
        startTime := time.Now()

        // Calculate character and line counts directly
        charCount := len(projectContext)
        lineCount := strings.Count(projectContext, "\n") + 1

        // Use token manager for token counting via the gemini client
        tokenCount := 0
        if cg.client != nil </span><span class="cov8" title="1">{
                // Use the gemini client to count tokens
                tokenResult, err := cg.client.CountTokens(ctx, projectContext)
                if err != nil </span><span class="cov0" title="0">{
                        cg.logger.Warn("Failed to count tokens accurately: %v. Using estimation instead.", err)
                        // Fall back to basic statistics using internal estimation
                        tokenCount = estimateTokenCount(projectContext)
                }</span> else<span class="cov8" title="1"> {
                        tokenCount = int(tokenResult.Total)
                        cg.logger.Debug("Accurate token count: %d tokens", tokenCount)
                }</span>
        } else<span class="cov0" title="0"> {
                // Fall back to basic statistics if no client
                tokenCount = estimateTokenCount(projectContext)
                cg.logger.Debug("Using estimated token count: %d tokens", tokenCount)
        }</span>

        <span class="cov8" title="1">duration := time.Since(startTime)
        cg.logger.Debug("Token calculation completed in %v", duration)

        // Store statistics in the stats struct
        stats.CharCount = charCount
        stats.LineCount = lineCount
        stats.TokenCount = int32(tokenCount)

        // Handle output based on mode
        if processedFilesCount &gt; 0 </span><span class="cov8" title="1">{
                cg.logger.Info("Context gathered: %d files, %d lines, %d chars, %d tokens",
                        processedFilesCount, lineCount, charCount, tokenCount)

                // Additional detailed debug information if needed
                if config.LogLevel == logutil.DebugLevel &amp;&amp; !cg.dryRun </span><span class="cov8" title="1">{
                        cg.logger.Debug("Context details: files=%d, lines=%d, chars=%d, tokens=%d",
                                processedFilesCount, lineCount, charCount, tokenCount)
                }</span>
        }

        // Log the successful completion of context gathering to audit log
        <span class="cov8" title="1">if logErr := cg.auditLogger.Log(auditlog.AuditEntry{
                Timestamp:  time.Now().UTC(),
                Operation:  "GatherContextEnd",
                Status:     "Success",
                DurationMs: &amp;gatherDurationMs,
                Inputs: map[string]interface{}{
                        "paths":         config.Paths,
                        "include":       config.Include,
                        "exclude":       config.Exclude,
                        "exclude_names": config.ExcludeNames,
                },
                Outputs: map[string]interface{}{
                        "processed_files_count": stats.ProcessedFilesCount,
                        "char_count":            stats.CharCount,
                        "line_count":            stats.LineCount,
                        "token_count":           stats.TokenCount,
                        "files_count":           len(contextFiles),
                },
                Message: "Successfully gathered project context files",
        }); logErr != nil </span><span class="cov0" title="0">{
                cg.logger.Error("Failed to write audit log: %v", logErr)
        }</span>

        <span class="cov8" title="1">return contextFiles, stats, nil</span>
}

// DisplayDryRunInfo shows detailed information for dry run mode
func (cg *contextGatherer) DisplayDryRunInfo(ctx context.Context, stats *ContextStats) error <span class="cov8" title="1">{
        cg.logger.Info("Files that would be included in context:")
        if stats.ProcessedFilesCount == 0 </span><span class="cov8" title="1">{
                cg.logger.Info("  No files matched the current filters.")
        }</span> else<span class="cov8" title="1"> {
                for i, file := range stats.ProcessedFiles </span><span class="cov8" title="1">{
                        cg.logger.Info("  %d. %s", i+1, file)
                }</span>
        }

        <span class="cov8" title="1">cg.logger.Info("Context statistics:")
        cg.logger.Info("  Files: %d", stats.ProcessedFilesCount)
        cg.logger.Info("  Lines: %d", stats.LineCount)
        cg.logger.Info("  Characters: %d", stats.CharCount)
        cg.logger.Info("  Tokens: %d", stats.TokenCount)

        // Get model info for token limit comparison
        modelInfo, modelInfoErr := cg.client.GetModelInfo(ctx)
        if modelInfoErr != nil </span><span class="cov8" title="1">{
                // Check if it's an API error with enhanced details
                if apiErr, ok := gemini.IsAPIError(modelInfoErr); ok </span><span class="cov0" title="0">{
                        cg.logger.Warn("Could not get model information: %s", apiErr.Message)
                        // Only show detailed info in debug logs
                        cg.logger.Debug("Model info error details: %s", apiErr.DebugInfo())
                }</span> else<span class="cov8" title="1"> {
                        cg.logger.Warn("Could not get model information: %v", modelInfoErr)
                }</span>
                // Continue - this is not a fatal error for dry run mode
        } else<span class="cov8" title="1"> {
                // Convert to int32 for comparison with model limits
                tokenCountInt32 := stats.TokenCount
                percentOfLimit := float64(tokenCountInt32) / float64(modelInfo.InputTokenLimit) * 100
                cg.logger.Info("Token usage: %d / %d (%.1f%% of model's limit)",
                        tokenCountInt32, modelInfo.InputTokenLimit, percentOfLimit)

                // Check if token count exceeds limit
                if tokenCountInt32 &gt; modelInfo.InputTokenLimit </span><span class="cov8" title="1">{
                        cg.logger.Error("WARNING: Token count exceeds model's limit by %d tokens",
                                tokenCountInt32-modelInfo.InputTokenLimit)
                        cg.logger.Error("Try reducing context by using --include, --exclude, or --exclude-names flags")
                }</span> else<span class="cov8" title="1"> {
                        cg.logger.Info("Context size is within the model's token limit")
                }</span>
        }

        <span class="cov8" title="1">cg.logger.Info("Dry run completed successfully.")
        cg.logger.Info("To generate content, run without the --dry-run flag.")

        return nil</span>
}
</pre>

		<pre class="file" id="file10" style="display: none">// Package architect contains the core application logic for the architect tool.
// This file implements the FileWriter interface for saving generated content to files,
// handling file creation, directory resolution, and related audit logging.
// The FileWriter component is responsible for the final output step in the workflow,
// writing the generated plan content to disk with proper error handling.
package architect

import (
        "fmt"
        "os"
        "path/filepath"
        "time"

        "github.com/phrazzld/architect/internal/auditlog"
        "github.com/phrazzld/architect/internal/logutil"
)

// FileWriter defines the interface for file output writing
type FileWriter interface {
        // SaveToFile writes content to the specified file
        SaveToFile(content, outputFile string) error
}

// fileWriter implements the FileWriter interface
type fileWriter struct {
        logger      logutil.LoggerInterface
        auditLogger auditlog.AuditLogger
}

// NewFileWriter creates a new FileWriter instance with the specified dependencies.
// It injects the required logger and audit logger to ensure proper output
// handling and audit trail generation during file operations.
func NewFileWriter(logger logutil.LoggerInterface, auditLogger auditlog.AuditLogger) FileWriter <span class="cov8" title="1">{
        return &amp;fileWriter{
                logger:      logger,
                auditLogger: auditLogger,
        }
}</span>

// SaveToFile writes the content to the specified file and handles audit logging.
// It ensures proper directory existence, resolves relative paths to absolute paths,
// and generates appropriate audit log entries for the operation's start and completion.
// The method handles errors gracefully and ensures they are properly logged.
func (fw *fileWriter) SaveToFile(content, outputFile string) error <span class="cov8" title="1">{
        // Log the start of output saving
        saveStartTime := time.Now()
        if logErr := fw.auditLogger.Log(auditlog.AuditEntry{
                Timestamp: saveStartTime,
                Operation: "SaveOutputStart",
                Status:    "InProgress",
                Inputs: map[string]interface{}{
                        "output_path":    outputFile,
                        "content_length": len(content),
                },
                Message: "Starting to save output to file",
        }); logErr != nil </span><span class="cov0" title="0">{
                fw.logger.Error("Failed to write audit log: %v", logErr)
        }</span>

        // Ensure output path is absolute
        <span class="cov8" title="1">outputPath := outputFile
        if !filepath.IsAbs(outputPath) </span><span class="cov8" title="1">{
                cwd, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        fw.logger.Error("Error getting current working directory: %v", err)

                        // Log failure to save output
                        saveDurationMs := time.Since(saveStartTime).Milliseconds()
                        if logErr := fw.auditLogger.Log(auditlog.AuditEntry{
                                Timestamp:  time.Now().UTC(),
                                Operation:  "SaveOutputEnd",
                                Status:     "Failure",
                                DurationMs: &amp;saveDurationMs,
                                Inputs: map[string]interface{}{
                                        "output_path": outputFile,
                                },
                                Error: &amp;auditlog.ErrorInfo{
                                        Message: fmt.Sprintf("Error getting current working directory: %v", err),
                                        Type:    "FileIOError",
                                },
                                Message: "Failed to save output to file",
                        }); logErr != nil </span><span class="cov0" title="0">{
                                fw.logger.Error("Failed to write audit log: %v", logErr)
                        }</span>

                        <span class="cov0" title="0">return fmt.Errorf("error getting current working directory: %w", err)</span>
                }
                <span class="cov8" title="1">outputPath = filepath.Join(cwd, outputPath)</span>
        }

        // Ensure the output directory exists
        <span class="cov8" title="1">outputDir := filepath.Dir(outputPath)
        if err := os.MkdirAll(outputDir, 0755); err != nil </span><span class="cov0" title="0">{
                fw.logger.Error("Error creating output directory %s: %v", outputDir, err)

                // Log failure to save output
                saveDurationMs := time.Since(saveStartTime).Milliseconds()
                if logErr := fw.auditLogger.Log(auditlog.AuditEntry{
                        Timestamp:  time.Now().UTC(),
                        Operation:  "SaveOutputEnd",
                        Status:     "Failure",
                        DurationMs: &amp;saveDurationMs,
                        Inputs: map[string]interface{}{
                                "output_path": outputPath,
                        },
                        Error: &amp;auditlog.ErrorInfo{
                                Message: fmt.Sprintf("Error creating output directory %s: %v", outputDir, err),
                                Type:    "FileIOError",
                        },
                        Message: "Failed to save output to file",
                }); logErr != nil </span><span class="cov0" title="0">{
                        fw.logger.Error("Failed to write audit log: %v", logErr)
                }</span>

                <span class="cov0" title="0">return fmt.Errorf("error creating output directory %s: %w", outputDir, err)</span>
        }

        // Write to file
        <span class="cov8" title="1">fw.logger.Info("Writing to file %s...", outputPath)
        err := os.WriteFile(outputPath, []byte(content), 0644)

        // Calculate duration in milliseconds
        saveDurationMs := time.Since(saveStartTime).Milliseconds()

        if err != nil </span><span class="cov0" title="0">{
                fw.logger.Error("Error writing to file %s: %v", outputPath, err)

                // Log failure to save output
                if logErr := fw.auditLogger.Log(auditlog.AuditEntry{
                        Timestamp:  time.Now().UTC(),
                        Operation:  "SaveOutputEnd",
                        Status:     "Failure",
                        DurationMs: &amp;saveDurationMs,
                        Inputs: map[string]interface{}{
                                "output_path": outputPath,
                        },
                        Error: &amp;auditlog.ErrorInfo{
                                Message: fmt.Sprintf("Error writing to file %s: %v", outputPath, err),
                                Type:    "FileIOError",
                        },
                        Message: "Failed to save output to file",
                }); logErr != nil </span><span class="cov0" title="0">{
                        fw.logger.Error("Failed to write audit log: %v", logErr)
                }</span>

                <span class="cov0" title="0">return fmt.Errorf("error writing to file %s: %w", outputPath, err)</span>
        }

        // Log successful saving of output
        <span class="cov8" title="1">if logErr := fw.auditLogger.Log(auditlog.AuditEntry{
                Timestamp:  time.Now().UTC(),
                Operation:  "SaveOutputEnd",
                Status:     "Success",
                DurationMs: &amp;saveDurationMs,
                Inputs: map[string]interface{}{
                        "output_path": outputPath,
                },
                Outputs: map[string]interface{}{
                        "content_length": len(content),
                },
                Message: "Successfully saved output to file",
        }); logErr != nil </span><span class="cov0" title="0">{
                fw.logger.Error("Failed to write audit log: %v", logErr)
        }</span>

        <span class="cov8" title="1">fw.logger.Info("Successfully saved to %s", outputPath)
        return nil</span>
}
</pre>

		<pre class="file" id="file11" style="display: none">// Package modelproc provides model processing functionality for the architect tool.
// It encapsulates the logic for interacting with AI models, managing tokens,
// writing outputs, and logging operations.
package modelproc

import (
        "context"
        "fmt"
        "path/filepath"
        "strings"
        "time"

        "github.com/phrazzld/architect/internal/auditlog"
        "github.com/phrazzld/architect/internal/config"
        "github.com/phrazzld/architect/internal/gemini"
        "github.com/phrazzld/architect/internal/logutil"
)

// APIService defines the interface for API-related operations
type APIService interface {
        // InitClient initializes and returns a Gemini client
        InitClient(ctx context.Context, apiKey, modelName, apiEndpoint string) (gemini.Client, error)

        // ProcessResponse processes the API response and extracts content
        ProcessResponse(result *gemini.GenerationResult) (string, error)

        // IsEmptyResponseError checks if an error is related to empty API responses
        IsEmptyResponseError(err error) bool

        // IsSafetyBlockedError checks if an error is related to safety filters
        IsSafetyBlockedError(err error) bool

        // GetErrorDetails extracts detailed information from an error
        GetErrorDetails(err error) string
}

// TokenResult holds information about token counts and limits
type TokenResult struct {
        TokenCount   int32
        InputLimit   int32
        ExceedsLimit bool
        LimitError   string
        Percentage   float64
}

// TokenManager defines the interface for token counting and management
type TokenManager interface {
        // GetTokenInfo retrieves token count information and checks limits
        GetTokenInfo(ctx context.Context, prompt string) (*TokenResult, error)

        // CheckTokenLimit verifies the prompt doesn't exceed the model's token limit
        CheckTokenLimit(ctx context.Context, prompt string) error

        // PromptForConfirmation asks for user confirmation to proceed if token count exceeds threshold
        PromptForConfirmation(tokenCount int32, threshold int) bool
}

// tokenManager provides a local implementation of TokenManager to avoid import cycles
type tokenManager struct {
        logger      logutil.LoggerInterface
        auditLogger auditlog.AuditLogger
        client      gemini.Client
}

// NewTokenManagerWithClient creates a new tokenManager instance with a specific client.
// This is defined as a variable to allow it to be mocked in tests.
var NewTokenManagerWithClient = func(logger logutil.LoggerInterface, auditLogger auditlog.AuditLogger, client gemini.Client) TokenManager <span class="cov8" title="1">{
        return &amp;tokenManager{
                logger:      logger,
                auditLogger: auditLogger,
                client:      client,
        }
}</span>

// GetTokenInfo implements TokenManager.GetTokenInfo
func (tm *tokenManager) GetTokenInfo(ctx context.Context, prompt string) (*TokenResult, error) <span class="cov8" title="1">{
        // Get the model name from the injected client
        modelName := tm.client.GetModelName()

        // Log the start of token checking
        checkStartTime := time.Now()
        if logErr := tm.auditLogger.Log(auditlog.AuditEntry{
                Timestamp: checkStartTime,
                Operation: "CheckTokensStart",
                Status:    "InProgress",
                Inputs: map[string]interface{}{
                        "prompt_length": len(prompt),
                        "model_name":    modelName,
                },
                Message: "Starting token count check for model " + modelName,
        }); logErr != nil </span><span class="cov0" title="0">{
                tm.logger.Error("Failed to write audit log: %v", logErr)
        }</span>

        // Create result structure
        <span class="cov8" title="1">result := &amp;TokenResult{
                ExceedsLimit: false,
        }

        // Get model information (limits)
        modelInfo, err := tm.client.GetModelInfo(ctx)
        if err != nil </span><span class="cov0" title="0">{
                // Pass through API errors directly for better error messages
                if apiErr, ok := gemini.IsAPIError(err); ok </span><span class="cov0" title="0">{
                        // Log the token check failure
                        if logErr := tm.auditLogger.Log(auditlog.AuditEntry{
                                Timestamp: time.Now().UTC(),
                                Operation: "CheckTokens",
                                Status:    "Failure",
                                Inputs: map[string]interface{}{
                                        "prompt_length": len(prompt),
                                        "model_name":    modelName,
                                },
                                Error: &amp;auditlog.ErrorInfo{
                                        Message: apiErr.Message,
                                        Type:    "APIError",
                                },
                                Message: "Token count check failed for model " + modelName,
                        }); logErr != nil </span><span class="cov0" title="0">{
                                tm.logger.Error("Failed to write audit log: %v", logErr)
                        }</span>

                        <span class="cov0" title="0">return nil, apiErr</span>
                }

                // Log the token check failure for other errors
                <span class="cov0" title="0">if logErr := tm.auditLogger.Log(auditlog.AuditEntry{
                        Timestamp: time.Now().UTC(),
                        Operation: "CheckTokens",
                        Status:    "Failure",
                        Inputs: map[string]interface{}{
                                "prompt_length": len(prompt),
                                "model_name":    modelName,
                        },
                        Error: &amp;auditlog.ErrorInfo{
                                Message: fmt.Sprintf("Failed to get model info: %v", err),
                                Type:    "TokenCheckError",
                        },
                        Message: "Token count check failed for model " + modelName,
                }); logErr != nil </span><span class="cov0" title="0">{
                        tm.logger.Error("Failed to write audit log: %v", logErr)
                }</span>

                // Wrap other errors
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get model info for token limit check: %w", err)</span>
        }

        // Store input limit
        <span class="cov8" title="1">result.InputLimit = modelInfo.InputTokenLimit

        // Count tokens in the prompt
        tokenResult, err := tm.client.CountTokens(ctx, prompt)
        if err != nil </span><span class="cov0" title="0">{
                // Pass through API errors directly for better error messages
                if apiErr, ok := gemini.IsAPIError(err); ok </span><span class="cov0" title="0">{
                        // Log the token check failure
                        if logErr := tm.auditLogger.Log(auditlog.AuditEntry{
                                Timestamp: time.Now().UTC(),
                                Operation: "CheckTokens",
                                Status:    "Failure",
                                Inputs: map[string]interface{}{
                                        "prompt_length": len(prompt),
                                        "model_name":    modelName,
                                },
                                Error: &amp;auditlog.ErrorInfo{
                                        Message: apiErr.Message,
                                        Type:    "APIError",
                                },
                                Message: "Token count check failed for model " + modelName,
                        }); logErr != nil </span><span class="cov0" title="0">{
                                tm.logger.Error("Failed to write audit log: %v", logErr)
                        }</span>

                        <span class="cov0" title="0">return nil, apiErr</span>
                }

                // Log the token check failure for other errors
                <span class="cov0" title="0">if logErr := tm.auditLogger.Log(auditlog.AuditEntry{
                        Timestamp: time.Now().UTC(),
                        Operation: "CheckTokens",
                        Status:    "Failure",
                        Inputs: map[string]interface{}{
                                "prompt_length": len(prompt),
                                "model_name":    modelName,
                        },
                        Error: &amp;auditlog.ErrorInfo{
                                Message: fmt.Sprintf("Failed to count tokens: %v", err),
                                Type:    "TokenCheckError",
                        },
                        Message: "Token count check failed for model " + modelName,
                }); logErr != nil </span><span class="cov0" title="0">{
                        tm.logger.Error("Failed to write audit log: %v", logErr)
                }</span>

                // Wrap other errors
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to count tokens for token limit check: %w", err)</span>
        }

        // Store token count
        <span class="cov8" title="1">result.TokenCount = tokenResult.Total

        // Calculate percentage of limit
        result.Percentage = float64(result.TokenCount) / float64(result.InputLimit) * 100

        // Log token usage information
        tm.logger.Debug("Token usage: %d / %d (%.1f%%)",
                result.TokenCount,
                result.InputLimit,
                result.Percentage)

        // Check if the prompt exceeds the token limit
        if result.TokenCount &gt; result.InputLimit </span><span class="cov8" title="1">{
                result.ExceedsLimit = true
                result.LimitError = fmt.Sprintf("prompt exceeds token limit (%d tokens &gt; %d token limit)",
                        result.TokenCount, result.InputLimit)

                // Log the token limit exceeded case
                if logErr := tm.auditLogger.Log(auditlog.AuditEntry{
                        Timestamp: time.Now().UTC(),
                        Operation: "CheckTokens",
                        Status:    "Failure",
                        Inputs: map[string]interface{}{
                                "prompt_length": len(prompt),
                                "model_name":    modelName,
                        },
                        TokenCounts: &amp;auditlog.TokenCountInfo{
                                PromptTokens: result.TokenCount,
                                TotalTokens:  result.TokenCount,
                                Limit:        result.InputLimit,
                        },
                        Error: &amp;auditlog.ErrorInfo{
                                Message: result.LimitError,
                                Type:    "TokenLimitExceededError",
                        },
                        Message: "Token limit exceeded for model " + modelName,
                }); logErr != nil </span><span class="cov0" title="0">{
                        tm.logger.Error("Failed to write audit log: %v", logErr)
                }</span>
        } else<span class="cov8" title="1"> {
                // Log the successful token check
                if logErr := tm.auditLogger.Log(auditlog.AuditEntry{
                        Timestamp: time.Now().UTC(),
                        Operation: "CheckTokens",
                        Status:    "Success",
                        Inputs: map[string]interface{}{
                                "prompt_length": len(prompt),
                                "model_name":    modelName,
                        },
                        Outputs: map[string]interface{}{
                                "percentage": result.Percentage,
                        },
                        TokenCounts: &amp;auditlog.TokenCountInfo{
                                PromptTokens: result.TokenCount,
                                TotalTokens:  result.TokenCount,
                                Limit:        result.InputLimit,
                        },
                        Message: fmt.Sprintf("Token check passed for model %s: %d / %d tokens (%.1f%% of limit)",
                                modelName, result.TokenCount, result.InputLimit, result.Percentage),
                }); logErr != nil </span><span class="cov0" title="0">{
                        tm.logger.Error("Failed to write audit log: %v", logErr)
                }</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// CheckTokenLimit implements TokenManager.CheckTokenLimit
func (tm *tokenManager) CheckTokenLimit(ctx context.Context, prompt string) error <span class="cov0" title="0">{
        tokenInfo, err := tm.GetTokenInfo(ctx, prompt)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if tokenInfo.ExceedsLimit </span><span class="cov0" title="0">{
                return fmt.Errorf(tokenInfo.LimitError)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// PromptForConfirmation implements TokenManager.PromptForConfirmation
func (tm *tokenManager) PromptForConfirmation(tokenCount int32, threshold int) bool <span class="cov8" title="1">{
        if threshold &lt;= 0 || int32(threshold) &gt; tokenCount </span><span class="cov8" title="1">{
                // No confirmation needed if threshold is disabled (0) or token count is below threshold
                tm.logger.Debug("No confirmation needed: threshold=%d, tokenCount=%d", threshold, tokenCount)
                return true
        }</span>

        <span class="cov0" title="0">tm.logger.Info("Token count (%d) exceeds confirmation threshold (%d).", tokenCount, threshold)
        tm.logger.Info("Do you want to proceed with the API call? [y/N]: ")

        // Implementation omitted for brevity - defaults to always returning true in this context
        // The actual confirmation would be handled in the top-level TokenManager
        return true</span>
}

// FileWriter defines the interface for file output writing
type FileWriter interface {
        // SaveToFile writes content to the specified file
        SaveToFile(content, outputFile string) error
}

// ModelProcessor handles all interactions with AI models including initialization,
// token management, request generation, response processing, and output handling.
type ModelProcessor struct {
        // Dependencies
        apiService   APIService
        tokenManager TokenManager
        fileWriter   FileWriter
        auditLogger  auditlog.AuditLogger
        logger       logutil.LoggerInterface
        config       *config.CliConfig
}

// NewProcessor creates a new ModelProcessor with all required dependencies.
// Note: The tokenManager parameter is ignored as each model needs its own TokenManager
// with the appropriate client. TokenManagers are created per-model in the Process method.
// This is necessary to avoid import cycles and to handle the multi-model architecture.
func NewProcessor(
        apiService APIService,
        _ TokenManager, // Ignored - Token managers are created per-model in Process
        fileWriter FileWriter,
        auditLogger auditlog.AuditLogger,
        logger logutil.LoggerInterface,
        config *config.CliConfig,
) *ModelProcessor <span class="cov8" title="1">{
        return &amp;ModelProcessor{
                apiService:   apiService,
                tokenManager: nil, // Not used - each model gets its own TokenManager in Process
                fileWriter:   fileWriter,
                auditLogger:  auditLogger,
                logger:       logger,
                config:       config,
        }
}</span>

// Process handles the entire model processing workflow for a single model.
// It implements the logic from the previous processModel/processModelConcurrently functions,
// including initialization, token checking, generation, response processing, and output saving.
func (p *ModelProcessor) Process(ctx context.Context, modelName string, stitchedPrompt string) error <span class="cov8" title="1">{
        p.logger.Info("Processing model: %s", modelName)

        // 1. Initialize model-specific client
        geminiClient, err := p.apiService.InitClient(ctx, p.config.APIKey, modelName, p.config.APIEndpoint)
        if err != nil </span><span class="cov8" title="1">{
                errorDetails := p.apiService.GetErrorDetails(err)
                if apiErr, ok := gemini.IsAPIError(err); ok </span><span class="cov0" title="0">{
                        p.logger.Error("Error creating Gemini client for model %s: %s", modelName, apiErr.Message)
                        if apiErr.Suggestion != "" </span><span class="cov0" title="0">{
                                p.logger.Error("Suggestion: %s", apiErr.Suggestion)
                        }</span>
                        <span class="cov0" title="0">if p.config.LogLevel == logutil.DebugLevel </span><span class="cov0" title="0">{
                                p.logger.Debug("Error details: %s", apiErr.DebugInfo())
                        }</span>
                } else<span class="cov8" title="1"> {
                        p.logger.Error("Error creating Gemini client for model %s: %s", modelName, errorDetails)
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("failed to initialize API client for model %s: %w", modelName, err)</span>
        }

        // BUGFIX: Ensure geminiClient is not nil before attempting to close it
        // CAUSE: There was a race condition in tests where geminiClient could be nil
        //        when concurrent tests interact with rate limiting, leading to nil pointer dereference
        // FIX: Add safety check in defer to prevent a panic if client is nil for any reason
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if geminiClient != nil </span><span class="cov8" title="1">{
                        geminiClient.Close()
                }</span>
        }()

        // 2. Check token limits for this model
        <span class="cov8" title="1">p.logger.Info("Checking token limits for model %s...", modelName)

        // We need to create a TokenManager with the client, but we can't import architect directly
        // without causing an import cycle. For now, use the per-model client in method calls
        // TODO: Refactor this to use a proper factory pattern

        // Note: We rely on the TokenManager to handle all audit logging for token checking operations.
        // The audit logs for CheckTokensStart, CheckTokens Success/Failure are managed by the TokenManager
        // implementation and should not be duplicated here.

        // Using direct TokenManager creation without importing architect package
        // Implementation-specific detail to avoid import cycle
        tokenInfo, err := NewTokenManagerWithClient(p.logger, p.auditLogger, geminiClient).GetTokenInfo(ctx, stitchedPrompt)
        if err != nil </span><span class="cov8" title="1">{
                p.logger.Error("Token count check failed for model %s", modelName)

                // Check if it's an API error with enhanced details
                if apiErr, ok := gemini.IsAPIError(err); ok </span><span class="cov0" title="0">{
                        p.logger.Error("Token count check failed for model %s: %s", modelName, apiErr.Message)
                        if apiErr.Suggestion != "" </span><span class="cov0" title="0">{
                                p.logger.Error("Suggestion: %s", apiErr.Suggestion)
                        }</span>
                        <span class="cov0" title="0">p.logger.Debug("Error details: %s", apiErr.DebugInfo())</span>
                } else<span class="cov8" title="1"> {
                        p.logger.Error("Token count check failed for model %s: %v", modelName, err)
                        p.logger.Error("Try reducing context by using --include, --exclude, or --exclude-names flags")
                }</span>

                <span class="cov8" title="1">return fmt.Errorf("token count check failed for model %s: %w", modelName, err)</span>
        }

        // If token limit is exceeded, abort
        <span class="cov8" title="1">if tokenInfo.ExceedsLimit </span><span class="cov8" title="1">{
                p.logger.Error("Token limit exceeded for model %s", modelName)
                p.logger.Error("Token limit exceeded: %s", tokenInfo.LimitError)
                p.logger.Error("Try reducing context by using --include, --exclude, or --exclude-names flags")

                return fmt.Errorf("token limit exceeded for model %s: %s", modelName, tokenInfo.LimitError)
        }</span>

        // Prompt for confirmation if token count exceeds threshold
        // Create a token manager for this model if needed (same one used for token count)
        <span class="cov8" title="1">tokenManager := NewTokenManagerWithClient(p.logger, p.auditLogger, geminiClient)
        if !tokenManager.PromptForConfirmation(tokenInfo.TokenCount, p.config.ConfirmTokens) </span><span class="cov8" title="1">{
                p.logger.Info("Operation cancelled by user due to token count.")
                return nil
        }</span>

        <span class="cov8" title="1">p.logger.Info("Token check passed for model %s: %d / %d tokens (%.1f%% of limit)",
                modelName, tokenInfo.TokenCount, tokenInfo.InputLimit, tokenInfo.Percentage)

        // 3. Generate content with this model
        p.logger.Info("Generating output with model %s (Temperature: %.2f, MaxOutputTokens: %d)...",
                modelName,
                geminiClient.GetTemperature(),
                geminiClient.GetMaxOutputTokens())

        // Log the start of content generation
        generateStartTime := time.Now()
        if logErr := p.auditLogger.Log(auditlog.AuditEntry{
                Timestamp: generateStartTime,
                Operation: "GenerateContentStart",
                Status:    "InProgress",
                Inputs: map[string]interface{}{
                        "model_name":    modelName,
                        "prompt_length": len(stitchedPrompt),
                },
                Message: "Starting content generation with Gemini model " + modelName,
        }); logErr != nil </span><span class="cov0" title="0">{
                p.logger.Error("Failed to write audit log: %v", logErr)
        }</span>

        <span class="cov8" title="1">result, err := geminiClient.GenerateContent(ctx, stitchedPrompt)

        // Calculate duration in milliseconds
        generateDurationMs := time.Since(generateStartTime).Milliseconds()

        if err != nil </span><span class="cov8" title="1">{
                p.logger.Error("Generation failed for model %s", modelName)

                var errorType string
                var errorMessage string

                // Check if it's an API error with enhanced details
                if apiErr, ok := gemini.IsAPIError(err); ok </span><span class="cov0" title="0">{
                        p.logger.Error("Error generating content with model %s: %s", modelName, apiErr.Message)
                        if apiErr.Suggestion != "" </span><span class="cov0" title="0">{
                                p.logger.Error("Suggestion: %s", apiErr.Suggestion)
                        }</span>
                        <span class="cov0" title="0">p.logger.Debug("Error details: %s", apiErr.DebugInfo())
                        errorType = "APIError"
                        errorMessage = apiErr.Message</span>
                } else<span class="cov8" title="1"> {
                        p.logger.Error("Error generating content with model %s: %v (Current token count: %d)", modelName, err, tokenInfo.TokenCount)
                        errorType = "ContentGenerationError"
                        errorMessage = fmt.Sprintf("Failed to generate content with model %s: %v", modelName, err)
                }</span>

                // Log the content generation failure
                <span class="cov8" title="1">if logErr := p.auditLogger.Log(auditlog.AuditEntry{
                        Timestamp:  time.Now().UTC(),
                        Operation:  "GenerateContentEnd",
                        Status:     "Failure",
                        DurationMs: &amp;generateDurationMs,
                        Inputs: map[string]interface{}{
                                "model_name":    modelName,
                                "prompt_length": len(stitchedPrompt),
                        },
                        Error: &amp;auditlog.ErrorInfo{
                                Message: errorMessage,
                                Type:    errorType,
                        },
                        Message: "Content generation failed for model " + modelName,
                }); logErr != nil </span><span class="cov0" title="0">{
                        p.logger.Error("Failed to write audit log: %v", logErr)
                }</span>

                <span class="cov8" title="1">return fmt.Errorf("output generation failed for model %s: %w", modelName, err)</span>
        }

        // Log successful content generation
        <span class="cov8" title="1">if logErr := p.auditLogger.Log(auditlog.AuditEntry{
                Timestamp:  time.Now().UTC(),
                Operation:  "GenerateContentEnd",
                Status:     "Success",
                DurationMs: &amp;generateDurationMs,
                Inputs: map[string]interface{}{
                        "model_name":    modelName,
                        "prompt_length": len(stitchedPrompt),
                },
                Outputs: map[string]interface{}{
                        "finish_reason":      result.FinishReason,
                        "has_safety_ratings": len(result.SafetyRatings) &gt; 0,
                },
                TokenCounts: &amp;auditlog.TokenCountInfo{
                        PromptTokens: int32(tokenInfo.TokenCount),
                        OutputTokens: int32(result.TokenCount),
                        TotalTokens:  int32(tokenInfo.TokenCount + result.TokenCount),
                },
                Message: "Content generation completed successfully for model " + modelName,
        }); logErr != nil </span><span class="cov0" title="0">{
                p.logger.Error("Failed to write audit log: %v", logErr)
        }</span>

        // 4. Process API response
        <span class="cov8" title="1">generatedOutput, err := p.apiService.ProcessResponse(result)
        if err != nil </span><span class="cov8" title="1">{
                // Get detailed error information
                errorDetails := p.apiService.GetErrorDetails(err)

                // Provide specific error messages based on error type
                if p.apiService.IsEmptyResponseError(err) </span><span class="cov0" title="0">{
                        p.logger.Error("Received empty or invalid response from Gemini API for model %s", modelName)
                        p.logger.Error("Error details: %s", errorDetails)
                        return fmt.Errorf("failed to process API response for model %s due to empty content: %w", modelName, err)
                }</span> else<span class="cov8" title="1"> if p.apiService.IsSafetyBlockedError(err) </span><span class="cov0" title="0">{
                        p.logger.Error("Content was blocked by Gemini safety filters for model %s", modelName)
                        p.logger.Error("Error details: %s", errorDetails)
                        return fmt.Errorf("failed to process API response for model %s due to safety restrictions: %w", modelName, err)
                }</span> else<span class="cov8" title="1"> {
                        // Generic API error handling
                        return fmt.Errorf("failed to process API response for model %s: %w", modelName, err)
                }</span>
        }
        <span class="cov8" title="1">contentLength := len(generatedOutput)
        p.logger.Info("Output generated successfully with model %s (content length: %d characters, tokens: %d)",
                modelName, contentLength, result.TokenCount)

        // 5. Sanitize model name for use in filename
        sanitizedModelName := sanitizeFilename(modelName)

        // 6. Construct output file path
        outputFilePath := filepath.Join(p.config.OutputDir, sanitizedModelName+".md")

        // 7. Save the output to file
        if err := p.saveOutputToFile(outputFilePath, generatedOutput); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to save output for model %s: %w", modelName, err)
        }</span>

        <span class="cov8" title="1">p.logger.Info("Successfully processed model: %s", modelName)
        return nil</span>
}

// sanitizeFilename replaces characters that are not valid in filenames
func sanitizeFilename(filename string) string <span class="cov8" title="1">{
        // Replace slashes and other problematic characters with hyphens
        replacer := strings.NewReplacer(
                "/", "-",
                "\\", "-",
                ":", "-",
                "*", "-",
                "?", "-",
                "\"", "-",
                "&lt;", "-",
                "&gt;", "-",
                "|", "-",
        )
        return replacer.Replace(filename)
}</span>

// saveOutputToFile is a helper method that saves the generated output to a file
// and includes audit logging around the file writing operation.
func (p *ModelProcessor) saveOutputToFile(outputFilePath, content string) error <span class="cov8" title="1">{
        // Log the start of output saving
        saveStartTime := time.Now()
        if logErr := p.auditLogger.Log(auditlog.AuditEntry{
                Timestamp: saveStartTime,
                Operation: "SaveOutputStart",
                Status:    "InProgress",
                Inputs: map[string]interface{}{
                        "output_path":    outputFilePath,
                        "content_length": len(content),
                },
                Message: "Starting to save output to file",
        }); logErr != nil </span><span class="cov0" title="0">{
                p.logger.Error("Failed to write audit log: %v", logErr)
        }</span>

        // Save output file
        <span class="cov8" title="1">p.logger.Info("Writing output to %s...", outputFilePath)
        err := p.fileWriter.SaveToFile(content, outputFilePath)

        // Calculate duration in milliseconds
        saveDurationMs := time.Since(saveStartTime).Milliseconds()

        if err != nil </span><span class="cov8" title="1">{
                // Log failure to save output
                p.logger.Error("Error saving output to file %s: %v", outputFilePath, err)

                if logErr := p.auditLogger.Log(auditlog.AuditEntry{
                        Timestamp:  time.Now().UTC(),
                        Operation:  "SaveOutputEnd",
                        Status:     "Failure",
                        DurationMs: &amp;saveDurationMs,
                        Inputs: map[string]interface{}{
                                "output_path": outputFilePath,
                        },
                        Error: &amp;auditlog.ErrorInfo{
                                Message: fmt.Sprintf("Failed to save output to file: %v", err),
                                Type:    "FileIOError",
                        },
                        Message: "Failed to save output to file",
                }); logErr != nil </span><span class="cov0" title="0">{
                        p.logger.Error("Failed to write audit log: %v", logErr)
                }</span>

                <span class="cov8" title="1">return fmt.Errorf("error saving output to file %s: %w", outputFilePath, err)</span>
        }

        // Log successful saving of output
        <span class="cov8" title="1">if logErr := p.auditLogger.Log(auditlog.AuditEntry{
                Timestamp:  time.Now().UTC(),
                Operation:  "SaveOutputEnd",
                Status:     "Success",
                DurationMs: &amp;saveDurationMs,
                Inputs: map[string]interface{}{
                        "output_path": outputFilePath,
                },
                Outputs: map[string]interface{}{
                        "content_length": len(content),
                },
                Message: "Successfully saved output to file",
        }); logErr != nil </span><span class="cov0" title="0">{
                p.logger.Error("Failed to write audit log: %v", logErr)
        }</span>

        <span class="cov8" title="1">p.logger.Info("Output successfully generated and saved to %s", outputFilePath)
        return nil</span>
}
</pre>

		<pre class="file" id="file12" style="display: none">// Package orchestrator is responsible for coordinating the core application workflow.
// It brings together various components like context gathering, API interaction,
// token management, and output writing to execute the main task defined
// by user instructions and configuration.
package orchestrator

import (
        "context"
        "errors"
        "fmt"
        "strings"
        "sync"
        "time"

        "github.com/phrazzld/architect/internal/architect/interfaces"
        "github.com/phrazzld/architect/internal/architect/modelproc"
        "github.com/phrazzld/architect/internal/architect/prompt"
        "github.com/phrazzld/architect/internal/auditlog"
        "github.com/phrazzld/architect/internal/config"
        "github.com/phrazzld/architect/internal/fileutil"
        "github.com/phrazzld/architect/internal/gemini"
        "github.com/phrazzld/architect/internal/logutil"
        "github.com/phrazzld/architect/internal/ratelimit"
)

// Orchestrator coordinates the main application logic.
// It depends on various services to perform tasks like interacting with the API,
// gathering context, managing tokens, writing files, logging audits, and handling rate limits.
type Orchestrator struct {
        apiService      interfaces.APIService
        contextGatherer interfaces.ContextGatherer
        tokenManager    interfaces.TokenManager
        fileWriter      interfaces.FileWriter
        auditLogger     auditlog.AuditLogger
        rateLimiter     *ratelimit.RateLimiter
        config          *config.CliConfig
        logger          logutil.LoggerInterface
}

// NewOrchestrator creates a new instance of the Orchestrator.
// It requires all necessary dependencies to be provided during construction,
// ensuring that the orchestrator is properly configured to execute its tasks.
func NewOrchestrator(
        apiService interfaces.APIService,
        contextGatherer interfaces.ContextGatherer,
        tokenManager interfaces.TokenManager,
        fileWriter interfaces.FileWriter,
        auditLogger auditlog.AuditLogger,
        rateLimiter *ratelimit.RateLimiter,
        config *config.CliConfig,
        logger logutil.LoggerInterface,
) *Orchestrator <span class="cov8" title="1">{
        return &amp;Orchestrator{
                apiService:      apiService,
                contextGatherer: contextGatherer,
                tokenManager:    tokenManager,
                fileWriter:      fileWriter,
                auditLogger:     auditLogger,
                rateLimiter:     rateLimiter,
                config:          config,
                logger:          logger,
        }
}</span>

// Run executes the main application workflow, representing the core business logic.
// It coordinates the entire process from context gathering to model processing:
// 1. Gather context from project files based on configuration
// 2. Handle dry run mode by displaying statistics (if enabled)
// 3. Build the complete prompt by combining instructions with context
// 4. Process all configured models concurrently with rate limiting
// 5. Handle and format any errors that occurred during processing
//
// The method enforces a clear separation of concerns by delegating specific tasks
// to helper methods, making the high-level workflow easy to understand.
func (o *Orchestrator) Run(ctx context.Context, instructions string) error <span class="cov8" title="1">{
        // STEP 1: Gather context from files
        contextFiles, contextStats, err := o.gatherProjectContext(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // STEP 2: Handle dry run mode (short-circuit if dry run)
        <span class="cov8" title="1">if o.config.DryRun </span><span class="cov8" title="1">{
                return o.handleDryRun(ctx, contextStats)
        }</span>

        // STEP 3: Build prompt by combining instructions and context
        <span class="cov8" title="1">stitchedPrompt := o.buildPrompt(instructions, contextFiles)

        // STEP 4: Process models concurrently
        o.logRateLimitingConfiguration()
        modelErrors := o.processModels(ctx, stitchedPrompt)

        // STEP 5: Handle any errors from model processing
        if len(modelErrors) &gt; 0 </span><span class="cov8" title="1">{
                return o.aggregateAndFormatErrors(modelErrors)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// gatherProjectContext collects relevant files from the project based on configuration.
func (o *Orchestrator) gatherProjectContext(ctx context.Context) ([]fileutil.FileMeta, *interfaces.ContextStats, error) <span class="cov8" title="1">{
        gatherConfig := interfaces.GatherConfig{
                Paths:        o.config.Paths,
                Include:      o.config.Include,
                Exclude:      o.config.Exclude,
                ExcludeNames: o.config.ExcludeNames,
                Format:       o.config.Format,
                Verbose:      o.config.Verbose,
                LogLevel:     o.config.LogLevel,
        }

        contextFiles, contextStats, err := o.contextGatherer.GatherContext(ctx, gatherConfig)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("failed during project context gathering: %w", err)
        }</span>

        <span class="cov8" title="1">return contextFiles, contextStats, nil</span>
}

// handleDryRun displays context statistics without performing API calls.
func (o *Orchestrator) handleDryRun(ctx context.Context, stats *interfaces.ContextStats) error <span class="cov8" title="1">{
        err := o.contextGatherer.DisplayDryRunInfo(ctx, stats)
        if err != nil </span><span class="cov0" title="0">{
                o.logger.Error("Error displaying dry run information: %v", err)
                return fmt.Errorf("error displaying dry run information: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// buildPrompt creates the complete prompt by combining instructions with context files.
func (o *Orchestrator) buildPrompt(instructions string, contextFiles []fileutil.FileMeta) string <span class="cov8" title="1">{
        stitchedPrompt := prompt.StitchPrompt(instructions, contextFiles)
        o.logger.Info("Prompt constructed successfully")
        o.logger.Debug("Stitched prompt length: %d characters", len(stitchedPrompt))
        return stitchedPrompt
}</span>

// logRateLimitingConfiguration logs information about concurrency and rate limits.
func (o *Orchestrator) logRateLimitingConfiguration() <span class="cov8" title="1">{
        if o.config.MaxConcurrentRequests &gt; 0 </span><span class="cov8" title="1">{
                o.logger.Info("Concurrency limited to %d simultaneous requests", o.config.MaxConcurrentRequests)
        }</span> else<span class="cov8" title="1"> {
                o.logger.Info("No concurrency limit applied")
        }</span>

        <span class="cov8" title="1">if o.config.RateLimitRequestsPerMinute &gt; 0 </span><span class="cov8" title="1">{
                o.logger.Info("Rate limited to %d requests per minute per model", o.config.RateLimitRequestsPerMinute)
        }</span> else<span class="cov8" title="1"> {
                o.logger.Info("No rate limit applied")
        }</span>

        <span class="cov8" title="1">o.logger.Info("Processing %d models concurrently...", len(o.config.ModelNames))</span>
}

// processModels processes each model concurrently with rate limiting.
// This is a key orchestration method that manages the concurrent execution
// of model processing while respecting rate limits. It coordinates multiple
// goroutines, each handling a different model, and collects any errors that
// occur during processing. This approach significantly improves throughput
// when multiple models are specified.
//
// Returns a slice of errors encountered during processing, which will be empty
// if all models were processed successfully.
func (o *Orchestrator) processModels(ctx context.Context, stitchedPrompt string) []error <span class="cov8" title="1">{
        var wg sync.WaitGroup
        errChan := make(chan error, len(o.config.ModelNames))

        // Launch a goroutine for each model
        for _, modelName := range o.config.ModelNames </span><span class="cov8" title="1">{
                wg.Add(1)
                go o.processModelWithRateLimit(ctx, modelName, stitchedPrompt, &amp;wg, errChan)
        }</span>

        // Wait for all goroutines to complete
        <span class="cov8" title="1">wg.Wait()
        close(errChan)

        // Collect errors from the channel
        var modelErrors []error
        for err := range errChan </span><span class="cov8" title="1">{
                modelErrors = append(modelErrors, err)
        }</span>

        <span class="cov8" title="1">return modelErrors</span>
}

// processModelWithRateLimit processes a single model with rate limiting.
func (o *Orchestrator) processModelWithRateLimit(
        ctx context.Context,
        modelName string,
        stitchedPrompt string,
        wg *sync.WaitGroup,
        errChan chan&lt;- error,
) <span class="cov8" title="1">{
        defer wg.Done()

        // Acquire rate limiting permission
        o.logger.Debug("Attempting to acquire rate limiter for model %s...", modelName)
        acquireStart := time.Now()
        if err := o.rateLimiter.Acquire(ctx, modelName); err != nil </span><span class="cov0" title="0">{
                o.logger.Error("Rate limiting error for model %s: %v", modelName, err)
                errChan &lt;- fmt.Errorf("model %s rate limit: %w", modelName, err)
                return
        }</span>
        <span class="cov8" title="1">acquireDuration := time.Since(acquireStart)
        o.logger.Debug("Rate limiter acquired for model %s (waited %v)", modelName, acquireDuration)

        // Release rate limiter when done
        defer func() </span><span class="cov8" title="1">{
                o.logger.Debug("Releasing rate limiter for model %s", modelName)
                o.rateLimiter.Release()
        }</span>()

        // Create API service adapter and model processor
        <span class="cov8" title="1">apiServiceAdapter := &amp;APIServiceAdapter{APIService: o.apiService}
        processor := modelproc.NewProcessor(
                apiServiceAdapter,
                nil, // tokenManager is created inside the Process method
                o.fileWriter,
                o.auditLogger,
                o.logger,
                o.config,
        )

        // Process the model
        err := processor.Process(ctx, modelName, stitchedPrompt)
        if err != nil </span><span class="cov8" title="1">{
                o.logger.Error("Processing model %s failed: %v", modelName, err)
                errChan &lt;- fmt.Errorf("model %s: %w", modelName, err)
        }</span>
}

// aggregateAndFormatErrors combines multiple errors into a single, user-friendly error message.
// This method consolidates errors from multiple model processing operations into
// a coherent error message for the user. It specially handles rate limit errors
// by providing additional guidance on how to adjust configuration parameters
// to avoid these errors in the future. This approach ensures users receive
// actionable feedback when errors occur.
func (o *Orchestrator) aggregateAndFormatErrors(modelErrors []error) error <span class="cov8" title="1">{
        // Count rate limit errors
        var rateLimitErrors []error
        for _, err := range modelErrors </span><span class="cov8" title="1">{
                if strings.Contains(err.Error(), "rate limit") </span><span class="cov8" title="1">{
                        rateLimitErrors = append(rateLimitErrors, err)
                }</span>
        }

        // Build the error message
        <span class="cov8" title="1">errMsg := "errors occurred during model processing:"
        for _, e := range modelErrors </span><span class="cov8" title="1">{
                errMsg += "\n  - " + e.Error()
        }</span>

        // Add rate limit guidance if applicable
        <span class="cov8" title="1">if len(rateLimitErrors) &gt; 0 </span><span class="cov8" title="1">{
                errMsg += "\n\nTip: If you're encountering rate limit errors, consider adjusting the --max-concurrent and --rate-limit flags to prevent overwhelming the API."
        }</span>

        <span class="cov8" title="1">return errors.New(errMsg)</span>
}

// APIServiceAdapter adapts interfaces.APIService to modelproc.APIService.
// This adapter pattern resolves potential interface incompatibilities between
// packages without requiring changes to either interface. It allows the orchestrator
// to work with the interfaces.APIService while providing the modelproc package with
// a compatible interface implementation, preventing circular dependencies.
type APIServiceAdapter struct {
        APIService interfaces.APIService
}

// InitClient initializes and returns a Gemini client for the specified model.
// It delegates to the underlying APIService implementation.
func (a *APIServiceAdapter) InitClient(ctx context.Context, apiKey, modelName, apiEndpoint string) (gemini.Client, error) <span class="cov8" title="1">{
        return a.APIService.InitClient(ctx, apiKey, modelName, apiEndpoint)
}</span>

// ProcessResponse extracts content from the API response.
// It delegates to the underlying APIService implementation.
func (a *APIServiceAdapter) ProcessResponse(result *gemini.GenerationResult) (string, error) <span class="cov8" title="1">{
        return a.APIService.ProcessResponse(result)
}</span>

// IsEmptyResponseError checks if an error is related to empty API responses.
// It delegates to the underlying APIService implementation.
func (a *APIServiceAdapter) IsEmptyResponseError(err error) bool <span class="cov8" title="1">{
        return a.APIService.IsEmptyResponseError(err)
}</span>

// IsSafetyBlockedError checks if an error is related to safety filters.
// It delegates to the underlying APIService implementation.
func (a *APIServiceAdapter) IsSafetyBlockedError(err error) bool <span class="cov8" title="1">{
        return a.APIService.IsSafetyBlockedError(err)
}</span>

// GetErrorDetails extracts detailed information from an error.
// It delegates to the underlying APIService implementation.
func (a *APIServiceAdapter) GetErrorDetails(err error) string <span class="cov8" title="1">{
        return a.APIService.GetErrorDetails(err)
}</span>

// TokenManagerAdapter is a deprecated adapter that was used to adapt interfaces.TokenManager
// to modelproc.TokenManager. It is no longer needed since TokenManagers are now created directly
// in the ModelProcessor.Process method with model-specific clients.
// This documentation is kept as a historical note, as the adapter code has been removed.
// The current design eliminates the need for this adapter by having ModelProcessor create
// its own TokenManager instances tailored to each specific model, improving encapsulation.
</pre>

		<pre class="file" id="file13" style="display: none">// Package prompt handles the creation and manipulation of prompts
// sent to the generative AI models. It provides functions for constructing
// prompts with context files and proper escaping of content.
package prompt

import (
        "strings"

        "github.com/phrazzld/architect/internal/fileutil"
)

// EscapeContent helps prevent conflicts with XML-like tags by escaping &lt; and &gt; characters
func EscapeContent(content string) string <span class="cov8" title="1">{
        escaped := strings.ReplaceAll(content, "&lt;", "&amp;lt;")
        escaped = strings.ReplaceAll(escaped, "&gt;", "&amp;gt;")
        return escaped
}</span>

// StitchPrompt combines instructions and file context into the final prompt string with XML-like tags
func StitchPrompt(instructions string, contextFiles []fileutil.FileMeta) string <span class="cov8" title="1">{
        var sb strings.Builder

        // Add instructions block
        sb.WriteString("&lt;instructions&gt;\n")
        if instructions != "" </span><span class="cov8" title="1">{
                sb.WriteString(instructions)
                sb.WriteString("\n")
        }</span>
        <span class="cov8" title="1">sb.WriteString("&lt;/instructions&gt;\n")

        // Add context block
        sb.WriteString("&lt;context&gt;\n")
        for _, file := range contextFiles </span><span class="cov8" title="1">{
                // Add file path tag
                sb.WriteString("&lt;path&gt;")
                sb.WriteString(file.Path)
                sb.WriteString("&lt;/path&gt;\n")

                // Add file content with escaping
                sb.WriteString(EscapeContent(file.Content))
                sb.WriteString("\n\n")
        }</span>
        <span class="cov8" title="1">sb.WriteString("&lt;/context&gt;")

        return sb.String()</span>
}
</pre>

		<pre class="file" id="file14" style="display: none">// Package architect contains the core application logic for the architect tool
package architect

import (
        "bufio"
        "context"
        "fmt"
        "os"
        "strings"
        "time"

        "github.com/phrazzld/architect/internal/auditlog"
        "github.com/phrazzld/architect/internal/gemini"
        "github.com/phrazzld/architect/internal/logutil"
)

// TokenResult holds information about token counts and limits
type TokenResult struct {
        TokenCount   int32
        InputLimit   int32
        ExceedsLimit bool
        LimitError   string
        Percentage   float64
}

// TokenManager defines the interface for token counting and management
type TokenManager interface {
        // GetTokenInfo retrieves token count information and checks limits
        GetTokenInfo(ctx context.Context, prompt string) (*TokenResult, error)

        // CheckTokenLimit verifies the prompt doesn't exceed the model's token limit
        CheckTokenLimit(ctx context.Context, prompt string) error

        // PromptForConfirmation asks for user confirmation to proceed if token count exceeds threshold
        PromptForConfirmation(tokenCount int32, threshold int) bool
}

// tokenManager implements the TokenManager interface
type tokenManager struct {
        logger      logutil.LoggerInterface
        auditLogger auditlog.AuditLogger
        client      gemini.Client
}

// NewTokenManager creates a new TokenManager instance
func NewTokenManager(logger logutil.LoggerInterface, auditLogger auditlog.AuditLogger, client gemini.Client) (TokenManager, error) <span class="cov8" title="1">{
        if client == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("client cannot be nil for TokenManager")
        }</span>
        <span class="cov8" title="1">return NewTokenManagerWithClient(logger, auditLogger, client), nil</span>
}

// NewTokenManagerWithClient creates a TokenManager with a specific client.
// This is defined as a variable to allow it to be mocked in tests.
var NewTokenManagerWithClient = func(logger logutil.LoggerInterface, auditLogger auditlog.AuditLogger, client gemini.Client) TokenManager <span class="cov8" title="1">{
        return &amp;tokenManager{
                logger:      logger,
                auditLogger: auditLogger,
                client:      client,
        }
}</span>

// GetTokenInfo retrieves token count information and checks limits
func (tm *tokenManager) GetTokenInfo(ctx context.Context, prompt string) (*TokenResult, error) <span class="cov8" title="1">{
        // Get the model name from the injected client
        modelName := tm.client.GetModelName()

        // Log the start of token checking
        checkStartTime := time.Now()
        if logErr := tm.auditLogger.Log(auditlog.AuditEntry{
                Timestamp: checkStartTime,
                Operation: "CheckTokensStart",
                Status:    "InProgress",
                Inputs: map[string]interface{}{
                        "prompt_length": len(prompt),
                        "model_name":    modelName,
                },
                Message: "Starting token count check for model " + modelName,
        }); logErr != nil </span><span class="cov0" title="0">{
                tm.logger.Error("Failed to write audit log: %v", logErr)
        }</span>

        // Create result structure
        <span class="cov8" title="1">result := &amp;TokenResult{
                ExceedsLimit: false,
        }

        // Get model information (limits)
        modelInfo, err := tm.client.GetModelInfo(ctx)
        if err != nil </span><span class="cov0" title="0">{
                // Pass through API errors directly for better error messages
                if apiErr, ok := gemini.IsAPIError(err); ok </span><span class="cov0" title="0">{
                        // Log the token check failure
                        if logErr := tm.auditLogger.Log(auditlog.AuditEntry{
                                Timestamp: time.Now().UTC(),
                                Operation: "CheckTokens",
                                Status:    "Failure",
                                Inputs: map[string]interface{}{
                                        "prompt_length": len(prompt),
                                        "model_name":    modelName,
                                },
                                Error: &amp;auditlog.ErrorInfo{
                                        Message: apiErr.Message,
                                        Type:    "APIError",
                                },
                                Message: "Token count check failed for model " + modelName,
                        }); logErr != nil </span><span class="cov0" title="0">{
                                tm.logger.Error("Failed to write audit log: %v", logErr)
                        }</span>

                        <span class="cov0" title="0">return nil, apiErr</span>
                }

                // Log the token check failure for other errors
                <span class="cov0" title="0">if logErr := tm.auditLogger.Log(auditlog.AuditEntry{
                        Timestamp: time.Now().UTC(),
                        Operation: "CheckTokens",
                        Status:    "Failure",
                        Inputs: map[string]interface{}{
                                "prompt_length": len(prompt),
                                "model_name":    modelName,
                        },
                        Error: &amp;auditlog.ErrorInfo{
                                Message: fmt.Sprintf("Failed to get model info: %v", err),
                                Type:    "TokenCheckError",
                        },
                        Message: "Token count check failed for model " + modelName,
                }); logErr != nil </span><span class="cov0" title="0">{
                        tm.logger.Error("Failed to write audit log: %v", logErr)
                }</span>

                // Wrap other errors
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get model info for token limit check: %w", err)</span>
        }

        // Store input limit
        <span class="cov8" title="1">result.InputLimit = modelInfo.InputTokenLimit

        // Count tokens in the prompt
        tokenResult, err := tm.client.CountTokens(ctx, prompt)
        if err != nil </span><span class="cov0" title="0">{
                // Pass through API errors directly for better error messages
                if apiErr, ok := gemini.IsAPIError(err); ok </span><span class="cov0" title="0">{
                        // Log the token check failure
                        if logErr := tm.auditLogger.Log(auditlog.AuditEntry{
                                Timestamp: time.Now().UTC(),
                                Operation: "CheckTokens",
                                Status:    "Failure",
                                Inputs: map[string]interface{}{
                                        "prompt_length": len(prompt),
                                        "model_name":    modelName,
                                },
                                Error: &amp;auditlog.ErrorInfo{
                                        Message: apiErr.Message,
                                        Type:    "APIError",
                                },
                                Message: "Token count check failed for model " + modelName,
                        }); logErr != nil </span><span class="cov0" title="0">{
                                tm.logger.Error("Failed to write audit log: %v", logErr)
                        }</span>

                        <span class="cov0" title="0">return nil, apiErr</span>
                }

                // Log the token check failure for other errors
                <span class="cov0" title="0">if logErr := tm.auditLogger.Log(auditlog.AuditEntry{
                        Timestamp: time.Now().UTC(),
                        Operation: "CheckTokens",
                        Status:    "Failure",
                        Inputs: map[string]interface{}{
                                "prompt_length": len(prompt),
                                "model_name":    modelName,
                        },
                        Error: &amp;auditlog.ErrorInfo{
                                Message: fmt.Sprintf("Failed to count tokens: %v", err),
                                Type:    "TokenCheckError",
                        },
                        Message: "Token count check failed for model " + modelName,
                }); logErr != nil </span><span class="cov0" title="0">{
                        tm.logger.Error("Failed to write audit log: %v", logErr)
                }</span>

                // Wrap other errors
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to count tokens for token limit check: %w", err)</span>
        }

        // Store token count
        <span class="cov8" title="1">result.TokenCount = tokenResult.Total

        // Calculate percentage of limit
        result.Percentage = float64(result.TokenCount) / float64(result.InputLimit) * 100

        // Log token usage information
        tm.logger.Debug("Token usage: %d / %d (%.1f%%)",
                result.TokenCount,
                result.InputLimit,
                result.Percentage)

        // Check if the prompt exceeds the token limit
        if result.TokenCount &gt; result.InputLimit </span><span class="cov8" title="1">{
                result.ExceedsLimit = true
                result.LimitError = fmt.Sprintf("prompt exceeds token limit (%d tokens &gt; %d token limit)",
                        result.TokenCount, result.InputLimit)

                // Log the token limit exceeded case
                if logErr := tm.auditLogger.Log(auditlog.AuditEntry{
                        Timestamp: time.Now().UTC(),
                        Operation: "CheckTokens",
                        Status:    "Failure",
                        Inputs: map[string]interface{}{
                                "prompt_length": len(prompt),
                                "model_name":    modelName,
                        },
                        TokenCounts: &amp;auditlog.TokenCountInfo{
                                PromptTokens: result.TokenCount,
                                TotalTokens:  result.TokenCount,
                                Limit:        result.InputLimit,
                        },
                        Error: &amp;auditlog.ErrorInfo{
                                Message: result.LimitError,
                                Type:    "TokenLimitExceededError",
                        },
                        Message: "Token limit exceeded for model " + modelName,
                }); logErr != nil </span><span class="cov0" title="0">{
                        tm.logger.Error("Failed to write audit log: %v", logErr)
                }</span>
        } else<span class="cov8" title="1"> {
                // Log the successful token check
                if logErr := tm.auditLogger.Log(auditlog.AuditEntry{
                        Timestamp: time.Now().UTC(),
                        Operation: "CheckTokens",
                        Status:    "Success",
                        Inputs: map[string]interface{}{
                                "prompt_length": len(prompt),
                                "model_name":    modelName,
                        },
                        Outputs: map[string]interface{}{
                                "percentage": result.Percentage,
                        },
                        TokenCounts: &amp;auditlog.TokenCountInfo{
                                PromptTokens: result.TokenCount,
                                TotalTokens:  result.TokenCount,
                                Limit:        result.InputLimit,
                        },
                        Message: fmt.Sprintf("Token check passed for model %s: %d / %d tokens (%.1f%% of limit)",
                                modelName, result.TokenCount, result.InputLimit, result.Percentage),
                }); logErr != nil </span><span class="cov0" title="0">{
                        tm.logger.Error("Failed to write audit log: %v", logErr)
                }</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// CheckTokenLimit verifies the prompt doesn't exceed the model's token limit
func (tm *tokenManager) CheckTokenLimit(ctx context.Context, prompt string) error <span class="cov0" title="0">{
        tokenInfo, err := tm.GetTokenInfo(ctx, prompt)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if tokenInfo.ExceedsLimit </span><span class="cov0" title="0">{
                return fmt.Errorf(tokenInfo.LimitError)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// PromptForConfirmation asks for user confirmation to proceed
func (tm *tokenManager) PromptForConfirmation(tokenCount int32, threshold int) bool <span class="cov8" title="1">{
        if threshold &lt;= 0 || int32(threshold) &gt; tokenCount </span><span class="cov8" title="1">{
                // No confirmation needed if threshold is disabled (0) or token count is below threshold
                tm.logger.Debug("No confirmation needed: threshold=%d, tokenCount=%d", threshold, tokenCount)
                return true
        }</span>

        <span class="cov8" title="1">tm.logger.Info("Token count (%d) exceeds confirmation threshold (%d).", tokenCount, threshold)
        tm.logger.Info("Do you want to proceed with the API call? [y/N]: ")

        reader := bufio.NewReader(os.Stdin)
        response, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                tm.logger.Error("Error reading input: %v", err)
                return false
        }</span>

        // Log the raw response for debugging
        <span class="cov8" title="1">tm.logger.Debug("User confirmation response (raw): %q", response)

        // Trim whitespace and convert to lowercase
        response = strings.ToLower(strings.TrimSpace(response))
        tm.logger.Debug("User confirmation response (processed): %q", response)

        // Only proceed if the user explicitly confirms with 'y' or 'yes'
        result := response == "y" || response == "yes"
        tm.logger.Debug("User confirmation result: %v", result)
        return result</span>
}
</pre>

		<pre class="file" id="file15" style="display: none">// Package auditlog provides structured logging for audit purposes
package auditlog

import (
        "encoding/json"
        "fmt"
        "os"
        "sync"
        "time"

        "github.com/phrazzld/architect/internal/logutil"
)

// AuditLogger defines the interface for logging audit events.
// Implementations of this interface will handle persisting audit
// log entries in various formats (e.g., JSON Lines file, no-op).
type AuditLogger interface {
        // Log records a single audit entry.
        // The entry contains information about operations, status, and relevant metadata.
        // Returns an error if the logging operation fails.
        Log(entry AuditEntry) error

        // Close releases any resources used by the logger (e.g., open file handles).
        // Should be called when the logger is no longer needed.
        // Returns an error if the closing operation fails.
        Close() error
}

// FileAuditLogger implements AuditLogger by writing JSON Lines to a file.
type FileAuditLogger struct {
        file   *os.File
        mu     sync.Mutex
        logger logutil.LoggerInterface // For logging errors within the audit logger itself
}

// NewFileAuditLogger creates a new FileAuditLogger that writes to the specified file path.
// If the file doesn't exist, it will be created. If it does exist, logs will be appended.
// The provided internal logger is used to log any errors that occur during audit logging operations.
func NewFileAuditLogger(filePath string, internalLogger logutil.LoggerInterface) (*FileAuditLogger, error) <span class="cov8" title="1">{
        file, err := os.OpenFile(filePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        if err != nil </span><span class="cov8" title="1">{
                internalLogger.Error("Failed to open audit log file '%s': %v", filePath, err)
                return nil, fmt.Errorf("failed to open audit log file %s: %w", filePath, err)
        }</span>
        <span class="cov8" title="1">internalLogger.Info("Audit logging enabled to file: %s", filePath)
        return &amp;FileAuditLogger{
                file:   file,
                logger: internalLogger,
        }, nil</span>
}

// Log records a single audit entry by marshaling it to JSON and writing it to the log file.
// It sets the entry timestamp if not already set and ensures thread safety with a mutex lock.
func (l *FileAuditLogger) Log(entry AuditEntry) error <span class="cov8" title="1">{
        l.mu.Lock()
        defer l.mu.Unlock()

        // Ensure timestamp is set
        if entry.Timestamp.IsZero() </span><span class="cov8" title="1">{
                entry.Timestamp = time.Now().UTC()
        }</span>

        // Marshal entry to JSON
        <span class="cov8" title="1">jsonData, err := json.Marshal(entry)
        if err != nil </span><span class="cov0" title="0">{
                l.logger.Error("Failed to marshal audit entry to JSON: %v, Entry: %+v", err, entry)
                return fmt.Errorf("failed to marshal audit entry: %w", err)
        }</span>

        // Write JSON line to file
        <span class="cov8" title="1">if _, err := l.file.Write(append(jsonData, '\n')); err != nil </span><span class="cov0" title="0">{
                l.logger.Error("Failed to write audit entry to file '%s': %v", l.file.Name(), err)
                return fmt.Errorf("failed to write audit entry: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Close properly closes the log file.
// It ensures thread safety with a mutex lock and prevents double-closing.
func (l *FileAuditLogger) Close() error <span class="cov8" title="1">{
        l.mu.Lock()
        defer l.mu.Unlock()

        if l.file != nil </span><span class="cov8" title="1">{
                l.logger.Info("Closing audit log file: %s", l.file.Name())
                err := l.file.Close()
                l.file = nil // Prevent double close
                if err != nil </span><span class="cov0" title="0">{
                        l.logger.Error("Error closing audit log file: %v", err)
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// NoOpAuditLogger implements AuditLogger with no-op methods.
// This implementation is used when audit logging is disabled.
type NoOpAuditLogger struct{}

// NewNoOpAuditLogger creates a new NoOpAuditLogger instance.
func NewNoOpAuditLogger() *NoOpAuditLogger <span class="cov8" title="1">{
        return &amp;NoOpAuditLogger{}
}</span>

// Log implements the AuditLogger interface but performs no action.
// It always returns nil (no error).
func (l *NoOpAuditLogger) Log(entry AuditEntry) error <span class="cov8" title="1">{
        return nil // Do nothing
}</span>

// Close implements the AuditLogger interface but performs no action.
// It always returns nil (no error).
func (l *NoOpAuditLogger) Close() error <span class="cov8" title="1">{
        return nil // Do nothing
}</span>

// Compile-time checks to ensure implementations satisfy the AuditLogger interface.
var _ AuditLogger = (*FileAuditLogger)(nil)
var _ AuditLogger = (*NoOpAuditLogger)(nil)
</pre>

		<pre class="file" id="file16" style="display: none">// Package config handles loading and managing application configuration.
// It defines a canonical set of configuration parameters used throughout
// the application, consolidating configuration from CLI flags, environment
// variables, and default values. This centralized approach ensures
// consistent configuration handling and reduces duplication.
package config

import (
        "fmt"
        "github.com/phrazzld/architect/internal/logutil"
        "strings"
)

// Configuration constants
const (
        // Default values
        DefaultOutputFile = "PLAN.md"
        DefaultModel      = "gemini-2.5-pro-exp-03-25"
        APIKeyEnvVar      = "GEMINI_API_KEY"
        APIEndpointEnvVar = "GEMINI_API_URL"
        DefaultFormat     = "&lt;{path}&gt;\n```\n{content}\n```\n&lt;/{path}&gt;\n\n"

        // Default rate limiting values
        DefaultMaxConcurrentRequests      = 5  // Default maximum concurrent API requests
        DefaultRateLimitRequestsPerMinute = 60 // Default requests per minute per model

        // Default excludes for file extensions
        DefaultExcludes = ".exe,.bin,.obj,.o,.a,.lib,.so,.dll,.dylib,.class,.jar,.pyc,.pyo,.pyd," +
                ".zip,.tar,.gz,.rar,.7z,.pdf,.doc,.docx,.xls,.xlsx,.ppt,.pptx,.odt,.ods,.odp," +
                ".jpg,.jpeg,.png,.gif,.bmp,.tiff,.svg,.mp3,.wav,.ogg,.mp4,.avi,.mov,.wmv,.flv," +
                ".iso,.img,.dmg,.db,.sqlite,.log"

        // Default excludes for file and directory names
        DefaultExcludeNames = ".git,.hg,.svn,node_modules,bower_components,vendor,target,dist,build," +
                "out,tmp,coverage,__pycache__,*.pyc,*.pyo,.DS_Store,~$*,desktop.ini,Thumbs.db," +
                "package-lock.json,yarn.lock,go.sum,go.work"
)

// ExcludeConfig defines file exclusion configuration
type ExcludeConfig struct {
        // File extensions to exclude
        Extensions string
        // File and directory names to exclude
        Names string
}

// AppConfig holds essential configuration settings with defaults
type AppConfig struct {
        // Core settings with defaults
        OutputFile string
        ModelName  string
        Format     string

        // File handling settings
        Include       string
        ConfirmTokens int

        // Logging and display settings
        Verbose  bool
        LogLevel logutil.LogLevel

        // Exclude settings (hierarchical)
        Excludes ExcludeConfig
}

// DefaultConfig returns a new AppConfig instance with default values
func DefaultConfig() *AppConfig <span class="cov8" title="1">{
        return &amp;AppConfig{
                OutputFile:    DefaultOutputFile,
                ModelName:     DefaultModel,
                Format:        DefaultFormat,
                LogLevel:      logutil.InfoLevel,
                ConfirmTokens: 0, // Disabled by default
                Excludes: ExcludeConfig{
                        Extensions: DefaultExcludes,
                        Names:      DefaultExcludeNames,
                },
        }
}</span>

// CliConfig holds the parsed command-line options for the application.
// It serves as the canonical configuration structure used throughout the
// application, combining user inputs from CLI flags, environment variables,
// and default values. This struct is passed to components that need
// configuration parameters rather than having them parse flags directly.
type CliConfig struct {
        // Instructions configuration
        InstructionsFile string

        // Output configuration
        OutputDir    string
        AuditLogFile string // Path to write structured audit logs (JSON Lines)
        Format       string

        // Context gathering options
        Paths        []string
        Include      string
        Exclude      string
        ExcludeNames string
        DryRun       bool
        Verbose      bool

        // API configuration
        APIKey      string
        APIEndpoint string
        ModelNames  []string

        // Token management
        ConfirmTokens int

        // Logging
        LogLevel logutil.LogLevel

        // Rate limiting configuration
        MaxConcurrentRequests      int // Maximum number of concurrent API requests (0 = no limit)
        RateLimitRequestsPerMinute int // Maximum requests per minute per model (0 = no limit)
}

// NewDefaultCliConfig returns a CliConfig with default values.
// This is used as a starting point before parsing CLI flags, ensuring
// that all fields have sensible defaults even if not explicitly set
// by the user.
func NewDefaultCliConfig() *CliConfig <span class="cov8" title="1">{
        return &amp;CliConfig{
                Format:                     DefaultFormat,
                Exclude:                    DefaultExcludes,
                ExcludeNames:               DefaultExcludeNames,
                ModelNames:                 []string{DefaultModel},
                LogLevel:                   logutil.InfoLevel,
                MaxConcurrentRequests:      DefaultMaxConcurrentRequests,
                RateLimitRequestsPerMinute: DefaultRateLimitRequestsPerMinute,
        }
}</span>

// ValidateConfig checks if the configuration is valid and returns an error if not.
// It performs validation beyond simple type-checking, such as verifying that
// required fields are present, paths exist, and values are within acceptable ranges.
// This helps catch configuration errors early before they cause runtime failures.
func ValidateConfig(config *CliConfig, logger logutil.LoggerInterface) error <span class="cov8" title="1">{
        // Handle nil config
        if config == nil </span><span class="cov8" title="1">{
                if logger != nil </span><span class="cov8" title="1">{
                        logger.Error("Configuration is nil")
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("nil config provided")</span>
        }

        // Define a safe logger function that won't panic if logger is nil
        <span class="cov8" title="1">logError := func(format string, args ...interface{}) </span><span class="cov8" title="1">{
                if logger != nil </span><span class="cov8" title="1">{
                        logger.Error(format, args...)
                }</span>
        }

        // Check for valid paths (always required)
        <span class="cov8" title="1">validPaths := false
        if len(config.Paths) &gt; 0 </span><span class="cov8" title="1">{
                for _, path := range config.Paths </span><span class="cov8" title="1">{
                        if len(strings.TrimSpace(path)) &gt; 0 </span><span class="cov8" title="1">{
                                validPaths = true
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">if !validPaths </span><span class="cov8" title="1">{
                logError("At least one file or directory path must be provided as an argument.")
                return fmt.Errorf("no paths specified")
        }</span>

        // Check for instructions file (required unless in dry run mode)
        <span class="cov8" title="1">if config.InstructionsFile == "" &amp;&amp; !config.DryRun </span><span class="cov8" title="1">{
                logError("The required --instructions flag is missing.")
                return fmt.Errorf("missing required --instructions flag")
        }</span>

        // Check for API key (always required)
        <span class="cov8" title="1">if config.APIKey == "" </span><span class="cov8" title="1">{
                logError("%s environment variable not set.", APIKeyEnvVar)
                return fmt.Errorf("API key not set")
        }</span>

        // Check for model names (required unless in dry run mode)
        <span class="cov8" title="1">if len(config.ModelNames) == 0 &amp;&amp; !config.DryRun </span><span class="cov8" title="1">{
                logError("At least one model must be specified with --model flag.")
                return fmt.Errorf("no models specified")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>

		<pre class="file" id="file17" style="display: none">// internal/fileutil/fileutil.go
package fileutil

import (
        "bytes"
        "log"
        "os"
        "os/exec"
        "path/filepath"
        "slices"
        "strings"
        "unicode"

        "github.com/phrazzld/architect/internal/logutil"
)

// FileMeta represents a file with its path and content.
type FileMeta struct {
        Path    string
        Content string
}

// Config holds file processing configuration
type Config struct {
        Verbose        bool
        IncludeExts    []string
        ExcludeExts    []string
        ExcludeNames   []string
        Format         string
        Logger         logutil.LoggerInterface
        GitAvailable   bool
        processedFiles int
        totalFiles     int               // For verbose logging
        fileCollector  func(path string) // Optional callback to collect processed file paths
}

// NewConfig creates a configuration with defaults.
func NewConfig(verbose bool, include, exclude, excludeNames, format string, logger logutil.LoggerInterface) *Config <span class="cov8" title="1">{
        // Check if git is available
        _, gitErr := exec.LookPath("git")
        gitAvailable := gitErr == nil

        if logger == nil </span><span class="cov0" title="0">{
                stdLogger := log.New(os.Stderr, "[fileutil] ", log.LstdFlags)
                logger = logutil.NewStdLoggerAdapter(stdLogger)
        }</span>

        <span class="cov8" title="1">cfg := &amp;Config{
                Verbose:      verbose,
                Format:       format,
                Logger:       logger,
                GitAvailable: gitAvailable,
        }

        // Process include/exclude extensions
        if include != "" </span><span class="cov8" title="1">{
                cfg.IncludeExts = strings.Split(include, ",")
                for i, ext := range cfg.IncludeExts </span><span class="cov8" title="1">{
                        ext = strings.TrimSpace(ext)
                        if !strings.HasPrefix(ext, ".") </span><span class="cov8" title="1">{
                                ext = "." + ext
                        }</span>
                        <span class="cov8" title="1">cfg.IncludeExts[i] = strings.ToLower(ext)</span>
                }
        }
        <span class="cov8" title="1">if exclude != "" </span><span class="cov8" title="1">{
                cfg.ExcludeExts = strings.Split(exclude, ",")
                for i, ext := range cfg.ExcludeExts </span><span class="cov8" title="1">{
                        ext = strings.TrimSpace(ext)
                        if !strings.HasPrefix(ext, ".") </span><span class="cov8" title="1">{
                                ext = "." + ext
                        }</span>
                        <span class="cov8" title="1">cfg.ExcludeExts[i] = strings.ToLower(ext)</span>
                }
        }
        // Process exclude names
        <span class="cov8" title="1">if excludeNames != "" </span><span class="cov8" title="1">{
                cfg.ExcludeNames = strings.Split(excludeNames, ",")
                for i, name := range cfg.ExcludeNames </span><span class="cov8" title="1">{
                        cfg.ExcludeNames[i] = strings.TrimSpace(name)
                }</span>
        }

        <span class="cov8" title="1">return cfg</span>
}

// SetFileCollector sets a callback function that will be called for each processed file
func (c *Config) SetFileCollector(collector func(path string)) <span class="cov8" title="1">{
        c.fileCollector = collector
}</span>

// isGitIgnored checks if a file is likely ignored by git or is hidden.
func isGitIgnored(path string, config *Config) bool <span class="cov8" title="1">{
        base := filepath.Base(path)
        // Always ignore .git directory contents implicitly
        if base == ".git" || strings.Contains(path, string(filepath.Separator)+".git"+string(filepath.Separator)) </span><span class="cov8" title="1">{
                return true
        }</span>

        // Use git check-ignore if available
        <span class="cov8" title="1">if config.GitAvailable </span><span class="cov8" title="1">{
                dir := filepath.Dir(path)
                // Check if the directory is actually a git repo first
                gitRepoCheck := exec.Command("git", "-C", dir, "rev-parse", "--is-inside-work-tree")
                if gitRepoCheck.Run() == nil </span><span class="cov8" title="1">{ // If it is a git repo
                        cmd := exec.Command("git", "-C", dir, "check-ignore", "-q", base)
                        err := cmd.Run()
                        if err == nil </span><span class="cov8" title="1">{ // Exit code 0: file IS ignored
                                config.Logger.Printf("Verbose: Git ignored: %s\n", path)
                                return true
                        }</span>
                        <span class="cov8" title="1">if exitErr, ok := err.(*exec.ExitError); ok &amp;&amp; exitErr.ExitCode() == 1 </span>{<span class="cov8" title="1">
                                // Exit code 1: file is NOT ignored
                                // Continue to other checks like hidden files
                        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                                // Other errors running check-ignore, log it but fall back
                                config.Logger.Printf("Verbose: Error running git check-ignore for %s: %v. Falling back.\n", path, err)
                        }</span>
                }
                // If not a git repo or check-ignore failed non-fatally, proceed to hidden check
        }

        // Fallback or additional check: Check if the file/directory itself is hidden
        <span class="cov8" title="1">if strings.HasPrefix(base, ".") &amp;&amp; base != "." &amp;&amp; base != ".." </span><span class="cov8" title="1">{
                config.Logger.Printf("Verbose: Hidden file/dir ignored: %s\n", path)
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// Constants for binary file detection
const (
        binarySampleSize            = 512
        binaryNonPrintableThreshold = 0.3
)

// isBinaryFile checks if content is likely binary.
func isBinaryFile(content []byte) bool <span class="cov8" title="1">{
        if len(content) &gt; 0 &amp;&amp; bytes.IndexByte(content, 0) != -1 </span><span class="cov8" title="1">{
                return true // Contains null byte
        }</span>
        <span class="cov8" title="1">nonPrintable := 0
        sampleSize := min(len(content), binarySampleSize)
        for i := 0; i &lt; sampleSize; i++ </span><span class="cov8" title="1">{
                if content[i] &lt; 32 &amp;&amp; !isWhitespace(content[i]) </span><span class="cov8" title="1">{
                        nonPrintable++
                }</span>
        }
        <span class="cov8" title="1">return float64(nonPrintable) &gt; float64(sampleSize)*binaryNonPrintableThreshold</span>
}

func isWhitespace(b byte) bool <span class="cov8" title="1">{
        return b == '\n' || b == '\r' || b == '\t' || b == ' '
}</span>

// shouldProcess checks all filters for a given file path.
func shouldProcess(path string, config *Config) bool <span class="cov8" title="1">{
        base := filepath.Base(path)
        ext := strings.ToLower(filepath.Ext(path))

        // Check if explicitly excluded by name
        if len(config.ExcludeNames) &gt; 0 &amp;&amp; slices.Contains(config.ExcludeNames, base) </span><span class="cov8" title="1">{
                config.Logger.Printf("Verbose: Skipping excluded name: %s\n", path)
                return false
        }</span>

        // Check if gitignored or hidden (handles .git implicitly)
        <span class="cov8" title="1">if isGitIgnored(path, config) </span><span class="cov8" title="1">{
                return false // Logging done within isGitIgnored
        }</span>

        // Check include extensions (if specified)
        <span class="cov8" title="1">if len(config.IncludeExts) &gt; 0 </span><span class="cov8" title="1">{
                included := false
                for _, includeExt := range config.IncludeExts </span><span class="cov8" title="1">{
                        if ext == includeExt </span><span class="cov8" title="1">{
                                included = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !included </span><span class="cov8" title="1">{
                        config.Logger.Printf("Verbose: Skipping non-included extension: %s (%s)\n", path, ext)
                        return false
                }</span>
        }

        // Check exclude extensions
        <span class="cov8" title="1">if len(config.ExcludeExts) &gt; 0 </span><span class="cov8" title="1">{
                for _, excludeExt := range config.ExcludeExts </span><span class="cov8" title="1">{
                        if ext == excludeExt </span><span class="cov8" title="1">{
                                config.Logger.Printf("Verbose: Skipping excluded extension: %s (%s)\n", path, ext)
                                return false
                        }</span>
                }
        }

        <span class="cov8" title="1">return true</span>
}

// processFile reads, checks, and adds a file to the FileMeta slice.
func processFile(path string, files *[]FileMeta, config *Config) <span class="cov8" title="1">{
        config.totalFiles++ // Increment total count when we attempt to process

        // Run all checks first
        if !shouldProcess(path, config) </span><span class="cov8" title="1">{
                return // Already logged why it was skipped
        }</span>

        <span class="cov8" title="1">content, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                config.Logger.Printf("Warning: Cannot read file %s: %v\n", path, err)
                return
        }</span>

        <span class="cov8" title="1">if isBinaryFile(content) </span><span class="cov8" title="1">{
                config.Logger.Printf("Verbose: Skipping binary file: %s\n", path)
                return
        }</span>

        // If all checks pass, process it
        <span class="cov8" title="1">config.processedFiles++
        config.Logger.Printf("Verbose: Processing file (%d/%d): %s (size: %d bytes)\n",
                config.processedFiles, config.totalFiles, path, len(content))

        // If a file collector is set, call it
        if config.fileCollector != nil </span><span class="cov8" title="1">{
                config.fileCollector(path)
        }</span>

        // Convert to absolute path if it's not already
        <span class="cov8" title="1">absPath := path
        if !filepath.IsAbs(path) </span><span class="cov8" title="1">{
                // If this fails, just use the original path
                if abs, err := filepath.Abs(path); err == nil </span><span class="cov8" title="1">{
                        absPath = abs
                }</span> else<span class="cov0" title="0"> {
                        config.Logger.Printf("Warning: Could not convert %s to absolute path: %v\n", path, err)
                }</span>
        }

        // Create a FileMeta and add it to the slice
        <span class="cov8" title="1">*files = append(*files, FileMeta{
                Path:    absPath,
                Content: string(content),
        })</span>
}

// GatherProjectContext walks paths and gathers files into a slice of FileMeta.
func GatherProjectContext(paths []string, config *Config) ([]FileMeta, int, error) <span class="cov8" title="1">{
        var files []FileMeta

        config.processedFiles = 0
        config.totalFiles = 0

        for _, p := range paths </span><span class="cov8" title="1">{
                info, err := os.Stat(p)
                if err != nil </span><span class="cov8" title="1">{
                        config.Logger.Printf("Warning: Cannot stat path %s: %v. Skipping.\n", p, err)
                        continue</span>
                }

                <span class="cov8" title="1">if info.IsDir() </span><span class="cov8" title="1">{
                        // Walk the directory
                        err := filepath.WalkDir(p, func(subPath string, d os.DirEntry, err error) error </span><span class="cov8" title="1">{
                                if err != nil </span><span class="cov8" title="1">{
                                        config.Logger.Printf("Warning: Error accessing path %s during walk: %v\n", subPath, err)
                                        return err // Report error up
                                }</span>

                                // Check if the directory itself should be skipped (e.g., .git, node_modules)
                                <span class="cov8" title="1">if d.IsDir() </span><span class="cov8" title="1">{
                                        if isGitIgnored(subPath, config) || slices.Contains(config.ExcludeNames, d.Name()) </span><span class="cov8" title="1">{
                                                config.Logger.Printf("Verbose: Skipping directory: %s\n", subPath)
                                                return filepath.SkipDir // Skip this whole directory
                                        }</span>
                                        <span class="cov8" title="1">return nil</span> // Continue walking into directory
                                }

                                // It's a file, process it
                                <span class="cov8" title="1">if !d.IsDir() </span><span class="cov8" title="1">{
                                        processFile(subPath, &amp;files, config)
                                }</span>

                                <span class="cov8" title="1">return nil</span> // Continue walking
                        })
                        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                config.Logger.Printf("Error walking directory %s: %v\n", p, err)
                                // Continue with other paths if possible
                        }</span>
                } else<span class="cov8" title="1"> {
                        // It's a single file
                        processFile(p, &amp;files, config)
                }</span>
        }

        <span class="cov8" title="1">return files, config.processedFiles, nil</span>
}

// CalculateStatistics calculates basic string stats.
func CalculateStatistics(content string) (charCount, lineCount, tokenCount int) <span class="cov8" title="1">{
        charCount = len(content)
        lineCount = strings.Count(content, "\n") + 1
        tokenCount = estimateTokenCount(content) // Fallback estimation
        return charCount, lineCount, tokenCount
}</span>

// estimateTokenCount counts tokens simply by whitespace boundaries.
// This is kept as a fallback method in case the API token counting fails.
func estimateTokenCount(text string) int <span class="cov8" title="1">{
        count := 0
        inToken := false
        for _, r := range text </span><span class="cov8" title="1">{
                if unicode.IsSpace(r) </span><span class="cov8" title="1">{
                        if inToken </span><span class="cov8" title="1">{
                                count++
                                inToken = false
                        }</span>
                } else<span class="cov8" title="1"> {
                        inToken = true
                }</span>
        }
        <span class="cov8" title="1">if inToken </span><span class="cov8" title="1">{
                count++
        }</span>
        <span class="cov8" title="1">return count</span>
}
</pre>

		<pre class="file" id="file18" style="display: none">package fileutil

import (
        "fmt"
        "strings"
        "sync"

        "github.com/phrazzld/architect/internal/logutil"
)

// MockLogger implements logutil.LoggerInterface for testing
type MockLogger struct {
        mutex       sync.Mutex
        messages    []string
        debugMsgs   []string
        infoMsgs    []string
        warnMsgs    []string
        errorMsgs   []string
        fatalMsgs   []string
        logLevel    logutil.LogLevel
        verboseMode bool
}

// NewMockLogger creates a new mock logger for testing
func NewMockLogger() *MockLogger <span class="cov8" title="1">{
        return &amp;MockLogger{
                messages:    make([]string, 0),
                debugMsgs:   make([]string, 0),
                infoMsgs:    make([]string, 0),
                warnMsgs:    make([]string, 0),
                errorMsgs:   make([]string, 0),
                fatalMsgs:   make([]string, 0),
                logLevel:    logutil.DebugLevel, // Default to debug for tests
                verboseMode: true,
        }
}</span>

// Println implements LoggerInterface.Println
func (m *MockLogger) Println(v ...interface{}) <span class="cov0" title="0">{
        msg := fmt.Sprintln(v...)
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.messages = append(m.messages, msg)
        m.infoMsgs = append(m.infoMsgs, msg)
}</span>

// Printf logs a formatted message at the default level
func (m *MockLogger) Printf(format string, args ...interface{}) <span class="cov8" title="1">{
        // Only log if we're in verbose mode and the format starts with "Verbose:"
        if m.verboseMode || !strings.HasPrefix(format, "Verbose:") </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(format, args...)
                m.mutex.Lock()
                defer m.mutex.Unlock()
                m.messages = append(m.messages, msg)
        }</span>
}

// Debug logs a formatted message at debug level
func (m *MockLogger) Debug(format string, args ...interface{}) <span class="cov0" title="0">{
        if m.logLevel &lt;= logutil.DebugLevel </span><span class="cov0" title="0">{
                msg := fmt.Sprintf(format, args...)
                m.mutex.Lock()
                defer m.mutex.Unlock()
                m.messages = append(m.messages, msg)
                m.debugMsgs = append(m.debugMsgs, msg)
        }</span>
}

// Info logs a formatted message at info level
func (m *MockLogger) Info(format string, args ...interface{}) <span class="cov0" title="0">{
        if m.logLevel &lt;= logutil.InfoLevel </span><span class="cov0" title="0">{
                msg := fmt.Sprintf(format, args...)
                m.mutex.Lock()
                defer m.mutex.Unlock()
                m.messages = append(m.messages, msg)
                m.infoMsgs = append(m.infoMsgs, msg)
        }</span>
}

// Warn logs a formatted message at warn level
func (m *MockLogger) Warn(format string, args ...interface{}) <span class="cov0" title="0">{
        if m.logLevel &lt;= logutil.WarnLevel </span><span class="cov0" title="0">{
                msg := fmt.Sprintf(format, args...)
                m.mutex.Lock()
                defer m.mutex.Unlock()
                m.messages = append(m.messages, msg)
                m.warnMsgs = append(m.warnMsgs, msg)
        }</span>
}

// Error logs a formatted message at error level
func (m *MockLogger) Error(format string, args ...interface{}) <span class="cov0" title="0">{
        if m.logLevel &lt;= logutil.ErrorLevel </span><span class="cov0" title="0">{
                msg := fmt.Sprintf(format, args...)
                m.mutex.Lock()
                defer m.mutex.Unlock()
                m.messages = append(m.messages, msg)
                m.errorMsgs = append(m.errorMsgs, msg)
        }</span>
}

// Fatal logs a formatted message at fatal level
func (m *MockLogger) Fatal(format string, args ...interface{}) <span class="cov0" title="0">{
        msg := fmt.Sprintf(format, args...)
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.messages = append(m.messages, msg)
        m.fatalMsgs = append(m.fatalMsgs, msg)
        // Note: We don't exit in tests
}</span>

// SetLevel sets the log level
func (m *MockLogger) SetLevel(level logutil.LogLevel) <span class="cov0" title="0">{
        m.logLevel = level
}</span>

// GetLevel returns the current log level
func (m *MockLogger) GetLevel() logutil.LogLevel <span class="cov0" title="0">{
        return m.logLevel
}</span>

// GetMessages returns all logged messages
func (m *MockLogger) GetMessages() []string <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        result := make([]string, len(m.messages))
        copy(result, m.messages)
        return result
}</span>

// GetDebugMessages returns debug level messages
func (m *MockLogger) GetDebugMessages() []string <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        result := make([]string, len(m.debugMsgs))
        copy(result, m.debugMsgs)
        return result
}</span>

// GetInfoMessages returns info level messages
func (m *MockLogger) GetInfoMessages() []string <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        result := make([]string, len(m.infoMsgs))
        copy(result, m.infoMsgs)
        return result
}</span>

// GetWarnMessages returns warn level messages
func (m *MockLogger) GetWarnMessages() []string <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        result := make([]string, len(m.warnMsgs))
        copy(result, m.warnMsgs)
        return result
}</span>

// GetErrorMessages returns error level messages
func (m *MockLogger) GetErrorMessages() []string <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        result := make([]string, len(m.errorMsgs))
        copy(result, m.errorMsgs)
        return result
}</span>

// GetFatalMessages returns fatal level messages
func (m *MockLogger) GetFatalMessages() []string <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        result := make([]string, len(m.fatalMsgs))
        copy(result, m.fatalMsgs)
        return result
}</span>

// ClearMessages clears all logged messages
func (m *MockLogger) ClearMessages() <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.messages = make([]string, 0)
        m.debugMsgs = make([]string, 0)
        m.infoMsgs = make([]string, 0)
        m.warnMsgs = make([]string, 0)
        m.errorMsgs = make([]string, 0)
        m.fatalMsgs = make([]string, 0)
}</span>

// ContainsMessage checks if a message was logged (substring match)
func (m *MockLogger) ContainsMessage(substr string) bool <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()
        for _, msg := range m.messages </span><span class="cov8" title="1">{
                if strings.Contains(msg, substr) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// SetVerbose sets the verbose mode for testing
func (m *MockLogger) SetVerbose(verbose bool) <span class="cov8" title="1">{
        m.verboseMode = verbose
}</span>
</pre>

		<pre class="file" id="file19" style="display: none">// internal/gemini/client.go
package gemini

import (
        "context"

        "github.com/phrazzld/architect/internal/logutil"
)

// ModelConfig holds Gemini model configuration parameters
type ModelConfig struct {
        MaxOutputTokens int32
        Temperature     float32
        TopP            float32
}

// ModelInfo holds model capabilities and limits
type ModelInfo struct {
        Name             string
        InputTokenLimit  int32
        OutputTokenLimit int32
}

// SafetyRating represents a content safety evaluation
type SafetyRating struct {
        Category string
        Blocked  bool
        Score    float32
}

// GenerationResult holds the response from a generate content call
type GenerationResult struct {
        Content       string
        FinishReason  string
        SafetyRatings []SafetyRating
        TokenCount    int32
        Truncated     bool
}

// TokenCount holds the result of a token counting operation
type TokenCount struct {
        Total int32
}

// Client defines the interface for interacting with Gemini API
type Client interface {
        // GenerateContent sends a text prompt to Gemini and returns the generated content
        GenerateContent(ctx context.Context, prompt string) (*GenerationResult, error)

        // CountTokens counts the tokens in a given prompt
        CountTokens(ctx context.Context, prompt string) (*TokenCount, error)

        // GetModelInfo retrieves information about a model (for future implementation)
        GetModelInfo(ctx context.Context) (*ModelInfo, error)

        // GetModelName returns the name of the model being used
        GetModelName() string

        // GetTemperature returns the temperature setting for the model
        GetTemperature() float32

        // GetMaxOutputTokens returns the max output tokens setting for the model
        GetMaxOutputTokens() int32

        // GetTopP returns the topP setting for the model
        GetTopP() float32

        // Close releases resources used by the client
        Close() error
}

// ClientOption defines a function that modifies a client
type ClientOption func(*geminiClient)

// WithHTTPClient allows injecting a custom HTTP client
func WithHTTPClient(client HTTPClient) ClientOption <span class="cov8" title="1">{
        return func(gc *geminiClient) </span><span class="cov8" title="1">{
                gc.httpClient = client
        }</span>
}

// WithLogger allows injecting a custom logger
func WithLogger(logger logutil.LoggerInterface) ClientOption <span class="cov0" title="0">{
        return func(gc *geminiClient) </span><span class="cov0" title="0">{
                gc.logger = logger
        }</span>
}

// NewClient creates a new Gemini client with the given API key, model name, and optional API endpoint
func NewClient(ctx context.Context, apiKey, modelName, apiEndpoint string, opts ...ClientOption) (Client, error) <span class="cov8" title="1">{
        // Convert public options to internal options
        var internalOpts []geminiClientOption
        for _, opt := range opts </span><span class="cov8" title="1">{
                // Conversion is safe as both function types have the same signature
                internalOpts = append(internalOpts, geminiClientOption(opt))
        }</span>

        <span class="cov8" title="1">return newGeminiClient(ctx, apiKey, modelName, apiEndpoint, internalOpts...)</span>
}

// DefaultModelConfig returns a reasonable default model configuration
func DefaultModelConfig() ModelConfig <span class="cov8" title="1">{
        return ModelConfig{
                MaxOutputTokens: 8192, // High limit for plan generation
                Temperature:     0.3,  // Lower temperature for deterministic output
                TopP:            0.9,  // Allow some creativity
        }
}</span>
</pre>

		<pre class="file" id="file20" style="display: none">// Package gemini provides a client for interacting with Google's Gemini API
package gemini

import (
        "errors"
        "fmt"
        "net/http"
        "strings"
)

// ErrorType represents different categories of errors that can occur when using the Gemini API
type ErrorType int

const (
        // ErrorTypeUnknown represents an unknown or uncategorized error
        ErrorTypeUnknown ErrorType = iota

        // ErrorTypeAuth represents authentication and authorization errors
        ErrorTypeAuth

        // ErrorTypeRateLimit represents rate limiting or quota errors
        ErrorTypeRateLimit

        // ErrorTypeInvalidRequest represents invalid request errors
        ErrorTypeInvalidRequest

        // ErrorTypeNotFound represents model not found errors
        ErrorTypeNotFound

        // ErrorTypeServer represents server errors
        ErrorTypeServer

        // ErrorTypeNetwork represents network connectivity errors
        ErrorTypeNetwork

        // ErrorTypeCancelled represents cancelled context errors
        ErrorTypeCancelled

        // ErrorTypeInputLimit represents input token limit exceeded errors
        ErrorTypeInputLimit

        // ErrorTypeContentFiltered represents content filtered by safety settings errors
        ErrorTypeContentFiltered
)

// APIError represents an enhanced error with detailed information
type APIError struct {
        // Original is the original error
        Original error

        // Type is the categorized error type
        Type ErrorType

        // Message is a user-friendly error message
        Message string

        // StatusCode is the HTTP status code (if applicable)
        StatusCode int

        // Suggestion is a helpful suggestion for resolving the error
        Suggestion string

        // Details contains additional error details
        Details string
}

// Error implements the error interface
func (e *APIError) Error() string <span class="cov8" title="1">{
        if e.Original != nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s: %v", e.Message, e.Original)
        }</span>
        <span class="cov8" title="1">return e.Message</span>
}

// Unwrap returns the original error
func (e *APIError) Unwrap() error <span class="cov8" title="1">{
        return e.Original
}</span>

// UserFacingError returns a user-friendly error message with suggestions
func (e *APIError) UserFacingError() string <span class="cov8" title="1">{
        var sb strings.Builder

        // Start with the error message
        sb.WriteString(e.Message)

        // Add suggestions if available
        if e.Suggestion != "" </span><span class="cov8" title="1">{
                sb.WriteString("\n\nSuggestion: ")
                sb.WriteString(e.Suggestion)
        }</span>

        <span class="cov8" title="1">return sb.String()</span>
}

// DebugInfo returns detailed debugging information about the error
func (e *APIError) DebugInfo() string <span class="cov8" title="1">{
        var sb strings.Builder

        sb.WriteString(fmt.Sprintf("Error Type: %v\n", e.Type))
        sb.WriteString(fmt.Sprintf("Message: %s\n", e.Message))

        if e.StatusCode != 0 </span><span class="cov8" title="1">{
                sb.WriteString(fmt.Sprintf("Status Code: %d\n", e.StatusCode))
        }</span>

        <span class="cov8" title="1">if e.Original != nil </span><span class="cov8" title="1">{
                sb.WriteString(fmt.Sprintf("Original Error: %v\n", e.Original))
        }</span>

        <span class="cov8" title="1">if e.Details != "" </span><span class="cov8" title="1">{
                sb.WriteString(fmt.Sprintf("Details: %s\n", e.Details))
        }</span>

        <span class="cov8" title="1">if e.Suggestion != "" </span><span class="cov8" title="1">{
                sb.WriteString(fmt.Sprintf("Suggestion: %s\n", e.Suggestion))
        }</span>

        <span class="cov8" title="1">return sb.String()</span>
}

// IsAPIError checks if an error is an APIError and returns it
func IsAPIError(err error) (*APIError, bool) <span class="cov8" title="1">{
        var apiErr *APIError
        if errors.As(err, &amp;apiErr) </span><span class="cov8" title="1">{
                return apiErr, true
        }</span>
        <span class="cov8" title="1">return nil, false</span>
}

// GetErrorType determines the error type based on the error message and status code
func GetErrorType(err error, statusCode int) ErrorType <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return ErrorTypeUnknown
        }</span>

        <span class="cov8" title="1">errMsg := err.Error()

        // Check for authorization errors
        if statusCode == http.StatusUnauthorized || statusCode == http.StatusForbidden </span><span class="cov8" title="1">{
                return ErrorTypeAuth
        }</span>

        // Check for rate limit or quota errors
        <span class="cov8" title="1">if statusCode == http.StatusTooManyRequests ||
                strings.Contains(errMsg, "rate limit") ||
                strings.Contains(errMsg, "quota") </span><span class="cov8" title="1">{
                return ErrorTypeRateLimit
        }</span>

        // Check for invalid request errors
        <span class="cov8" title="1">if statusCode == http.StatusBadRequest </span><span class="cov8" title="1">{
                return ErrorTypeInvalidRequest
        }</span>

        // Check for not found errors
        <span class="cov8" title="1">if statusCode == http.StatusNotFound </span><span class="cov8" title="1">{
                return ErrorTypeNotFound
        }</span>

        // Check for server errors
        <span class="cov8" title="1">if statusCode &gt;= 500 &amp;&amp; statusCode &lt; 600 </span><span class="cov8" title="1">{
                return ErrorTypeServer
        }</span>

        // Check for content filtering
        <span class="cov8" title="1">if strings.Contains(errMsg, "safety") ||
                strings.Contains(errMsg, "blocked") ||
                strings.Contains(errMsg, "filtered") </span><span class="cov8" title="1">{
                return ErrorTypeContentFiltered
        }</span>

        // Check for token limit errors
        <span class="cov8" title="1">if strings.Contains(errMsg, "token limit") ||
                strings.Contains(errMsg, "tokens exceeds") </span><span class="cov8" title="1">{
                return ErrorTypeInputLimit
        }</span>

        // Check for network errors
        <span class="cov8" title="1">if strings.Contains(errMsg, "network") ||
                strings.Contains(errMsg, "connection") ||
                strings.Contains(errMsg, "timeout") </span><span class="cov8" title="1">{
                return ErrorTypeNetwork
        }</span>

        // Check for cancellation
        <span class="cov8" title="1">if strings.Contains(errMsg, "canceled") ||
                strings.Contains(errMsg, "cancelled") ||
                strings.Contains(errMsg, "deadline exceeded") </span><span class="cov8" title="1">{
                return ErrorTypeCancelled
        }</span>

        <span class="cov8" title="1">return ErrorTypeUnknown</span>
}

// FormatAPIError creates a detailed API error from a standard error
func FormatAPIError(err error, statusCode int) *APIError <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Check if it's already an APIError
        <span class="cov8" title="1">if apiErr, ok := IsAPIError(err); ok </span><span class="cov8" title="1">{
                return apiErr
        }</span>

        // Determine error type
        <span class="cov8" title="1">errType := GetErrorType(err, statusCode)

        // Create base API error
        apiErr := &amp;APIError{
                Original:   err,
                Type:       errType,
                Message:    err.Error(),
                StatusCode: statusCode,
        }

        // Enhance error details based on type
        switch errType </span>{
        case ErrorTypeAuth:<span class="cov8" title="1">
                apiErr.Message = "Authentication failed with the Gemini API"
                apiErr.Suggestion = "Check that your API key is valid and has not expired. Ensure environment variables are set correctly."</span>

        case ErrorTypeRateLimit:<span class="cov8" title="1">
                apiErr.Message = "Request rate limit or quota exceeded on the Gemini API"
                apiErr.Suggestion = "Wait and try again later. Consider adjusting the --max-concurrent and --rate-limit flags to limit request rate. You can also upgrade your API usage tier if this happens frequently."</span>

        case ErrorTypeInvalidRequest:<span class="cov8" title="1">
                apiErr.Message = "Invalid request sent to the Gemini API"
                apiErr.Suggestion = "Check the prompt format and parameters. Ensure they comply with the API requirements."</span>

        case ErrorTypeNotFound:<span class="cov8" title="1">
                apiErr.Message = "The requested model or resource was not found"
                apiErr.Suggestion = "Verify that the model name is correct and that the model is available in your region."</span>

        case ErrorTypeServer:<span class="cov8" title="1">
                apiErr.Message = "Gemini API server error occurred"
                apiErr.Suggestion = "This is typically a temporary issue. Wait a few moments and try again."</span>

        case ErrorTypeNetwork:<span class="cov8" title="1">
                apiErr.Message = "Network error while connecting to the Gemini API"
                apiErr.Suggestion = "Check your internet connection and try again. If persistent, there may be connectivity issues to Google's servers."</span>

        case ErrorTypeCancelled:<span class="cov8" title="1">
                apiErr.Message = "Request to Gemini API was cancelled"
                apiErr.Suggestion = "The operation was interrupted. Try again with a longer timeout if needed."</span>

        case ErrorTypeInputLimit:<span class="cov8" title="1">
                apiErr.Message = "Input token limit exceeded for the Gemini model"
                apiErr.Suggestion = "Reduce the input size by using --include, --exclude, or --exclude-names flags to filter the context."</span>

        case ErrorTypeContentFiltered:<span class="cov8" title="1">
                apiErr.Message = "Content was filtered by Gemini API safety settings"
                apiErr.Suggestion = "Your prompt or content may have triggered safety filters. Review and modify your input to comply with content policies."</span>

        default:<span class="cov8" title="1">
                apiErr.Message = fmt.Sprintf("Error calling Gemini API: %v", err)
                apiErr.Suggestion = "Check the logs for more details or try again."</span>
        }

        <span class="cov8" title="1">return apiErr</span>
}
</pre>

		<pre class="file" id="file21" style="display: none">// internal/gemini/gemini_client.go
package gemini

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "strings"
        "sync"
        "time"

        "github.com/phrazzld/architect/internal/logutil"

        genai "github.com/google/generative-ai-go/genai"
        "google.golang.org/api/option"
)

// HTTPClient is an interface for an HTTP client
type HTTPClient interface {
        Do(req *http.Request) (*http.Response, error)
}

// geminiClient implements the Client interface using Google's genai SDK
type geminiClient struct {
        client      *genai.Client
        model       *genai.GenerativeModel
        modelName   string
        apiKey      string
        apiEndpoint string
        logger      logutil.LoggerInterface

        // Model info caching
        modelInfoCache map[string]*ModelInfo
        modelInfoMutex sync.RWMutex
        httpClient     HTTPClient
}

// geminiClientOption defines a function type for applying options to geminiClient
type geminiClientOption func(*geminiClient)

// newGeminiClient creates a new Gemini client with Google's genai SDK
func newGeminiClient(ctx context.Context, apiKey, modelName, apiEndpoint string, opts ...geminiClientOption) (Client, error) <span class="cov8" title="1">{
        if apiKey == "" </span><span class="cov8" title="1">{
                return nil, errors.New("API key cannot be empty")
        }</span>

        <span class="cov8" title="1">if modelName == "" </span><span class="cov8" title="1">{
                return nil, errors.New("model name cannot be empty")
        }</span>

        // Create standard logger for internal client use
        <span class="cov8" title="1">logger := logutil.NewLogger(logutil.InfoLevel, nil, "[gemini] ")

        // Prepare client options
        var clientOpts []option.ClientOption

        if apiEndpoint != "" </span><span class="cov0" title="0">{
                // Custom endpoint (likely for testing)
                logger.Debug("Using custom Gemini API endpoint: %s", apiEndpoint)
                clientOpts = append(clientOpts,
                        option.WithEndpoint(apiEndpoint),
                        option.WithoutAuthentication()) // Skip auth for mock server
        }</span> else<span class="cov8" title="1"> {
                // Default endpoint with API key
                clientOpts = append(clientOpts, option.WithAPIKey(apiKey))
        }</span>

        // Initialize the Google genai client
        <span class="cov8" title="1">client, err := genai.NewClient(ctx, clientOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Gemini client: %w", err)
        }</span>

        // Initialize the model with default settings
        <span class="cov8" title="1">model := client.GenerativeModel(modelName)
        config := DefaultModelConfig()
        model.SetMaxOutputTokens(config.MaxOutputTokens)
        model.SetTemperature(config.Temperature)
        model.SetTopP(config.TopP)

        // Create the client with default values
        gc := &amp;geminiClient{
                client:         client,
                model:          model,
                modelName:      modelName,
                apiKey:         apiKey,
                apiEndpoint:    apiEndpoint,
                logger:         logger,
                modelInfoCache: make(map[string]*ModelInfo),
                modelInfoMutex: sync.RWMutex{},
                httpClient:     &amp;http.Client{Timeout: 10 * time.Second}, // Default HTTP client
        }

        // Apply any custom options
        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(gc)
        }</span>

        <span class="cov8" title="1">return gc, nil</span>
}

// GenerateContent sends a text prompt to Gemini and returns the generated content
func (c *geminiClient) GenerateContent(ctx context.Context, prompt string) (*GenerationResult, error) <span class="cov8" title="1">{
        if prompt == "" </span><span class="cov8" title="1">{
                return nil, &amp;APIError{
                        Original:   errors.New("prompt cannot be empty"),
                        Type:       ErrorTypeInvalidRequest,
                        Message:    "Cannot generate content with an empty prompt",
                        Suggestion: "Provide a task description using the --task flag or --task-file option",
                }
        }</span>

        // Generate content
        <span class="cov0" title="0">resp, err := c.model.GenerateContent(ctx, genai.Text(prompt))
        if err != nil </span><span class="cov0" title="0">{
                apiErr := FormatAPIError(err, 0)
                // Log detailed info for debugging
                c.logger.Debug("Gemini API Error: %s", apiErr.DebugInfo())
                return nil, apiErr
        }</span>

        // Check for empty response
        <span class="cov0" title="0">if resp == nil </span><span class="cov0" title="0">{
                return nil, &amp;APIError{
                        Original:   errors.New("received nil response from Gemini API"),
                        Type:       ErrorTypeUnknown,
                        Message:    "Received an empty response from the Gemini API",
                        Suggestion: "This is likely a temporary issue. Please try again in a few moments.",
                }
        }</span>

        // Check for empty candidates
        <span class="cov0" title="0">if len(resp.Candidates) == 0 </span><span class="cov0" title="0">{
                return nil, &amp;APIError{
                        Original:   errors.New("received empty candidates from Gemini API"),
                        Type:       ErrorTypeUnknown,
                        Message:    "The Gemini API returned no generation candidates",
                        Suggestion: "This could be due to content filtering. Try modifying your prompt or task description.",
                }
        }</span>

        <span class="cov0" title="0">candidate := resp.Candidates[0]

        // Check for empty content
        if candidate.Content == nil || len(candidate.Content.Parts) == 0 </span><span class="cov0" title="0">{
                return &amp;GenerationResult{
                        Content:       "",
                        FinishReason:  string(candidate.FinishReason),
                        SafetyRatings: mapSafetyRatings(candidate.SafetyRatings),
                        Truncated:     candidate.FinishReason == genai.FinishReasonMaxTokens,
                }, nil
        }</span>

        // Extract text content
        <span class="cov0" title="0">var contentBuilder strings.Builder
        for _, part := range candidate.Content.Parts </span><span class="cov0" title="0">{
                if textPart, ok := part.(genai.Text); ok </span><span class="cov0" title="0">{
                        contentBuilder.WriteString(string(textPart))
                }</span>
        }

        // Get token usage if available
        <span class="cov0" title="0">var tokenCount int32
        if resp.UsageMetadata != nil </span><span class="cov0" title="0">{
                tokenCount = resp.UsageMetadata.TotalTokenCount
        }</span>

        // Build result
        <span class="cov0" title="0">result := &amp;GenerationResult{
                Content:       contentBuilder.String(),
                FinishReason:  string(candidate.FinishReason),
                SafetyRatings: mapSafetyRatings(candidate.SafetyRatings),
                TokenCount:    tokenCount,
                Truncated:     candidate.FinishReason == genai.FinishReasonMaxTokens,
        }

        return result, nil</span>
}

// CountTokens counts the tokens in a given prompt
func (c *geminiClient) CountTokens(ctx context.Context, prompt string) (*TokenCount, error) <span class="cov0" title="0">{
        if prompt == "" </span><span class="cov0" title="0">{
                return &amp;TokenCount{Total: 0}, nil
        }</span>

        <span class="cov0" title="0">resp, err := c.model.CountTokens(ctx, genai.Text(prompt))
        if err != nil </span><span class="cov0" title="0">{
                apiErr := FormatAPIError(err, 0)
                apiErr.Message = "Failed to count tokens in prompt"
                apiErr.Suggestion = "Check your API key and internet connection. This operation is required before sending content to the API."

                // Log detailed info for debugging
                c.logger.Debug("Token counting error: %s", apiErr.DebugInfo())

                return nil, apiErr
        }</span>

        <span class="cov0" title="0">return &amp;TokenCount{
                Total: resp.TotalTokens,
        }, nil</span>
}

// ModelDetailsResponse represents the API response for model details
type ModelDetailsResponse struct {
        Name                       string   `json:"name"`
        BaseModelID                string   `json:"baseModelId"`
        Version                    string   `json:"version"`
        DisplayName                string   `json:"displayName"`
        Description                string   `json:"description"`
        InputTokenLimit            int32    `json:"inputTokenLimit"`
        OutputTokenLimit           int32    `json:"outputTokenLimit"`
        SupportedGenerationMethods []string `json:"supportedGenerationMethods"`
        Temperature                float32  `json:"temperature"`
        TopP                       float32  `json:"topP"`
        TopK                       int32    `json:"topK"`
}

// GetModelInfo retrieves information about the current model
func (c *geminiClient) GetModelInfo(ctx context.Context) (*ModelInfo, error) <span class="cov8" title="1">{
        // Check cache first
        c.modelInfoMutex.RLock()
        if info, ok := c.modelInfoCache[c.modelName]; ok </span><span class="cov8" title="1">{
                c.modelInfoMutex.RUnlock()
                return info, nil
        }</span>
        <span class="cov8" title="1">c.modelInfoMutex.RUnlock()

        // Not in cache, fetch from API
        info, err := c.fetchModelInfo(ctx, c.modelName)
        if err != nil </span><span class="cov8" title="1">{
                // If API fetch fails, use conservative defaults
                c.logger.Warn("Failed to fetch model info for %s: %v. Using default values.", c.modelName, err)

                info = &amp;ModelInfo{
                        Name:             c.modelName,
                        InputTokenLimit:  30720, // Conservative default
                        OutputTokenLimit: 8192,  // Conservative default
                }
        }</span>

        // Cache the result (even default values to avoid repeated failures)
        <span class="cov8" title="1">c.modelInfoMutex.Lock()
        c.modelInfoCache[c.modelName] = info
        c.modelInfoMutex.Unlock()

        return info, nil</span>
}

// fetchModelInfo calls the Generative Language API to get model details
func (c *geminiClient) fetchModelInfo(ctx context.Context, modelName string) (*ModelInfo, error) <span class="cov8" title="1">{
        var url string

        if c.apiEndpoint != "" </span><span class="cov8" title="1">{
                // Use custom endpoint with no authentication
                url = fmt.Sprintf("%s/v1beta/models/%s",
                        strings.TrimSuffix(c.apiEndpoint, "/"), modelName)
        }</span> else<span class="cov8" title="1"> {
                // Use default endpoint with API key
                url = fmt.Sprintf("https://generativelanguage.googleapis.com/v1beta/models/%s?key=%s",
                        modelName, c.apiKey)
        }</span>

        // Create request
        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                apiErr := &amp;APIError{
                        Original:   err,
                        Type:       ErrorTypeNetwork,
                        Message:    "Failed to create HTTP request for model information",
                        Suggestion: "This is likely a temporary issue with network connectivity. Check your internet connection and try again.",
                }
                return nil, apiErr
        }</span>

        // Make the request
        <span class="cov8" title="1">resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                apiErr := &amp;APIError{
                        Original:   err,
                        Type:       ErrorTypeNetwork,
                        Message:    "Failed to connect to Gemini API to fetch model information",
                        Suggestion: "Check your internet connection and try again. If the issue persists, the API might be experiencing downtime.",
                        Details:    err.Error(),
                }
                return nil, apiErr
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Check status code
        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                body, _ := io.ReadAll(resp.Body)
                bodyStr := string(body)

                apiErr := FormatAPIError(
                        fmt.Errorf("API returned error: %s", bodyStr),
                        resp.StatusCode,
                )

                // Add model-specific details
                apiErr.Details = fmt.Sprintf("Model: %s, Status: %d, Response: %s",
                        modelName, resp.StatusCode, bodyStr)

                // For 404 errors, provide more context about the model
                if resp.StatusCode == http.StatusNotFound </span><span class="cov8" title="1">{
                        apiErr.Message = fmt.Sprintf("Model '%s' not found or not accessible", modelName)
                        apiErr.Suggestion = "Check that the model name is correct and that you have access to it. Consider using a different model."
                }</span>

                // Log detailed error for debugging
                <span class="cov8" title="1">c.logger.Debug("Model info error: %s", apiErr.DebugInfo())

                return nil, apiErr</span>
        }

        // Parse response
        <span class="cov8" title="1">var modelDetails ModelDetailsResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;modelDetails); err != nil </span><span class="cov8" title="1">{
                apiErr := &amp;APIError{
                        Original:   err,
                        Type:       ErrorTypeInvalidRequest,
                        Message:    "Failed to parse model information response from Gemini API",
                        Suggestion: "This is likely a temporary API issue or a change in the API response format. Try again later.",
                        Details:    err.Error(),
                }
                return nil, apiErr
        }</span>

        // Convert to our internal model
        <span class="cov8" title="1">info := &amp;ModelInfo{
                Name:             modelDetails.Name,
                InputTokenLimit:  modelDetails.InputTokenLimit,
                OutputTokenLimit: modelDetails.OutputTokenLimit,
        }

        c.logger.Debug("Fetched model info for %s: input limit=%d, output limit=%d",
                modelName, info.InputTokenLimit, info.OutputTokenLimit)

        return info, nil</span>
}

// Close releases resources used by the client
func (c *geminiClient) Close() error <span class="cov0" title="0">{
        if c.client != nil </span><span class="cov0" title="0">{
                return c.client.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetModelName returns the name of the model being used
func (c *geminiClient) GetModelName() string <span class="cov8" title="1">{
        return c.modelName
}</span>

// GetTemperature returns the temperature setting for the model
func (c *geminiClient) GetTemperature() float32 <span class="cov8" title="1">{
        if c.model != nil &amp;&amp; c.model.Temperature != nil </span><span class="cov0" title="0">{
                return *c.model.Temperature
        }</span>
        <span class="cov8" title="1">return DefaultModelConfig().Temperature</span>
}

// GetMaxOutputTokens returns the max output tokens setting for the model
func (c *geminiClient) GetMaxOutputTokens() int32 <span class="cov8" title="1">{
        if c.model != nil &amp;&amp; c.model.MaxOutputTokens != nil </span><span class="cov0" title="0">{
                return int32(*c.model.MaxOutputTokens)
        }</span>
        <span class="cov8" title="1">return DefaultModelConfig().MaxOutputTokens</span>
}

// GetTopP returns the topP setting for the model
func (c *geminiClient) GetTopP() float32 <span class="cov8" title="1">{
        if c.model != nil &amp;&amp; c.model.TopP != nil </span><span class="cov0" title="0">{
                return *c.model.TopP
        }</span>
        <span class="cov8" title="1">return DefaultModelConfig().TopP</span>
}

// mapSafetyRatings converts genai safety ratings to our internal format
func mapSafetyRatings(ratings []*genai.SafetyRating) []SafetyRating <span class="cov8" title="1">{
        if ratings == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">result := make([]SafetyRating, len(ratings))
        for i, rating := range ratings </span><span class="cov8" title="1">{
                result[i] = SafetyRating{
                        Category: string(rating.Category),
                        Blocked:  rating.Blocked,
                        Score:    float32(rating.Probability),
                }
        }</span>

        <span class="cov8" title="1">return result</span>
}
</pre>

		<pre class="file" id="file22" style="display: none">// internal/gemini/mock_client.go
package gemini

import (
        "context"
)

// MockClient implements Client interface for testing
type MockClient struct {
        GenerateContentFunc    func(ctx context.Context, prompt string) (*GenerationResult, error)
        CountTokensFunc        func(ctx context.Context, prompt string) (*TokenCount, error)
        GetModelInfoFunc       func(ctx context.Context) (*ModelInfo, error)
        GetModelNameFunc       func() string
        GetTemperatureFunc     func() float32
        GetMaxOutputTokensFunc func() int32
        GetTopPFunc            func() float32
        CloseFunc              func() error
}

// GenerateContent calls the mocked implementation
func (m *MockClient) GenerateContent(ctx context.Context, prompt string) (*GenerationResult, error) <span class="cov8" title="1">{
        if m.GenerateContentFunc != nil </span><span class="cov8" title="1">{
                return m.GenerateContentFunc(ctx, prompt)
        }</span>
        <span class="cov8" title="1">return &amp;GenerationResult{Content: "Mock response"}, nil</span>
}

// CountTokens calls the mocked implementation
func (m *MockClient) CountTokens(ctx context.Context, prompt string) (*TokenCount, error) <span class="cov8" title="1">{
        if m.CountTokensFunc != nil </span><span class="cov8" title="1">{
                return m.CountTokensFunc(ctx, prompt)
        }</span>
        <span class="cov8" title="1">return &amp;TokenCount{Total: 10}, nil</span> // Simple default
}

// GetModelInfo calls the mocked implementation
func (m *MockClient) GetModelInfo(ctx context.Context) (*ModelInfo, error) <span class="cov8" title="1">{
        if m.GetModelInfoFunc != nil </span><span class="cov8" title="1">{
                return m.GetModelInfoFunc(ctx)
        }</span>
        <span class="cov0" title="0">return &amp;ModelInfo{
                Name:             "mock-model",
                InputTokenLimit:  32000,
                OutputTokenLimit: 8192,
        }, nil</span>
}

// Close calls the mocked implementation
func (m *MockClient) Close() error <span class="cov8" title="1">{
        if m.CloseFunc != nil </span><span class="cov8" title="1">{
                return m.CloseFunc()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetModelName returns the mocked model name
func (m *MockClient) GetModelName() string <span class="cov8" title="1">{
        if m.GetModelNameFunc != nil </span><span class="cov8" title="1">{
                return m.GetModelNameFunc()
        }</span>
        <span class="cov8" title="1">return "mock-model"</span>
}

// GetTemperature returns the mocked temperature
func (m *MockClient) GetTemperature() float32 <span class="cov8" title="1">{
        if m.GetTemperatureFunc != nil </span><span class="cov8" title="1">{
                return m.GetTemperatureFunc()
        }</span>
        <span class="cov8" title="1">return DefaultModelConfig().Temperature</span>
}

// GetMaxOutputTokens returns the mocked max output tokens
func (m *MockClient) GetMaxOutputTokens() int32 <span class="cov8" title="1">{
        if m.GetMaxOutputTokensFunc != nil </span><span class="cov8" title="1">{
                return m.GetMaxOutputTokensFunc()
        }</span>
        <span class="cov8" title="1">return DefaultModelConfig().MaxOutputTokens</span>
}

// GetTopP returns the mocked topP
func (m *MockClient) GetTopP() float32 <span class="cov8" title="1">{
        if m.GetTopPFunc != nil </span><span class="cov8" title="1">{
                return m.GetTopPFunc()
        }</span>
        <span class="cov8" title="1">return DefaultModelConfig().TopP</span>
}

// NewMockClient creates a new mock client for testing
func NewMockClient() *MockClient <span class="cov8" title="1">{
        return &amp;MockClient{
                GetModelInfoFunc: func(ctx context.Context) (*ModelInfo, error) </span><span class="cov8" title="1">{
                        return &amp;ModelInfo{
                                Name:             "mock-model",
                                InputTokenLimit:  32000,
                                OutputTokenLimit: 8192,
                        }, nil
                }</span>,
        }
}
</pre>

		<pre class="file" id="file23" style="display: none">// internal/integration/test_helpers.go
package integration

import (
        "bytes"
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "testing"
        "time"

        "github.com/phrazzld/architect/internal/architect"
        "github.com/phrazzld/architect/internal/auditlog"
        "github.com/phrazzld/architect/internal/config"
        "github.com/phrazzld/architect/internal/gemini"
        "github.com/phrazzld/architect/internal/logutil"
)

// TestEnv holds the testing environment
type TestEnv struct {
        // Test directory where we'll create test files
        TestDir string

        // Captures stdout/stderr
        StdoutBuffer *bytes.Buffer
        StderrBuffer *bytes.Buffer

        // Original stdout/stderr for restoring after test
        OrigStdout *os.File
        OrigStderr *os.File

        // Mock Gemini client
        MockClient *gemini.MockClient

        // Test logger
        Logger logutil.LoggerInterface

        // Mock audit logger
        AuditLogger auditlog.AuditLogger

        // Mock standard input for simulating user inputs
        stdinReader *os.File // The read end of the pipe to use as stdin
        stdinWriter *os.File // The write end of the pipe to simulate user input
        OrigStdin   *os.File

        // Cleanup function to run after test
        Cleanup func()
}

// NewTestEnv creates a new test environment
func NewTestEnv(t *testing.T) *TestEnv <span class="cov8" title="1">{
        // Create a temporary directory for test files
        testDir, err := os.MkdirTemp("", "architect-integration-test-*")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test directory: %v", err)
        }</span>

        // Create buffers to capture stdout/stderr
        <span class="cov8" title="1">stdoutBuffer := &amp;bytes.Buffer{}
        stderrBuffer := &amp;bytes.Buffer{}

        // Save original stdout/stderr
        origStdout := os.Stdout
        origStderr := os.Stderr

        // Create a pipe for stdin simulation (instead of a temp file)
        // r is the read end (which will be used as stdin)
        // w is the write end (which we'll use to simulate user input)
        r, w, err := os.Pipe()
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create pipe for stdin simulation: %v", err)
        }</span>
        <span class="cov8" title="1">origStdin := os.Stdin

        // Create a mock client
        mockClient := gemini.NewMockClient()

        // Create a logger that writes to the stderr buffer
        // StderrBuffer is passed explicitly since we no longer rely on global redirection
        logger := logutil.NewLogger(logutil.DebugLevel, stderrBuffer, "[test] ")

        // Create a no-op audit logger for tests
        auditLogger := auditlog.NewNoOpAuditLogger()

        // Create cleanup function
        cleanup := func() </span><span class="cov8" title="1">{
                // Remove test directory and all contents
                os.RemoveAll(testDir)

                // Restore original stdin (stdout/stderr are no longer redirected globally)
                os.Stdin = origStdin

                // Close pipe file descriptors
                r.Close()
                w.Close()
        }</span>

        <span class="cov8" title="1">return &amp;TestEnv{
                TestDir:      testDir,
                StdoutBuffer: stdoutBuffer,
                StderrBuffer: stderrBuffer,
                OrigStdout:   origStdout,
                OrigStderr:   origStderr,
                MockClient:   mockClient,
                Logger:       logger,
                AuditLogger:  auditLogger,
                stdinReader:  r,
                stdinWriter:  w,
                OrigStdin:    origStdin,
                Cleanup:      cleanup,
        }</span>
}

// Setup prepares the environment
// After refactoring, this function redirects stdin to our pipe reader
// StdoutBuffer and StderrBuffer should be passed explicitly where needed
func (env *TestEnv) Setup() <span class="cov0" title="0">{
        // Set stdin to our pipe reader
        os.Stdin = env.stdinReader
}</span>

// GetBufferedLogger returns a logger that writes to the test environment's stderr buffer
// Use this when you need a fresh logger that writes to the environment's buffer
func (env *TestEnv) GetBufferedLogger(level logutil.LogLevel, prefix string) logutil.LoggerInterface <span class="cov8" title="1">{
        return logutil.NewLogger(level, env.StderrBuffer, prefix)
}</span>

// SimulateUserInput writes data to the stdin pipe writer to simulate user input
func (env *TestEnv) SimulateUserInput(input string) <span class="cov8" title="1">{
        // Write the input to the pipe writer
        // Ensure the input ends with a newline for proper line reading
        if !strings.HasSuffix(input, "\n") </span><span class="cov8" title="1">{
                input += "\n"
        }</span>

        <span class="cov8" title="1">_, err := env.stdinWriter.WriteString(input)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to write to stdin pipe: %v", err))</span>
        }
}

// CreateTestFile creates a file with the given content in the test directory
func (env *TestEnv) CreateTestFile(t *testing.T, relativePath, content string) string <span class="cov8" title="1">{
        // Ensure parent directories exist
        fullPath := filepath.Join(env.TestDir, relativePath)
        parentDir := filepath.Dir(fullPath)

        err := os.MkdirAll(parentDir, 0755)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create directories for test file: %v", err)
        }</span>

        // Write the file
        <span class="cov8" title="1">err = os.WriteFile(fullPath, []byte(content), 0644)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to write test file: %v", err)
        }</span>

        <span class="cov8" title="1">return fullPath</span>
}

// CreateTestDirectory creates a directory in the test environment
func (env *TestEnv) CreateTestDirectory(t *testing.T, relativePath string) string <span class="cov0" title="0">{
        fullPath := filepath.Join(env.TestDir, relativePath)

        err := os.MkdirAll(fullPath, 0755)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test directory: %v", err)
        }</span>

        <span class="cov0" title="0">return fullPath</span>
}

// SetupMockGeminiClient configures the mock client with standard test responses
func (env *TestEnv) SetupMockGeminiClient() <span class="cov8" title="1">{
        // Mock CountTokens
        env.MockClient.CountTokensFunc = func(ctx context.Context, prompt string) (*gemini.TokenCount, error) </span><span class="cov8" title="1">{
                return &amp;gemini.TokenCount{Total: int32(len(prompt) / 4)}, nil // Simple estimation
        }</span>

        // Mock GetModelInfo
        <span class="cov8" title="1">env.MockClient.GetModelInfoFunc = func(ctx context.Context) (*gemini.ModelInfo, error) </span><span class="cov8" title="1">{
                return &amp;gemini.ModelInfo{
                        Name:             "test-model",
                        InputTokenLimit:  100000, // Large enough for most tests
                        OutputTokenLimit: 8192,
                }, nil
        }</span>

        // Mock GenerateContent
        <span class="cov8" title="1">env.MockClient.GenerateContentFunc = func(ctx context.Context, prompt string) (*gemini.GenerationResult, error) </span><span class="cov8" title="1">{
                return &amp;gemini.GenerationResult{
                        Content:      "# Test Generated Plan\n\nThis is a test plan generated by the mock client.\n\n## Details\n\nThe plan would normally contain implementation details based on the prompt.",
                        TokenCount:   1000,
                        FinishReason: "STOP",
                }, nil
        }</span>
}

// SetupXMLValidatingClient configures the mock client to validate XML structure in prompts
func (env *TestEnv) SetupXMLValidatingClient(t *testing.T, expectedPartialMatches ...string) <span class="cov8" title="1">{
        // Mock GenerateContent with XML structure validation
        env.MockClient.GenerateContentFunc = func(ctx context.Context, prompt string) (*gemini.GenerationResult, error) </span><span class="cov8" title="1">{
                // Basic validation - checks for existence of tags
                if !strings.Contains(prompt, "&lt;instructions&gt;") || !strings.Contains(prompt, "&lt;/instructions&gt;") </span><span class="cov0" title="0">{
                        t.Errorf("Prompt missing instructions tags: %s", prompt)
                }</span>

                <span class="cov8" title="1">if !strings.Contains(prompt, "&lt;context&gt;") || !strings.Contains(prompt, "&lt;/context&gt;") </span><span class="cov0" title="0">{
                        t.Errorf("Prompt missing context tags: %s", prompt)
                }</span>

                // Check for XML escaping of special characters
                <span class="cov8" title="1">if strings.Contains(prompt, "&lt;") &amp;&amp; !strings.Contains(prompt, "&amp;lt;") </span><span class="cov0" title="0">{
                        t.Errorf("Potential unescaped &lt; character in content section: %s", prompt)
                }</span>

                <span class="cov8" title="1">if strings.Contains(prompt, "&gt;") &amp;&amp; !strings.Contains(prompt, "&amp;gt;") </span><span class="cov0" title="0">{
                        t.Errorf("Potential unescaped &gt; character in content section: %s", prompt)
                }</span>

                // Check for additional expected partial matches (like filenames)
                <span class="cov8" title="1">for _, partialMatch := range expectedPartialMatches </span><span class="cov8" title="1">{
                        found := false
                        // For each partial match, check if it exists anywhere in the prompt
                        if strings.Contains(prompt, partialMatch) </span><span class="cov8" title="1">{
                                found = true
                        }</span>

                        <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                                t.Errorf("Prompt missing expected content %s: %s", partialMatch, prompt)
                        }</span>
                }

                // If we get here, the validation passed
                <span class="cov8" title="1">return &amp;gemini.GenerationResult{
                        Content:      "# Validated XML Structure Plan\n\nThis content was generated after validating the XML structure of the prompt.",
                        TokenCount:   1000,
                        FinishReason: "STOP",
                }, nil</span>
        }
}

// GetOutputFile reads the content of a file in the test directory
func (env *TestEnv) GetOutputFile(t *testing.T, relativePath string) string <span class="cov0" title="0">{
        fullPath := filepath.Join(env.TestDir, relativePath)

        content, err := os.ReadFile(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to read output file: %v", err)
        }</span>

        <span class="cov0" title="0">return string(content)</span>
}

// CreateInstructionsFile creates a new instructions file for testing
// This helper encapsulates the process of creating properly formatted instruction files
func (env *TestEnv) CreateInstructionsFile(t *testing.T, content string, options ...string) string <span class="cov0" title="0">{
        // Default relative path
        relativePath := "instructions.md"

        // If an option is provided, use it as the relative path
        if len(options) &gt; 0 &amp;&amp; options[0] != "" </span><span class="cov0" title="0">{
                relativePath = options[0]
        }</span>

        // Create the instruction file
        <span class="cov0" title="0">return env.CreateTestFile(t, relativePath, content)</span>
}

// TimeInterval represents a start and end time for measuring concurrent execution
type TimeInterval struct {
        Start time.Time
        End   time.Time
}

// areIntervalsConcurrent checks if a set of time intervals overlap significantly,
// indicating concurrent execution. Returns true if at least half of the intervals
// overlap with at least one other interval.
func areIntervalsConcurrent(intervals []TimeInterval) bool <span class="cov8" title="1">{
        if len(intervals) &lt; 2 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Count overlapping intervals
        <span class="cov8" title="1">overlappingIntervals := 0

        for i := 0; i &lt; len(intervals); i++ </span><span class="cov8" title="1">{
                hasOverlap := false
                for j := 0; j &lt; len(intervals); j++ </span><span class="cov8" title="1">{
                        if i == j </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        // Check if intervals overlap
                        <span class="cov8" title="1">if (intervals[i].Start.Before(intervals[j].End) || intervals[i].Start.Equal(intervals[j].End)) &amp;&amp;
                                (intervals[j].Start.Before(intervals[i].End) || intervals[j].Start.Equal(intervals[i].End)) </span><span class="cov8" title="1">{
                                hasOverlap = true
                                break</span>
                        }
                }

                <span class="cov8" title="1">if hasOverlap </span><span class="cov8" title="1">{
                        overlappingIntervals++
                }</span>
        }

        // Require that at least half of the intervals have overlaps
        <span class="cov8" title="1">return overlappingIntervals &gt;= len(intervals)/2</span>
}

// ------------------------------------------------------------------------
// Common Helper Functions for Integration Tests
// ------------------------------------------------------------------------

// Note: mockIntAPIService is defined in test_runner.go
// We use it here directly to avoid duplication

// CreateGoSourceFile creates a Go source file with customizable content
// It provides a simple way to create standard Go files with default content
// which can be overridden by specifying content.
func (env *TestEnv) CreateGoSourceFile(t *testing.T, relativePath string, content ...string) string <span class="cov0" title="0">{
        t.Helper()

        // Default content if none provided
        fileContent := `package main

import "fmt"

func main() {
        fmt.Println("Hello, world!")
}
`
        // Use provided content if specified
        if len(content) &gt; 0 &amp;&amp; content[0] != "" </span><span class="cov0" title="0">{
                fileContent = content[0]
        }</span>

        <span class="cov0" title="0">return env.CreateTestFile(t, relativePath, fileContent)</span>
}

// CreateStandardConfig creates a standard test configuration with common settings
// It returns a config.CliConfig with defaults that can be customized through parameters
func (env *TestEnv) CreateStandardConfig(t *testing.T, opts ...ConfigOption) *config.CliConfig <span class="cov0" title="0">{
        t.Helper()

        // Create a task file with default content
        instructionsContent := "Implement a new feature to multiply two numbers"
        instructionsFile := env.CreateInstructionsFile(t, instructionsContent)

        // Default model name
        modelName := "test-model"

        // Default output directory
        outputDir := filepath.Join(env.TestDir, "output")

        // Create the default config
        cfg := &amp;config.CliConfig{
                InstructionsFile: instructionsFile,
                OutputDir:        outputDir,
                ModelNames:       []string{modelName},
                APIKey:           "test-api-key",
                Paths:            []string{env.TestDir + "/src"},
                LogLevel:         logutil.InfoLevel,
        }

        // Apply any custom options
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(cfg)
        }</span>

        <span class="cov0" title="0">return cfg</span>
}

// ConfigOption defines a function type for customizing config
type ConfigOption func(*config.CliConfig)

// WithDryRun sets the dry run option
func WithDryRun(dryRun bool) ConfigOption <span class="cov0" title="0">{
        return func(c *config.CliConfig) </span><span class="cov0" title="0">{
                c.DryRun = dryRun
        }</span>
}

// WithInstructionsContent sets custom instructions content and creates the file
func (env *TestEnv) WithInstructionsContent(t *testing.T, content string) ConfigOption <span class="cov0" title="0">{
        t.Helper()
        instructionsFile := env.CreateInstructionsFile(t, content)
        return func(c *config.CliConfig) </span><span class="cov0" title="0">{
                c.InstructionsFile = instructionsFile
        }</span>
}

// WithModelNames sets the model names
func WithModelNames(names ...string) ConfigOption <span class="cov0" title="0">{
        return func(c *config.CliConfig) </span><span class="cov0" title="0">{
                c.ModelNames = names
        }</span>
}

// WithIncludeFilter sets the include filter
func WithIncludeFilter(include string) ConfigOption <span class="cov0" title="0">{
        return func(c *config.CliConfig) </span><span class="cov0" title="0">{
                c.Include = include
        }</span>
}

// WithExcludeFilter sets the exclude filter
func WithExcludeFilter(exclude string) ConfigOption <span class="cov0" title="0">{
        return func(c *config.CliConfig) </span><span class="cov0" title="0">{
                c.Exclude = exclude
        }</span>
}

// WithConfirmTokens sets the confirm tokens threshold
func WithConfirmTokens(threshold int) ConfigOption <span class="cov0" title="0">{
        return func(c *config.CliConfig) </span><span class="cov0" title="0">{
                c.ConfirmTokens = threshold
        }</span>
}

// WithLogLevel sets the log level
func WithLogLevel(level logutil.LogLevel) ConfigOption <span class="cov0" title="0">{
        return func(c *config.CliConfig) </span><span class="cov0" title="0">{
                c.LogLevel = level
        }</span>
}

// WithAuditLogFile sets the audit log file
func WithAuditLogFile(file string) ConfigOption <span class="cov0" title="0">{
        return func(c *config.CliConfig) </span><span class="cov0" title="0">{
                c.AuditLogFile = file
        }</span>
}

// WithPaths sets the paths to analyze
func WithPaths(paths ...string) ConfigOption <span class="cov0" title="0">{
        return func(c *config.CliConfig) </span><span class="cov0" title="0">{
                c.Paths = paths
        }</span>
}

// SetupErrorResponse configures the mock API client to return an error
// This simplifies testing error handling scenarios
func (env *TestEnv) SetupErrorResponse(message string, statusCode int, suggestion string) <span class="cov0" title="0">{
        apiError := &amp;gemini.APIError{
                Message:    message,
                StatusCode: statusCode,
                Suggestion: suggestion,
        }

        // Configure the mock client to return the error for GenerateContent
        env.MockClient.GenerateContentFunc = func(ctx context.Context, prompt string) (*gemini.GenerationResult, error) </span><span class="cov0" title="0">{
                return nil, apiError
        }</span>
}

// SetupTokenLimitExceeded configures the mock client to simulate a token limit exceeded scenario
func (env *TestEnv) SetupTokenLimitExceeded(tokenCount int, modelLimit int) <span class="cov0" title="0">{
        // Configure the token count response
        env.MockClient.CountTokensFunc = func(ctx context.Context, prompt string) (*gemini.TokenCount, error) </span><span class="cov0" title="0">{
                return &amp;gemini.TokenCount{Total: int32(tokenCount)}, nil
        }</span>

        // Configure the model info with a lower limit
        <span class="cov0" title="0">env.MockClient.GetModelInfoFunc = func(ctx context.Context) (*gemini.ModelInfo, error) </span><span class="cov0" title="0">{
                return &amp;gemini.ModelInfo{
                        Name:             "test-model",
                        InputTokenLimit:  int32(modelLimit),
                        OutputTokenLimit: int32(8192),
                }, nil
        }</span>
}

// ExecuteArchitectWithConfig runs architect.Execute with the given config and verifies output
// Returns the error from Execute so tests can further examine it
func (env *TestEnv) ExecuteArchitectWithConfig(t *testing.T, ctx context.Context, cfg *config.CliConfig) error <span class="cov0" title="0">{
        t.Helper()

        // Create a mock API service
        mockApiService := &amp;mockIntAPIService{
                logger:     env.Logger,
                mockClient: env.MockClient,
        }

        // Run architect.Execute with the configured parameters
        return architect.Execute(
                ctx,
                cfg,
                env.Logger,
                env.AuditLogger,
                mockApiService,
        )
}</span>

// VerifyOutputFile checks if an output file exists and contains expected content
func (env *TestEnv) VerifyOutputFile(t *testing.T, relativePath, expectedContent string) bool <span class="cov0" title="0">{
        t.Helper()

        // Full path to the file
        fullPath := filepath.Join(env.TestDir, relativePath)

        // Check if file exists
        if _, err := os.Stat(fullPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                t.Errorf("Output file was not created at %s", fullPath)
                return false
        }</span>

        // Read the content
        <span class="cov0" title="0">content, err := os.ReadFile(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to read output file: %v", err)
                return false
        }</span>

        // Check content
        <span class="cov0" title="0">if !strings.Contains(string(content), expectedContent) </span><span class="cov0" title="0">{
                t.Errorf("Output file does not contain expected content %q", expectedContent)
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// VerifyOutputFileNotExists checks that an output file does not exist
func (env *TestEnv) VerifyOutputFileNotExists(t *testing.T, relativePath string) bool <span class="cov0" title="0">{
        t.Helper()

        // Full path to the file
        fullPath := filepath.Join(env.TestDir, relativePath)

        // Check if file exists
        if _, err := os.Stat(fullPath); !os.IsNotExist(err) </span><span class="cov0" title="0">{
                t.Errorf("Output file was created when it should not have been: %s", fullPath)
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// SetupStandardTestFiles creates a standard set of test files in the /src directory
// Returns the path to the created directory
func (env *TestEnv) SetupStandardTestFiles(t *testing.T) string <span class="cov0" title="0">{
        t.Helper()

        // Create source directory
        srcDir := env.CreateTestDirectory(t, "src")

        // Create main.go
        env.CreateGoSourceFile(t, "src/main.go", "")

        // Create utils.go
        env.CreateTestFile(t, "src/utils.go", `package main

func add(a, b int) int {
        return a + b
}`)

        return srcDir
}</span>

// RunStandardTest runs a standard test with configurable options
// This encapsulates the common pattern of setting up a test environment,
// configuring it, and running architect.Execute
func (env *TestEnv) RunStandardTest(t *testing.T, opts ...ConfigOption) (error, string) <span class="cov0" title="0">{
        t.Helper()

        // Set up the mock client with standard responses
        env.SetupMockGeminiClient()

        // Create standard files
        env.SetupStandardTestFiles(t)

        // Create config with the provided options
        cfg := env.CreateStandardConfig(t, opts...)

        // Run architect.Execute
        ctx := context.Background()
        err := env.ExecuteArchitectWithConfig(t, ctx, cfg)

        // Calculate the expected output file path
        var outputPath string
        if len(cfg.ModelNames) &gt; 0 </span><span class="cov0" title="0">{
                modelName := cfg.ModelNames[0]
                outputPath = filepath.Join("output", modelName+".md")
        }</span>

        <span class="cov0" title="0">return err, outputPath</span>
}
</pre>

		<pre class="file" id="file24" style="display: none">// internal/integration/test_runner.go
package integration

import (
        "context"
        "fmt"

        "github.com/phrazzld/architect/internal/architect"
        "github.com/phrazzld/architect/internal/config"
        "github.com/phrazzld/architect/internal/gemini"
        "github.com/phrazzld/architect/internal/logutil"
)

// mockIntAPIService implements the architect.APIService interface for testing
// This type is actually used by running tests but wasn't detected by linting
type mockIntAPIService struct {
        logger     logutil.LoggerInterface
        mockClient gemini.Client
}

// InitClient returns the mock client instead of creating a real one
func (s *mockIntAPIService) InitClient(ctx context.Context, apiKey, modelName, apiEndpoint string) (gemini.Client, error) <span class="cov8" title="1">{
        // Always return the mock client, ignoring the API key, model name, and API endpoint
        return s.mockClient, nil
}</span>

// ProcessResponse processes the API response and extracts content
func (s *mockIntAPIService) ProcessResponse(result *gemini.GenerationResult) (string, error) <span class="cov8" title="1">{
        // Check for nil result
        if result == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("result is nil")
        }</span>

        // Check for empty content
        <span class="cov8" title="1">if result.Content == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("empty content")
        }</span>

        // Get the original content - with the new architecture, we just return the content
        // directly without any template processing
        <span class="cov8" title="1">return result.Content, nil</span>
}

// IsEmptyResponseError checks if an error is related to empty API responses
func (s *mockIntAPIService) IsEmptyResponseError(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return err.Error() == "empty content" || err.Error() == "result is nil"</span>
}

// IsSafetyBlockedError checks if an error is related to safety filters
func (s *mockIntAPIService) IsSafetyBlockedError(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return err.Error() == "content blocked by safety filters"</span>
}

// GetErrorDetails extracts detailed information from an error
func (s *mockIntAPIService) GetErrorDetails(err error) string <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return err.Error()</span>
}

// RunTestWithConfig runs the architect application with the provided test config and environment
func RunTestWithConfig(
        ctx context.Context,
        testConfig *config.CliConfig,
        env *TestEnv,
) error <span class="cov8" title="1">{
        // Create a mock API service directly without modifying any global variables
        mockApiService := &amp;mockIntAPIService{
                logger:     env.Logger,
                mockClient: env.MockClient,
        }

        // Run the architect application using Execute with the mock API service
        return architect.Execute(
                ctx,
                testConfig,
                env.Logger,
                env.AuditLogger,
                mockApiService,
        )
}</span>
</pre>

		<pre class="file" id="file25" style="display: none">// internal/logutil/logutil.go
package logutil

import (
        "fmt"
        "io"
        "log"
        "os"
        "sync"
        "time"
)

// LoggerInterface defines the common logging interface
// This allows both our structured Logger and the standard log.Logger
// to be used interchangeably
type LoggerInterface interface {
        Println(v ...interface{})
        Printf(format string, v ...interface{})
        Debug(format string, v ...interface{})
        Info(format string, v ...interface{})
        Warn(format string, v ...interface{})
        Error(format string, v ...interface{})
        Fatal(format string, v ...interface{})
}

// StdLoggerAdapter provides a compatibility layer for standard log.Logger
type StdLoggerAdapter struct {
        *log.Logger
}

// NewStdLoggerAdapter wraps a standard logger
func NewStdLoggerAdapter(logger *log.Logger) *StdLoggerAdapter <span class="cov0" title="0">{
        return &amp;StdLoggerAdapter{Logger: logger}
}</span>

// Debug implements LoggerInterface.Debug
func (s *StdLoggerAdapter) Debug(format string, v ...interface{}) <span class="cov0" title="0">{
        s.Logger.Printf("[DEBUG] "+format, v...)
}</span>

// Info implements LoggerInterface.Info
func (s *StdLoggerAdapter) Info(format string, v ...interface{}) <span class="cov0" title="0">{
        s.Logger.Printf("[INFO] "+format, v...)
}</span>

// Warn implements LoggerInterface.Warn
func (s *StdLoggerAdapter) Warn(format string, v ...interface{}) <span class="cov0" title="0">{
        s.Logger.Printf("[WARN] "+format, v...)
}</span>

// Error implements LoggerInterface.Error
func (s *StdLoggerAdapter) Error(format string, v ...interface{}) <span class="cov0" title="0">{
        s.Logger.Printf("[ERROR] "+format, v...)
}</span>

// Fatal implements LoggerInterface.Fatal
func (s *StdLoggerAdapter) Fatal(format string, v ...interface{}) <span class="cov0" title="0">{
        s.Logger.Fatalf("[FATAL] "+format, v...)
}</span>

// LogLevel represents different logging severity levels
type LogLevel int

const (
        // Log levels in increasing order of severity
        DebugLevel LogLevel = iota
        InfoLevel
        WarnLevel
        ErrorLevel
)

// String returns the string representation of a log level
func (l LogLevel) String() string <span class="cov8" title="1">{
        switch l </span>{
        case DebugLevel:<span class="cov8" title="1">
                return "DEBUG"</span>
        case InfoLevel:<span class="cov8" title="1">
                return "INFO"</span>
        case WarnLevel:<span class="cov8" title="1">
                return "WARN"</span>
        case ErrorLevel:<span class="cov8" title="1">
                return "ERROR"</span>
        default:<span class="cov8" title="1">
                return "UNKNOWN"</span>
        }
}

// Logger provides structured logging with levels
type Logger struct {
        mu     sync.Mutex // Mutex to protect concurrent access
        level  LogLevel   // Current log level
        writer io.Writer  // Where to write logs (typically os.Stderr)
        prefix string     // Prefix for all log messages
}

// Ensure Logger implements LoggerInterface
var _ LoggerInterface = (*Logger)(nil)

// NewLogger creates a new logger with the specified configuration
func NewLogger(level LogLevel, writer io.Writer, prefix string) *Logger <span class="cov8" title="1">{
        if writer == nil </span><span class="cov0" title="0">{
                writer = os.Stderr
        }</span>

        <span class="cov8" title="1">logger := &amp;Logger{
                level:  level,
                writer: writer,
                prefix: prefix,
        }

        return logger</span>
}

// formatMessage creates a formatted log message with timestamp and level
func (l *Logger) formatMessage(level LogLevel, format string, args ...interface{}) string <span class="cov8" title="1">{
        timestamp := time.Now().Format("2006-01-02 15:04:05.000")
        msg := fmt.Sprintf(format, args...)
        return fmt.Sprintf("%s [%s] %s%s", timestamp, level.String(), l.prefix, msg)
}</span>

// log logs a message at the specified level if it meets the threshold
func (l *Logger) log(level LogLevel, format string, args ...interface{}) <span class="cov8" title="1">{
        l.mu.Lock()
        defer l.mu.Unlock()

        if level &lt; l.level </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">formattedMsg := l.formatMessage(level, format, args...)
        fmt.Fprintln(l.writer, formattedMsg)</span>
}

// Debug logs a message at DEBUG level
func (l *Logger) Debug(format string, args ...interface{}) <span class="cov8" title="1">{
        l.log(DebugLevel, format, args...)
}</span>

// Info logs a message at INFO level
func (l *Logger) Info(format string, args ...interface{}) <span class="cov8" title="1">{
        l.log(InfoLevel, format, args...)
}</span>

// Warn logs a message at WARN level
func (l *Logger) Warn(format string, args ...interface{}) <span class="cov0" title="0">{
        l.log(WarnLevel, format, args...)
}</span>

// Error logs a message at ERROR level
func (l *Logger) Error(format string, args ...interface{}) <span class="cov0" title="0">{
        l.log(ErrorLevel, format, args...)
}</span>

// Fatal logs a message at ERROR level and then exits the program
func (l *Logger) Fatal(format string, args ...interface{}) <span class="cov0" title="0">{
        l.log(ErrorLevel, format, args...)
        os.Exit(1)
}</span>

// SetLevel changes the current log level
func (l *Logger) SetLevel(level LogLevel) <span class="cov8" title="1">{
        l.mu.Lock()
        defer l.mu.Unlock()
        l.level = level
}</span>

// SetPrefix changes the prefix used in log messages
func (l *Logger) SetPrefix(prefix string) <span class="cov8" title="1">{
        l.mu.Lock()
        defer l.mu.Unlock()
        l.prefix = prefix
}</span>

// GetLevel returns the current log level
func (l *Logger) GetLevel() LogLevel <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()
        return l.level
}</span>

// Println implements LoggerInterface by logging at info level
func (l *Logger) Println(v ...interface{}) <span class="cov0" title="0">{
        l.Info(fmt.Sprintln(v...))
}</span>

// Printf implements LoggerInterface by logging at info level
func (l *Logger) Printf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.Info(format, v...)
}</span>

// ParseLogLevel converts a string to a LogLevel
func ParseLogLevel(level string) (LogLevel, error) <span class="cov8" title="1">{
        switch level </span>{
        case "debug":<span class="cov8" title="1">
                return DebugLevel, nil</span>
        case "info":<span class="cov8" title="1">
                return InfoLevel, nil</span>
        case "warn":<span class="cov8" title="1">
                return WarnLevel, nil</span>
        case "error":<span class="cov8" title="1">
                return ErrorLevel, nil</span>
        default:<span class="cov8" title="1">
                return InfoLevel, fmt.Errorf("unknown log level: %s", level)</span>
        }
}
</pre>

		<pre class="file" id="file26" style="display: none">// Package ratelimit provides concurrency control and rate limiting functionality
package ratelimit

import (
        "context"
        "errors"
        "sync"

        "golang.org/x/time/rate"
)

var (
        // ErrContextCanceled is returned when the context is canceled during acquisition
        ErrContextCanceled = errors.New("context canceled while waiting for resource")
)

// Semaphore provides a simple mechanism for limiting concurrent operations
type Semaphore struct {
        tickets chan struct{}
}

// NewSemaphore creates a new semaphore with the given capacity
// If maxConcurrent is &lt;= 0, returns nil (no limiting)
func NewSemaphore(maxConcurrent int) *Semaphore <span class="cov8" title="1">{
        if maxConcurrent &lt;= 0 </span><span class="cov8" title="1">{
                return nil // No limit
        }</span>
        <span class="cov8" title="1">return &amp;Semaphore{
                tickets: make(chan struct{}, maxConcurrent),
        }</span>
}

// Acquire gets a ticket from the semaphore, blocking if none are available
// Returns nil if successful, or error if the context is canceled
// Does nothing if semaphore is nil (no limiting)
func (s *Semaphore) Acquire(ctx context.Context) error <span class="cov8" title="1">{
        if s == nil </span><span class="cov8" title="1">{
                return nil // No limiting
        }</span>

        <span class="cov8" title="1">select </span>{
        case s.tickets &lt;- struct{}{}:<span class="cov8" title="1">
                return nil</span>
        case &lt;-ctx.Done():<span class="cov8" title="1">
                return ErrContextCanceled</span>
        }
}

// Release returns a ticket to the semaphore
// Does nothing if semaphore is nil (no limiting)
func (s *Semaphore) Release() <span class="cov8" title="1">{
        if s == nil </span><span class="cov8" title="1">{
                return // No limiting
        }</span>
        <span class="cov8" title="1">select </span>{
        case &lt;-s.tickets:<span class="cov8" title="1"></span>
                // Successfully released a ticket
        default:<span class="cov0" title="0"></span>
                // This should never happen in correct usage
                // but prevents deadlock if Release is called without Acquire
        }
}

// TokenBucket manages rate limiting using a token bucket algorithm
type TokenBucket struct {
        // Map of model names to limiters
        limiters   map[string]*rate.Limiter
        mutex      sync.RWMutex
        ratePerMin int
        limit      rate.Limit
        burst      int
}

// NewTokenBucket creates a new token bucket rate limiter
// If ratePerMin is &lt;= 0, returns nil (no limiting)
func NewTokenBucket(ratePerMin, maxBurst int) *TokenBucket <span class="cov8" title="1">{
        if ratePerMin &lt;= 0 </span><span class="cov8" title="1">{
                return nil // No limit
        }</span>

        // Convert from per-minute to per-second (which is what rate.Limit uses)
        <span class="cov8" title="1">rps := rate.Limit(float64(ratePerMin) / 60.0)

        // Set burst size, defaulting to 1/10 of rate (min 1, max 10)
        if maxBurst &lt;= 0 </span><span class="cov0" title="0">{
                maxBurst = min(max(1, ratePerMin/10), 10)
        }</span>

        <span class="cov8" title="1">return &amp;TokenBucket{
                limiters:   make(map[string]*rate.Limiter),
                ratePerMin: ratePerMin,
                limit:      rps,
                burst:      maxBurst,
        }</span>
}

// getLimiter returns the rate limiter for a specific model, creating it if needed
func (tb *TokenBucket) getLimiter(modelName string) *rate.Limiter <span class="cov8" title="1">{
        // For no limit case
        if tb == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Check if we already have a limiter for this model
        <span class="cov8" title="1">tb.mutex.RLock()
        limiter, exists := tb.limiters[modelName]
        tb.mutex.RUnlock()

        if exists </span><span class="cov8" title="1">{
                return limiter
        }</span>

        // Create a new limiter for this model
        <span class="cov8" title="1">tb.mutex.Lock()
        defer tb.mutex.Unlock()

        // Double-check in case another goroutine created it
        if limiter, exists = tb.limiters[modelName]; exists </span><span class="cov0" title="0">{
                return limiter
        }</span>

        <span class="cov8" title="1">limiter = rate.NewLimiter(tb.limit, tb.burst)
        tb.limiters[modelName] = limiter
        return limiter</span>
}

// Acquire waits to acquire a token, returns error if context canceled
func (tb *TokenBucket) Acquire(ctx context.Context, modelName string) error <span class="cov8" title="1">{
        if tb == nil </span><span class="cov8" title="1">{
                return nil // No limiting
        }</span>

        <span class="cov8" title="1">limiter := tb.getLimiter(modelName)
        if limiter.Allow() </span><span class="cov8" title="1">{
                // Fast path - if we can get a token without waiting
                return nil
        }</span>

        // Slow path - wait for a token to become available
        <span class="cov8" title="1">return limiter.Wait(ctx)</span>
}

// RateLimiter combines semaphore and token bucket limiters
// BUGFIX: Remove unnecessary mutex causing deadlocks in concurrent Acquire/Release calls.
// CAUSE: Holding rl.mu across blocking calls (semaphore.Acquire, tokenBucket.Acquire)
//
//        prevented Release calls (which also needed rl.mu) from freeing resources,
//        leading to deadlock when resources were contended.
//
// FIX: Removed rl.mu entirely. Acquire semaphore then token bucket sequentially.
//
//        Release semaphore immediately if token bucket acquisition fails.
//        The underlying Semaphore and TokenBucket handle their own concurrency.
type RateLimiter struct {
        semaphore   *Semaphore
        tokenBucket *TokenBucket
}

// NewRateLimiter creates a new combined rate limiter
// By default, uses a burst size of 1 for the token bucket to make rate limiting more strict
func NewRateLimiter(maxConcurrent, ratePerMin int) *RateLimiter <span class="cov8" title="1">{
        return &amp;RateLimiter{
                semaphore:   NewSemaphore(maxConcurrent),
                tokenBucket: NewTokenBucket(ratePerMin, 1), // Use explicit burst size of 1 for stricter rate limiting
        }
}</span>

// Acquire waits to acquire both semaphore and rate limit permissions
func (rl *RateLimiter) Acquire(ctx context.Context, modelName string) error <span class="cov8" title="1">{
        // First try to acquire the semaphore
        if err := rl.semaphore.Acquire(ctx); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // If we got the semaphore but fail to get the rate limit, release the semaphore
        <span class="cov8" title="1">if err := rl.tokenBucket.Acquire(ctx, modelName); err != nil </span><span class="cov8" title="1">{
                rl.semaphore.Release()
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Release releases the semaphore (token bucket doesn't need explicit release)
func (rl *RateLimiter) Release() <span class="cov8" title="1">{
        rl.semaphore.Release()
        // No explicit release needed for token bucket
}</span>

// Helper functions for min/max (Go 1.21+ has these in standard math package)
func min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

func max(a, b int) int <span class="cov0" title="0">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}
</pre>

		<pre class="file" id="file27" style="display: none">// Package runutil provides utilities for generating and managing run names
package runutil

import (
        "math/rand"
        "time"
)

// randomSource is a dedicated random source for generating run names
var randomSource = rand.New(rand.NewSource(time.Now().UnixNano()))

// List of adjectives for generating run names
var adjectives = []string{
        "amber", "ancient", "autumn", "bold", "brave", "bright", "calm", "clever",
        "coastal", "cosmic", "crimson", "crystal", "curious", "daring", "deep",
        "distant", "eager", "elegant", "emerald", "enchanted", "endless", "energetic",
        "ethereal", "fierce", "floral", "flowing", "flying", "forest", "gentle",
        "golden", "graceful", "grand", "hidden", "humming", "icy", "infinite",
        "jade", "jolly", "kind", "lively", "lunar", "majestic", "melodic", "mighty",
        "misty", "morning", "mountain", "noble", "ocean", "patient", "peaceful",
        "playful", "poetic", "proud", "purple", "quick", "quiet", "radiant", "rapid",
        "royal", "ruby", "rustic", "serene", "shining", "silent", "silver", "sincere",
        "singing", "skillful", "sleepy", "smiling", "snowy", "solar", "sparkling",
        "spring", "starry", "steadfast", "stormy", "summer", "sunny", "swift",
        "thoughtful", "thundering", "tranquil", "twilight", "vibrant", "wandering",
        "whispering", "wild", "winter", "wise", "zephyr",
}

// List of nouns for generating run names
var nouns = []string{
        "acorn", "archipelago", "aurora", "badger", "beacon", "bear", "birch",
        "bison", "brook", "buzzard", "canyon", "cardinal", "cascade", "cave",
        "cheetah", "cliff", "cloud", "coast", "condor", "coral", "cove", "crater",
        "creek", "dawn", "deer", "delta", "dolphin", "dove", "dragon", "driftwood",
        "dusk", "eagle", "elm", "falcon", "fern", "firefly", "fjord", "flower",
        "forest", "galaxy", "gazelle", "geyser", "glacier", "grove", "harbor",
        "hawk", "heron", "hill", "horizon", "ibex", "iceberg", "island", "jackal",
        "jaguar", "jay", "journey", "koala", "lagoon", "lantern", "leopard", "lighthouse",
        "lightning", "lynx", "maple", "marsh", "meadow", "meteor", "mist", "moon",
        "moose", "mountain", "nebula", "ocean", "osprey", "otter", "owl", "panther",
        "path", "peak", "penguin", "phoenix", "pine", "planet", "plateau", "puma",
        "quail", "rabbit", "raccoon", "rain", "raven", "reef", "ridge", "river",
        "robin", "rock", "satellite", "sea", "sequoia", "shadow", "shore", "sparrow",
        "squirrel", "star", "storm", "stream", "summit", "sun", "sunset", "swift",
        "thunder", "tiger", "tortoise", "trail", "valley", "vapor", "volcano", "wave",
        "willow", "wind", "wolf", "zenith",
}

// GenerateRunName creates a random adjective-noun combination suitable for use
// as a run name or directory name. The result follows the pattern "adjective-noun"
// with all lowercase and a hyphen as separator.
func GenerateRunName() string <span class="cov8" title="1">{
        adjective := adjectives[randomSource.Intn(len(adjectives))]
        noun := nouns[randomSource.Intn(len(nouns))]

        return adjective + "-" + noun
}</span>
</pre>

		<pre class="file" id="file28" style="display: none">// main.go - Simple entry point for architect
package main

import "github.com/phrazzld/architect/cmd/architect"

func main() <span class="cov0" title="0">{
        // Delegate directly to the new main function in the cmd package
        architect.Main()
}</span>
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
